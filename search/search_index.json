{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Flare Network Technical Documentation # Flare Fundamentals Descriptions of Flare's key concepts, technology and tools. User Guides Step-by-step guides for tools like the Explorer or the different wallets. Infrastructure Guides Step-by-step guides to deploy your own Flare network components. Exchange Guides Advice for exchanges willing to support the Flare blockchain. Developer Docs Programming tutorials to help you build your app using Flare's tech. API Reference Guides API documentation and access RPC nodes. These pages are a Work In Progress . Use the contact buttons at the bottom of the page if there is anything you cannot find here! /*Special centered title for the Home page*/ h1 { text-align: center; } /*Remove the \"Last updated\" text at the bottom*/ .md-source-file { display: none; }","title":"Welcome to the Flare Network Technical Documentation"},{"location":"#welcome-to-the-flare-network-technical-documentation","text":"Flare Fundamentals Descriptions of Flare's key concepts, technology and tools. User Guides Step-by-step guides for tools like the Explorer or the different wallets. Infrastructure Guides Step-by-step guides to deploy your own Flare network components. Exchange Guides Advice for exchanges willing to support the Flare blockchain. Developer Docs Programming tutorials to help you build your app using Flare's tech. API Reference Guides API documentation and access RPC nodes. These pages are a Work In Progress . Use the contact buttons at the bottom of the page if there is anything you cannot find here! /*Special centered title for the Home page*/ h1 { text-align: center; } /*Remove the \"Last updated\" text at the bottom*/ .md-source-file { display: none; }","title":"Welcome to the Flare Network Technical Documentation"},{"location":"apis/","text":"APIs # Select one of the topics below: Access Nodes # Public RPC nodes for Flare, Songbird and Coston. Public RPC nodes for connected chains Flare API Portal (private nodes) API Documentation # Flare API web3.js API ethers.js API","title":"APIs"},{"location":"apis/#apis","text":"Select one of the topics below:","title":"APIs"},{"location":"apis/#access-nodes","text":"Public RPC nodes for Flare, Songbird and Coston. Public RPC nodes for connected chains Flare API Portal (private nodes)","title":"Access Nodes"},{"location":"apis/#api-documentation","text":"Flare API web3.js API ethers.js API","title":"API Documentation"},{"location":"dev/","text":"Developer Docs # Quick links Network Configuration Flare Contracts Addresses How to run a node All Flare networks are a fork of the Avalanche project, which runs the Ethereum Virtual Machine . Therefore, all Ethereum contracts and tools work on Flare, Songbird and Coston. All Flare networks are layer-1 networks, and run independently of both Avalanche and Ethereum. You can interact with the Flare networks using wallets , block explorers and the most common blockchain development environments . As an example, all Flare networks support NFTs and many have already been created on Songbird. The block explorer also supports displaying NFTs. Once you have set up your development environment , you can start with the Accessing the Network tutorials. Open-Source Repositories # These are Flare's main source repositories, both on GitHub and GitLab . Validator node Smart contracts Topics # Getting Started Tutorials Reference Guides Tools and Projects","title":"Developer Docs"},{"location":"dev/#developer-docs","text":"Quick links Network Configuration Flare Contracts Addresses How to run a node All Flare networks are a fork of the Avalanche project, which runs the Ethereum Virtual Machine . Therefore, all Ethereum contracts and tools work on Flare, Songbird and Coston. All Flare networks are layer-1 networks, and run independently of both Avalanche and Ethereum. You can interact with the Flare networks using wallets , block explorers and the most common blockchain development environments . As an example, all Flare networks support NFTs and many have already been created on Songbird. The block explorer also supports displaying NFTs. Once you have set up your development environment , you can start with the Accessing the Network tutorials.","title":"Developer Docs"},{"location":"dev/#open-source-repositories","text":"These are Flare's main source repositories, both on GitHub and GitLab . Validator node Smart contracts","title":"Open-Source Repositories"},{"location":"dev/#topics","text":"Getting Started Tutorials Reference Guides Tools and Projects","title":"Topics"},{"location":"dev/tools/","text":"Tools and Projects # The following tools and projects already support the Flare network. Node Providers # Validator nodes are online servers running a blockchain's client software. They ensure that stored data is consistent and provide access to this data for applications. Applications are encouraged to deploy their own nodes for enhanced reliability. The companies below offer nodes-as-a-service, greatly simplifying deployment and operational costs. Flare API Portal Blockdaemon Storage # Storing large amounts of data on-chain is typically very expensive. These are some decentralized storage alternatives. Filecoin IPFS Crust Network Pinata Lighthouse Arweave Indexing and Querying # Blockchains typically store the history of all transactions but not the latest, consolidated state of individual accounts. The companies below provide fast access to this information Covalent SubQuery Wallets # Please see the Wallet user guides for a list of wallets currently supporting the Flare network.","title":"Tools and Projects"},{"location":"dev/tools/#tools-and-projects","text":"The following tools and projects already support the Flare network.","title":"Tools and Projects"},{"location":"dev/tools/#node-providers","text":"Validator nodes are online servers running a blockchain's client software. They ensure that stored data is consistent and provide access to this data for applications. Applications are encouraged to deploy their own nodes for enhanced reliability. The companies below offer nodes-as-a-service, greatly simplifying deployment and operational costs. Flare API Portal Blockdaemon","title":"Node Providers"},{"location":"dev/tools/#storage","text":"Storing large amounts of data on-chain is typically very expensive. These are some decentralized storage alternatives. Filecoin IPFS Crust Network Pinata Lighthouse Arweave","title":"Storage"},{"location":"dev/tools/#indexing-and-querying","text":"Blockchains typically store the history of all transactions but not the latest, consolidated state of individual accounts. The companies below provide fast access to this information Covalent SubQuery","title":"Indexing and Querying"},{"location":"dev/tools/#wallets","text":"Please see the Wallet user guides for a list of wallets currently supporting the Flare network.","title":"Wallets"},{"location":"dev/getting-started/","text":"Getting Started # The following guides provide information to quickly start developing on the Flare networks. Guides # Setting Up Your Environment Retrieving Contract Addresses","title":"Getting Started"},{"location":"dev/getting-started/#getting-started","text":"The following guides provide information to quickly start developing on the Flare networks.","title":"Getting Started"},{"location":"dev/getting-started/#guides","text":"Setting Up Your Environment Retrieving Contract Addresses","title":"Guides"},{"location":"dev/getting-started/contract-addresses/","text":"Retrieving Contract Addresses # Attention Developers should never rely on contract addresses gathered from off-chain sources like direct messages, social media, or even websites, as these addresses could easily lead to malicious contracts. For this reason, this documentation does not provide any contract address except for the single entry point described below. The only secure way to retrieve contract addresses is from the blockchain itself . As a convenience, though, Flare's smart contract repository contains the latest deployment address for all Flare's smart contracts. These addresses can be used to speed up development, but should not be used in production. To emphasize: Applications are strongly encouraged to retrieve any contract address they need directly from the blockchain and not have addresses hard-coded into the source code, except for the single entry point given in this page. Retrieval from Blockchain # All of Flare's smart contract addresses can be retrieved from the FlareContractRegistry contract. This is the only contract address given in this documentation. FlareContractRegistry 0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019 This contract is available at the same address in all Flare networks: Flare, Songbird, Coston and Coston2. Copy the above address into the Block Explorer to see the available contract's methods. You can retrieve the current address on the blockchain of any Flare smart contract from its name by using these methods, for example: function getContractAddressByName ( string calldata _name ) external view returns ( address ); function getContractAddressesByName ( string [] calldata _names ) external view returns ( address [] memory ); The name search is case-sensitive , so you should use the proper capitalization. For example: WNat FtsoRewardManager PriceSubmitter Applications can also retrieve all smart contract names and addresses at once using: function getAllContracts ( ) external view returns ( string [] memory _names , address [] memory _addresses ); Retrieve current list Retrieval from Source Code # The Flare Smart Contracts repository contains an autogenerated JSON file listing the latest deployed addresses of all Flare contracts on each network. You can find this file in the deployment/deploys folder, and parse it to retrieve the addresses of any Flare contract. Attention As stated at the beginning, applications should NOT have Flare contract addresses in their source code. Instead, applications are strongly encouraged to retrieve any contract address they need directly from the blockchain as described above . Branch JSON file Flare flare_network_deployed_code flare.json Songbird songbird_network_deployed_code songbird.json Coston coston_network_deployed_code coston.json Coston2 coston2_network_deployed_code coston2.json const button = document.getElementById(\"contract-list-button\"); const list = document.getElementById(\"contract-list-results\"); button.addEventListener(\"click\", (e) => { e.preventDefault(); button.style.display = \"none\"; list.innerHTML = \"Retrieving...\"; import(\"/assets/javascripts/ethers-6.3.esm.min.js\").then(ethers => { const provider = new ethers.JsonRpcProvider(\"https://flare-api.flare.network/ext/C/rpc\"); const flareContractRegistry = new ethers.Contract( \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\", [\"function getAllContracts() external view returns(string[] memory, address[] memory)\"], provider); const res = flareContractRegistry.getAllContracts().then(res => { list.innerHTML = \"Current smart contract list:\"; var ul=document.createElement('ul'); for (var i = 0; i < res[0].length; ++i) { var li = document.createElement('li'); li.innerHTML = `<code>${res[0][i]}</code>`; ul.appendChild(li); } list.appendChild(ul); }); }); });","title":"Retrieving Contract Addresses"},{"location":"dev/getting-started/contract-addresses/#retrieving-contract-addresses","text":"Attention Developers should never rely on contract addresses gathered from off-chain sources like direct messages, social media, or even websites, as these addresses could easily lead to malicious contracts. For this reason, this documentation does not provide any contract address except for the single entry point described below. The only secure way to retrieve contract addresses is from the blockchain itself . As a convenience, though, Flare's smart contract repository contains the latest deployment address for all Flare's smart contracts. These addresses can be used to speed up development, but should not be used in production. To emphasize: Applications are strongly encouraged to retrieve any contract address they need directly from the blockchain and not have addresses hard-coded into the source code, except for the single entry point given in this page.","title":"Retrieving Contract Addresses"},{"location":"dev/getting-started/contract-addresses/#retrieval-from-blockchain","text":"All of Flare's smart contract addresses can be retrieved from the FlareContractRegistry contract. This is the only contract address given in this documentation. FlareContractRegistry 0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019 This contract is available at the same address in all Flare networks: Flare, Songbird, Coston and Coston2. Copy the above address into the Block Explorer to see the available contract's methods. You can retrieve the current address on the blockchain of any Flare smart contract from its name by using these methods, for example: function getContractAddressByName ( string calldata _name ) external view returns ( address ); function getContractAddressesByName ( string [] calldata _names ) external view returns ( address [] memory ); The name search is case-sensitive , so you should use the proper capitalization. For example: WNat FtsoRewardManager PriceSubmitter Applications can also retrieve all smart contract names and addresses at once using: function getAllContracts ( ) external view returns ( string [] memory _names , address [] memory _addresses ); Retrieve current list","title":"Retrieval from Blockchain"},{"location":"dev/getting-started/contract-addresses/#retrieval-from-source-code","text":"The Flare Smart Contracts repository contains an autogenerated JSON file listing the latest deployed addresses of all Flare contracts on each network. You can find this file in the deployment/deploys folder, and parse it to retrieve the addresses of any Flare contract. Attention As stated at the beginning, applications should NOT have Flare contract addresses in their source code. Instead, applications are strongly encouraged to retrieve any contract address they need directly from the blockchain as described above . Branch JSON file Flare flare_network_deployed_code flare.json Songbird songbird_network_deployed_code songbird.json Coston coston_network_deployed_code coston.json Coston2 coston2_network_deployed_code coston2.json const button = document.getElementById(\"contract-list-button\"); const list = document.getElementById(\"contract-list-results\"); button.addEventListener(\"click\", (e) => { e.preventDefault(); button.style.display = \"none\"; list.innerHTML = \"Retrieving...\"; import(\"/assets/javascripts/ethers-6.3.esm.min.js\").then(ethers => { const provider = new ethers.JsonRpcProvider(\"https://flare-api.flare.network/ext/C/rpc\"); const flareContractRegistry = new ethers.Contract( \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\", [\"function getAllContracts() external view returns(string[] memory, address[] memory)\"], provider); const res = flareContractRegistry.getAllContracts().then(res => { list.innerHTML = \"Current smart contract list:\"; var ul=document.createElement('ul'); for (var i = 0; i < res[0].length; ++i) { var li = document.createElement('li'); li.innerHTML = `<code>${res[0][i]}</code>`; ul.appendChild(li); } list.appendChild(ul); }); }); });","title":"Retrieval from Source Code"},{"location":"dev/getting-started/setup/","text":"Setting Up Your Environment # The following guides provide information to quickly set up a smart contract development environment. Guides # Using Remix Using Hardhat Using Truffle Using Foundry","title":"Setting Up Your Environment"},{"location":"dev/getting-started/setup/#setting-up-your-environment","text":"The following guides provide information to quickly set up a smart contract development environment.","title":"Setting Up Your Environment"},{"location":"dev/getting-started/setup/#guides","text":"Using Remix Using Hardhat Using Truffle Using Foundry","title":"Guides"},{"location":"dev/getting-started/setup/foundry/","text":"Setting Up Your Environment Using Foundry # Foundry is a fast, portable and modular testing and deployment tool for developing EVM smart contracts. Tests are written in Solidity to keep the workflow consistent with smart contract development and testing before deployments. Foundry itself is written in Rust. This article, partially based on the Foundry documentation , shows how to set up Foundry and use it to build and deploy smart contracts on Flare. Guide # 1. Set up the Environment # Follow the instructions for your operating system in the Foundry's Installation guide . 2. Create a Foundry Project # Foundry can quick-start your development by providing a sample project: forge init hello_foundry This creates a new directory hello_foundry from the default template which should look something like this: Foundry project structure. 3. Build the Contract # To build the Counter.sol contract in the sample project run: cd hello_foundry forge build When done, it should print Compiler run successful . You will notice that two new directories have been created, out and cache : Foundry project after build. The out directory contains your contract artifact, such as the ABI, while the cache is used by forge to only recompile what is necessary. 4. Test the Contract # In the test folder you should find a ready-made test file that verifies the contract works as expected. To run tests with Foundry, you just need to run: forge test When finished, it should print something similar to Test result: ok. 2 passed; 0 failed; finished in 24.43ms . Info Learn more about Advanced Testing using Foundry . 5. Deploy the Contract # Forge can deploy only one contract at a time to a given network. To do so, you must provide the URL of the RPC node to access the network, and the private key of the account that will deploy the contract. The URL can be stored in an environment variable named FOUNDRY_ETH_RPC_URL) so you do not need to supply it every time. Important You are going to deploy the contract on the Coston 2 network . Make sure you have enough C2FLR in the account that will deploy the contract to pay the gas fees! You can add C2FLR to any account using the Coston 2 Faucet . The general Foundry command to deploy a contract is: forge create --rpc-url <your_rpc_url> \\ --private-key <your_private_key> \\ <contract_file>:<contract_name> Since Solidity files may contain multiple contracts, the :<contract_name> parameter specifies which contract to deploy from the <contract_file> source file. Learn more about Deploying and Verifying Smart Contracts using Foundry . To deploy the sample Counter contract to Flare's Coston 2 Network, run: forge create --rpc-url https://coston2-api.flare.network/ext/C/rpc \\ --private-key d8936f6eae35c73a14ea7c1aabb8d068e16889a7f516c8abc482ba4e1489f4cd \\ src/Counter.sol:Counter Using the private key for your account. Execution should look similar to this: Foundry project deployment. You can check the status of the contract by copy and pasting the Deployed to: address into the Coston 2 Block Explorer . Info Learn more about Deploying and Verifying Smart Contracts using Foundry !","title":"Using Foundry"},{"location":"dev/getting-started/setup/foundry/#setting-up-your-environment-using-foundry","text":"Foundry is a fast, portable and modular testing and deployment tool for developing EVM smart contracts. Tests are written in Solidity to keep the workflow consistent with smart contract development and testing before deployments. Foundry itself is written in Rust. This article, partially based on the Foundry documentation , shows how to set up Foundry and use it to build and deploy smart contracts on Flare.","title":"Setting Up Your Environment Using Foundry"},{"location":"dev/getting-started/setup/foundry/#guide","text":"","title":"Guide"},{"location":"dev/getting-started/setup/foundry/#1-set-up-the-environment","text":"Follow the instructions for your operating system in the Foundry's Installation guide .","title":"1. Set up the Environment"},{"location":"dev/getting-started/setup/foundry/#2-create-a-foundry-project","text":"Foundry can quick-start your development by providing a sample project: forge init hello_foundry This creates a new directory hello_foundry from the default template which should look something like this: Foundry project structure.","title":"2. Create a Foundry Project"},{"location":"dev/getting-started/setup/foundry/#3-build-the-contract","text":"To build the Counter.sol contract in the sample project run: cd hello_foundry forge build When done, it should print Compiler run successful . You will notice that two new directories have been created, out and cache : Foundry project after build. The out directory contains your contract artifact, such as the ABI, while the cache is used by forge to only recompile what is necessary.","title":"3. Build the Contract"},{"location":"dev/getting-started/setup/foundry/#4-test-the-contract","text":"In the test folder you should find a ready-made test file that verifies the contract works as expected. To run tests with Foundry, you just need to run: forge test When finished, it should print something similar to Test result: ok. 2 passed; 0 failed; finished in 24.43ms . Info Learn more about Advanced Testing using Foundry .","title":"4. Test the Contract"},{"location":"dev/getting-started/setup/foundry/#5-deploy-the-contract","text":"Forge can deploy only one contract at a time to a given network. To do so, you must provide the URL of the RPC node to access the network, and the private key of the account that will deploy the contract. The URL can be stored in an environment variable named FOUNDRY_ETH_RPC_URL) so you do not need to supply it every time. Important You are going to deploy the contract on the Coston 2 network . Make sure you have enough C2FLR in the account that will deploy the contract to pay the gas fees! You can add C2FLR to any account using the Coston 2 Faucet . The general Foundry command to deploy a contract is: forge create --rpc-url <your_rpc_url> \\ --private-key <your_private_key> \\ <contract_file>:<contract_name> Since Solidity files may contain multiple contracts, the :<contract_name> parameter specifies which contract to deploy from the <contract_file> source file. Learn more about Deploying and Verifying Smart Contracts using Foundry . To deploy the sample Counter contract to Flare's Coston 2 Network, run: forge create --rpc-url https://coston2-api.flare.network/ext/C/rpc \\ --private-key d8936f6eae35c73a14ea7c1aabb8d068e16889a7f516c8abc482ba4e1489f4cd \\ src/Counter.sol:Counter Using the private key for your account. Execution should look similar to this: Foundry project deployment. You can check the status of the contract by copy and pasting the Deployed to: address into the Coston 2 Block Explorer . Info Learn more about Deploying and Verifying Smart Contracts using Foundry !","title":"5. Deploy the Contract"},{"location":"dev/getting-started/setup/hardhat/","text":"Setting Up Your Environment Using Hardhat # Hardhat is an environment developers use to test, compile, deploy and debug dapps based on any blockchain compatible Ethereum's EVM . Hardhat is a flexible and extensible task runner that helps you manage and automate the recurring tasks inherent to developing smart contracts and dapps. This article, partially based on the Hardhat documentation shows you how to set up Hardhat and use it to build, test and deploy smart contracts on Flare. Guide # 1. Set up the Environment # Install the following dependencies: NodeJSv12+ LTS and npm/Yarn Package Installer . Tip Check the Official Guide by Hardhat if you have issues installing this package. Once the above dependencies are installed, create an npm empty project by running the following commands in a terminal: mkdir flare-tutorial cd flare-tutorial npm init Press Enter on each of the prompts. Finally, add Hardhat and a few dependencies to the project, since you will use them in this tutorial. npm install --save-dev \\ hardhat \\ @nomicfoundation/hardhat-toolbox \\ @nomiclabs/hardhat-ethers \\ dotenv 2. Create a Hardhat Project # Hardhat can quick-start your development by providing a sample project. Just run: npx hardhat You should see the following prompt: Hardhat project creation prompt. Choose the Create a JavaScript project with the Up and Down keys, and Press Enter . Then press Y for rest of the prompts. When done, it should print Project created . If you take a look in the contracts folder, you should find a sample source file called Lock.sol . It is a Solidity smart contract implementing a simple digital lock, where users can only withdraw funds after a given period of time: // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.9 ; // Uncomment this line to use console.log // import \"hardhat/console.sol\"; contract Lock { uint public unlockTime ; address payable public owner ; event Withdrawal ( uint amount , uint when ); constructor ( uint _unlockTime ) payable { require ( block.timestamp < _unlockTime , \"Unlock time should be in the future\" ); unlockTime = _unlockTime ; owner = payable ( msg.sender ); } function withdraw () public { // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp); require ( block.timestamp >= unlockTime , \"You can't withdraw yet\" ); require ( msg.sender == owner , \"You aren't the owner\" ); emit Withdrawal ( address ( this ). balance , block.timestamp ); owner . transfer ( address ( this ). balance ); } } 3. Compile the Contracts # To compile the sample project, simply run: npx hardhat compile Upon successful compilation it will print Compiled 1 Solidity file successfully . 4. Configure the Project # In order to be deployed on any of the Flare networks , the project needs to be configured. Edit the hardhat.config.js file and replace its contents with the following: require ( 'dotenv' ). config (); require ( \"@nomicfoundation/hardhat-toolbox\" ); require ( '@nomiclabs/hardhat-ethers' ); /** @type import('hardhat/config').HardhatUserConfig */ module . exports = { solidity : \"0.8.17\" , networks : { hardhat : { }, coston : { url : \"https://coston-api.flare.network/ext/bc/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 16 }, songbird : { url : \"https://songbird-api.flare.network/ext/bc/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 19 }, coston2 : { url : \"https://coston2-api.flare.network/ext/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 114 , }, flare : { url : \"https://flare-api.flare.network/ext/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 14 , } }, }; Then, create a file called .env at the root of you project (where the hardhat.config.js file resides) to store the private key for the account to use for testing. .env files are useful to store local information which should not be committed into the source repository. In this tutorial, you need to store your test account's private key in this format: PRIVATE_KEY = \"0x0000000000000000000000000000000000000000000000000000000000000000\" That is, 64 hexadecimal characters after the 0x . Caution Make sure you never upload your .env file to a remote repository. For this reason, the .gitignore file that Hardhat created for you already ignores .env files. 5. Test the Contract # In the test folder you should find a ready-made test file that verifies the contract works as expected. To run tests with Hardhat, you just need to run: npx hardhat test You should get: Lock contract test results. 6. Deploy the Contract # Finally, you will deploy the contract to Flare's test network, Coston2 , using a Hardhat script from the scripts folder. Run this command in the root of the project: npx hardhat run scripts/deploy.js --network coston2 You should get an output similar to: Lock with 1 ETH and unlock timestamp 1705592309 deployed to 0xdC7781FA9fA7e2d0313cd0229a5080B4e30663a5 The last part is the address where the contract has been deployed. You can check the status of the contract by copy and pasting this address in the Block Explorer .","title":"Using Hardhat"},{"location":"dev/getting-started/setup/hardhat/#setting-up-your-environment-using-hardhat","text":"Hardhat is an environment developers use to test, compile, deploy and debug dapps based on any blockchain compatible Ethereum's EVM . Hardhat is a flexible and extensible task runner that helps you manage and automate the recurring tasks inherent to developing smart contracts and dapps. This article, partially based on the Hardhat documentation shows you how to set up Hardhat and use it to build, test and deploy smart contracts on Flare.","title":"Setting Up Your Environment Using Hardhat"},{"location":"dev/getting-started/setup/hardhat/#guide","text":"","title":"Guide"},{"location":"dev/getting-started/setup/hardhat/#1-set-up-the-environment","text":"Install the following dependencies: NodeJSv12+ LTS and npm/Yarn Package Installer . Tip Check the Official Guide by Hardhat if you have issues installing this package. Once the above dependencies are installed, create an npm empty project by running the following commands in a terminal: mkdir flare-tutorial cd flare-tutorial npm init Press Enter on each of the prompts. Finally, add Hardhat and a few dependencies to the project, since you will use them in this tutorial. npm install --save-dev \\ hardhat \\ @nomicfoundation/hardhat-toolbox \\ @nomiclabs/hardhat-ethers \\ dotenv","title":"1. Set up the Environment"},{"location":"dev/getting-started/setup/hardhat/#2-create-a-hardhat-project","text":"Hardhat can quick-start your development by providing a sample project. Just run: npx hardhat You should see the following prompt: Hardhat project creation prompt. Choose the Create a JavaScript project with the Up and Down keys, and Press Enter . Then press Y for rest of the prompts. When done, it should print Project created . If you take a look in the contracts folder, you should find a sample source file called Lock.sol . It is a Solidity smart contract implementing a simple digital lock, where users can only withdraw funds after a given period of time: // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.9 ; // Uncomment this line to use console.log // import \"hardhat/console.sol\"; contract Lock { uint public unlockTime ; address payable public owner ; event Withdrawal ( uint amount , uint when ); constructor ( uint _unlockTime ) payable { require ( block.timestamp < _unlockTime , \"Unlock time should be in the future\" ); unlockTime = _unlockTime ; owner = payable ( msg.sender ); } function withdraw () public { // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp); require ( block.timestamp >= unlockTime , \"You can't withdraw yet\" ); require ( msg.sender == owner , \"You aren't the owner\" ); emit Withdrawal ( address ( this ). balance , block.timestamp ); owner . transfer ( address ( this ). balance ); } }","title":"2. Create a Hardhat Project"},{"location":"dev/getting-started/setup/hardhat/#3-compile-the-contracts","text":"To compile the sample project, simply run: npx hardhat compile Upon successful compilation it will print Compiled 1 Solidity file successfully .","title":"3. Compile the Contracts"},{"location":"dev/getting-started/setup/hardhat/#4-configure-the-project","text":"In order to be deployed on any of the Flare networks , the project needs to be configured. Edit the hardhat.config.js file and replace its contents with the following: require ( 'dotenv' ). config (); require ( \"@nomicfoundation/hardhat-toolbox\" ); require ( '@nomiclabs/hardhat-ethers' ); /** @type import('hardhat/config').HardhatUserConfig */ module . exports = { solidity : \"0.8.17\" , networks : { hardhat : { }, coston : { url : \"https://coston-api.flare.network/ext/bc/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 16 }, songbird : { url : \"https://songbird-api.flare.network/ext/bc/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 19 }, coston2 : { url : \"https://coston2-api.flare.network/ext/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 114 , }, flare : { url : \"https://flare-api.flare.network/ext/C/rpc\" , accounts : [ process . env . PRIVATE_KEY ], chainId : 14 , } }, }; Then, create a file called .env at the root of you project (where the hardhat.config.js file resides) to store the private key for the account to use for testing. .env files are useful to store local information which should not be committed into the source repository. In this tutorial, you need to store your test account's private key in this format: PRIVATE_KEY = \"0x0000000000000000000000000000000000000000000000000000000000000000\" That is, 64 hexadecimal characters after the 0x . Caution Make sure you never upload your .env file to a remote repository. For this reason, the .gitignore file that Hardhat created for you already ignores .env files.","title":"4. Configure the Project"},{"location":"dev/getting-started/setup/hardhat/#5-test-the-contract","text":"In the test folder you should find a ready-made test file that verifies the contract works as expected. To run tests with Hardhat, you just need to run: npx hardhat test You should get: Lock contract test results.","title":"5. Test the Contract"},{"location":"dev/getting-started/setup/hardhat/#6-deploy-the-contract","text":"Finally, you will deploy the contract to Flare's test network, Coston2 , using a Hardhat script from the scripts folder. Run this command in the root of the project: npx hardhat run scripts/deploy.js --network coston2 You should get an output similar to: Lock with 1 ETH and unlock timestamp 1705592309 deployed to 0xdC7781FA9fA7e2d0313cd0229a5080B4e30663a5 The last part is the address where the contract has been deployed. You can check the status of the contract by copy and pasting this address in the Block Explorer .","title":"6. Deploy the Contract"},{"location":"dev/getting-started/setup/remix/","text":"Setting Up Your Environment Using Remix # The Remix IDE is a powerful, open-source tool that helps you write Solidity smart contracts straight from the browser, without requiring any download, account creation, or login. This article shows you how to deploy a Hello World contract to the Flare blockchain using the Remix IDE and the MetaMask wallet. Guide # 1. Create a New File # Visit the Remix IDE and click the New File button. Name it HelloWorld.sol . Drag and drop it to the contracts folder. New file in the Remix IDE. 2. Write Your Contract # Copy and paste the smart contract code provided below into the newly created HelloWorld.sol file. // SPDX-License-Identifier: MIT // Specifies the version of Solidity, using semantic versioning. pragma solidity 0.8.17 ; // Defines a contract named `HelloWorld` contract HelloWorld { // Declares a state variable `message` of type `string`. string public message ; // Constructors are used to initialize the contract's data. constructor ( string memory initMessage ) { // Accepts a string argument `initMessage`. message = initMessage ; } // A public function that accepts a string argument. function update ( string memory newMessage ) public { message = newMessage ; } } 3. Compile Your Contract # Go to the Solidity Compiler tab (on the left), and select compiler version 0.8.17 . Now, click the Compile HelloWorld.sol button. After successful compilation, it will show a Green tick mark on the Compiler tab button. Compilation successful. 4. Deploying on Flare Testnet # You will now deploy the smart contract on the Coston2 network , Flare's test network. When a smart contract is deployed on Flare's main network, it not only costs money (such as gas fees), but it also becomes immutable and cannot be modified. Therefore, deploying your smart contracts first on the test network is highly recommended. Important Before jumping onto Remix Deployment: Make sure that you have added and selected the Coston2 test network to your MetaMask Wallet. The MetaMask Wallet guide shows how to do it. Use the values for Coston2 that you will find in the Network Configurations page. Ensure that you have enough Coston2 native tokens $C2FLR to pay for gas. Visit the Coston2 Faucet to request some $C2FLR . Go to the Deploy & Run Transactions tab (the last one) and select Injected Provider - Metamask from the ENVIRONMENT dropdown. Accept the connection request received in MetaMask if necessary. Environment selection on Remix. Click the Deploy button and confirm the CONTRACT DEPLOYMENT transaction in MetaMask. Contract deployment transaction. Note The process to deploy your contract on the Flare main network is the same as above. You only have to select Flare Network on MetaMask and use $FLR tokens. 5. Interact with the Contract # You can now interact with the contract to verify that it is working as intended. In the Deployed Contracts section at the bottom of the left column, expand the HELLOWORLD contract to see its methods and data: update method. message public variable. Type a message in the box next to the update button and click the button. Confirm the deployment transaction in MetaMask. Check that the contract has been updated by clicking the message button and verifying you get back the message you typed before. Interact with the contract","title":"Using Remix"},{"location":"dev/getting-started/setup/remix/#setting-up-your-environment-using-remix","text":"The Remix IDE is a powerful, open-source tool that helps you write Solidity smart contracts straight from the browser, without requiring any download, account creation, or login. This article shows you how to deploy a Hello World contract to the Flare blockchain using the Remix IDE and the MetaMask wallet.","title":"Setting Up Your Environment Using Remix"},{"location":"dev/getting-started/setup/remix/#guide","text":"","title":"Guide"},{"location":"dev/getting-started/setup/remix/#1-create-a-new-file","text":"Visit the Remix IDE and click the New File button. Name it HelloWorld.sol . Drag and drop it to the contracts folder. New file in the Remix IDE.","title":"1. Create a New File"},{"location":"dev/getting-started/setup/remix/#2-write-your-contract","text":"Copy and paste the smart contract code provided below into the newly created HelloWorld.sol file. // SPDX-License-Identifier: MIT // Specifies the version of Solidity, using semantic versioning. pragma solidity 0.8.17 ; // Defines a contract named `HelloWorld` contract HelloWorld { // Declares a state variable `message` of type `string`. string public message ; // Constructors are used to initialize the contract's data. constructor ( string memory initMessage ) { // Accepts a string argument `initMessage`. message = initMessage ; } // A public function that accepts a string argument. function update ( string memory newMessage ) public { message = newMessage ; } }","title":"2. Write Your Contract"},{"location":"dev/getting-started/setup/remix/#3-compile-your-contract","text":"Go to the Solidity Compiler tab (on the left), and select compiler version 0.8.17 . Now, click the Compile HelloWorld.sol button. After successful compilation, it will show a Green tick mark on the Compiler tab button. Compilation successful.","title":"3. Compile Your Contract"},{"location":"dev/getting-started/setup/remix/#4-deploying-on-flare-testnet","text":"You will now deploy the smart contract on the Coston2 network , Flare's test network. When a smart contract is deployed on Flare's main network, it not only costs money (such as gas fees), but it also becomes immutable and cannot be modified. Therefore, deploying your smart contracts first on the test network is highly recommended. Important Before jumping onto Remix Deployment: Make sure that you have added and selected the Coston2 test network to your MetaMask Wallet. The MetaMask Wallet guide shows how to do it. Use the values for Coston2 that you will find in the Network Configurations page. Ensure that you have enough Coston2 native tokens $C2FLR to pay for gas. Visit the Coston2 Faucet to request some $C2FLR . Go to the Deploy & Run Transactions tab (the last one) and select Injected Provider - Metamask from the ENVIRONMENT dropdown. Accept the connection request received in MetaMask if necessary. Environment selection on Remix. Click the Deploy button and confirm the CONTRACT DEPLOYMENT transaction in MetaMask. Contract deployment transaction. Note The process to deploy your contract on the Flare main network is the same as above. You only have to select Flare Network on MetaMask and use $FLR tokens.","title":"4. Deploying on Flare Testnet"},{"location":"dev/getting-started/setup/remix/#5-interact-with-the-contract","text":"You can now interact with the contract to verify that it is working as intended. In the Deployed Contracts section at the bottom of the left column, expand the HELLOWORLD contract to see its methods and data: update method. message public variable. Type a message in the box next to the update button and click the button. Confirm the deployment transaction in MetaMask. Check that the contract has been updated by clicking the message button and verifying you get back the message you typed before. Interact with the contract","title":"5. Interact with the Contract"},{"location":"dev/getting-started/setup/truffle/","text":"Setting Up Your Environment Using Truffle # Truffle is a blockchain development environment, which you can use to create and test smart contracts by leveraging the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier. This article shows you how to set up Truffle and use it to build and deploy a smart contract on the Flare network. Guide # 1. Set up the Environment # Install the following dependencies: NodeJSv12+ LTS and npm/Yarn Package Installer . Once the above dependencies are installed, install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version into the terminal. 2. Create a Truffle Project # In this article you will use one of Truffle's boilerplate projects which you can find on the Truffle Boxes page . MetaCoin box is an example of a completed coin-like contract. Create a new directory for this Truffle project by running: mkdir flare-truffle-tutorial cd flare-truffle-tutorial Then install the MetaCoin box: truffle unbox metacoin Once this operation is complete, you should have a project structure with the following items: Truffle Project structure. Finally, install the following dependencies which will be needed to deploy contracts: npm i @truffle/hdwallet-provider dotenv 3. Compile the Contract # In the contracts folder you should find two sample source files called MetaCoin.sol and ConvertLib.sol . To compile them, simply run: truffle compile Upon successful compilation, you should see the following output: Truffle compilation output. 4. Test the Contract # In the test folder you should find examples for testing your smart contracts in both JavaScript and Solidity that verify the contracts work as expected. To run tests: truffle test When successful, the output should look like this: Truffle test output. 5. Configure the Project # In order to be deployed on any of the Flare networks , the project needs to be configured. Edit the truffle-config.js file and replace its contents with the following: const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); require ( 'dotenv' ). config (); const fs = require ( 'fs' ); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 8545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, flare : { provider : () => new HDWalletProvider ( process . env . PRIVATE_KEY , `https://flare-api.flare.network/ext/C/rpc` ), network_id : 14 , timeoutBlocks : 200 , skipDryRun : true }, coston2 : { provider : () => new HDWalletProvider ( process . env . PRIVATE_KEY , `https://coston2-api.flare.network/ext/C/rpc` ), network_id : 114 , timeoutBlocks : 200 , skipDryRun : true }, }, // Set default mocha options here, use special reporters etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"0.8.13\" , // Fetch exact version from solc-bin } } }; Then, create a file called .env at the root of you project (where the truffle-config.js file resides) to store the private key for the account to use for testing. PRIVATE_KEY = \"d8936f6eae35c73a14ea7c1aabb8d068e16889a7f516c8abc482ba4e1489f4cd\" .env files are useful to store local information which should not be committed into the source repository. Caution Make sure you never upload your .env file to a remote repository. For this reason, the .gitignore file that Truffle created for you already ignores .env files. 6. Deploy the Contract # Important You are going to deploy the contract on the Coston 2 network . Make sure you have enough C2FLR in the account that will deploy the contract to pay the gas fees! You can add C2FLR to any account using the Coston 2 Faucet . Run this command in the root folder of the project: truffle migrate --network coston2 You should get an output similar to: Truffle deployment output. You can check the status of the contract by copy and pasting the contract address: in the Block Explorer .","title":"Using Truffle"},{"location":"dev/getting-started/setup/truffle/#setting-up-your-environment-using-truffle","text":"Truffle is a blockchain development environment, which you can use to create and test smart contracts by leveraging the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier. This article shows you how to set up Truffle and use it to build and deploy a smart contract on the Flare network.","title":"Setting Up Your Environment Using Truffle"},{"location":"dev/getting-started/setup/truffle/#guide","text":"","title":"Guide"},{"location":"dev/getting-started/setup/truffle/#1-set-up-the-environment","text":"Install the following dependencies: NodeJSv12+ LTS and npm/Yarn Package Installer . Once the above dependencies are installed, install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version into the terminal.","title":"1. Set up the Environment"},{"location":"dev/getting-started/setup/truffle/#2-create-a-truffle-project","text":"In this article you will use one of Truffle's boilerplate projects which you can find on the Truffle Boxes page . MetaCoin box is an example of a completed coin-like contract. Create a new directory for this Truffle project by running: mkdir flare-truffle-tutorial cd flare-truffle-tutorial Then install the MetaCoin box: truffle unbox metacoin Once this operation is complete, you should have a project structure with the following items: Truffle Project structure. Finally, install the following dependencies which will be needed to deploy contracts: npm i @truffle/hdwallet-provider dotenv","title":"2. Create a Truffle Project"},{"location":"dev/getting-started/setup/truffle/#3-compile-the-contract","text":"In the contracts folder you should find two sample source files called MetaCoin.sol and ConvertLib.sol . To compile them, simply run: truffle compile Upon successful compilation, you should see the following output: Truffle compilation output.","title":"3. Compile the Contract"},{"location":"dev/getting-started/setup/truffle/#4-test-the-contract","text":"In the test folder you should find examples for testing your smart contracts in both JavaScript and Solidity that verify the contracts work as expected. To run tests: truffle test When successful, the output should look like this: Truffle test output.","title":"4. Test the Contract"},{"location":"dev/getting-started/setup/truffle/#5-configure-the-project","text":"In order to be deployed on any of the Flare networks , the project needs to be configured. Edit the truffle-config.js file and replace its contents with the following: const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); require ( 'dotenv' ). config (); const fs = require ( 'fs' ); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 8545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, flare : { provider : () => new HDWalletProvider ( process . env . PRIVATE_KEY , `https://flare-api.flare.network/ext/C/rpc` ), network_id : 14 , timeoutBlocks : 200 , skipDryRun : true }, coston2 : { provider : () => new HDWalletProvider ( process . env . PRIVATE_KEY , `https://coston2-api.flare.network/ext/C/rpc` ), network_id : 114 , timeoutBlocks : 200 , skipDryRun : true }, }, // Set default mocha options here, use special reporters etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"0.8.13\" , // Fetch exact version from solc-bin } } }; Then, create a file called .env at the root of you project (where the truffle-config.js file resides) to store the private key for the account to use for testing. PRIVATE_KEY = \"d8936f6eae35c73a14ea7c1aabb8d068e16889a7f516c8abc482ba4e1489f4cd\" .env files are useful to store local information which should not be committed into the source repository. Caution Make sure you never upload your .env file to a remote repository. For this reason, the .gitignore file that Truffle created for you already ignores .env files.","title":"5. Configure the Project"},{"location":"dev/getting-started/setup/truffle/#6-deploy-the-contract","text":"Important You are going to deploy the contract on the Coston 2 network . Make sure you have enough C2FLR in the account that will deploy the contract to pay the gas fees! You can add C2FLR to any account using the Coston 2 Faucet . Run this command in the root folder of the project: truffle migrate --network coston2 You should get an output similar to: Truffle deployment output. You can check the status of the contract by copy and pasting the contract address: in the Block Explorer .","title":"6. Deploy the Contract"},{"location":"dev/reference/","text":"Reference Guides # The following guides provide in-depth information about the Flare networks and the different smart contracts APIs. Guides # Network Configuration Automatic Claiming Block Explorers and Indexers The FlareDrop Personal Delegation Accounts Wallets","title":"Reference Guides"},{"location":"dev/reference/#reference-guides","text":"The following guides provide in-depth information about the Flare networks and the different smart contracts APIs.","title":"Reference Guides"},{"location":"dev/reference/#guides","text":"Network Configuration Automatic Claiming Block Explorers and Indexers The FlareDrop Personal Delegation Accounts Wallets","title":"Guides"},{"location":"dev/reference/automatic-claiming/","text":"Automatic Claiming # Users who do not want to claim rewards themselves can enlist executors to claim on their behalf. Executors can then initiate the claiming process, and rewards are sent directly to the user's account. Info This feature is only available on the Flare network. Introduction # Building an executor requires two parts: An executor bot that periodically claims on behalf of the users. An app that allows users to select the executor, such as the Flare Portal , which is free to use. This page contains the following information: The Required Contracts section briefly lists the smart contracts related to executor operation. The User Operations section shows how to perform the operations required in a user-facing application, such as setting an executor. The Executor Operations section shows how to perform the operations required by an executor bot, such as registering as an executor. The User and Executor Reports section shows how to access information useful for performing user and executor functions. Required Contracts # Setting up automatic claiming requires interacting with these contracts: ClaimSetupManager (CSM). FTSORewardManager (FTSO). To find the addresses of these contracts, see the Contract Addresses page. User Operations # This section shows how to perform operations required to enable autoclaiming. The main step is to set the executor that will perform the claiming for the user who has accrued rewards. Then other operations are explained, such as changing the executor and disabling automatic claiming. Setting Claim Executors # There are two ways to set up automatic claiming: Manual and Registered . Manual Claiming # With Manual Claiming , rewards are claimed on-chain, but any agreement between users and executors happens off-chain. Fees are not paid automatically. To set one or more executors to claim rewards for a user: Set a specific executor by calling CSM.setClaimExecutors() and providing the executor's address. This method must be called from the user's account, since they are the only ones that can authorize claiming on their behalf. This function removes all previously set executors and replaces them with the new set. Registered Claiming # With Registered Claiming , a purpose-built ClaimSetupManager contract handles the on-chain agreement between users and executors, greatly simplifying the process. To set one or more registered executors to claim rewards for a user: Get a list of executors and their fees by calling CSM.getRegisteredExecutors() . To find the fee of a specific executor, call CSM.getExecutorCurrentFeeValue() . This fee is deducted from the user\u2019s reward after each claim and sent to the executor. You can show this information to the user and let them select which executor to use. Set the selected executors by calling CSM.setClaimExecutors() as shown for Manual Claiming . However, when setting registered executors, the call must include a value equal to the executor\u2019s fee (in FLR), which is sent to the executor as an enrollment fee. If more than one executor is set, the value must equal the sum of all the executor's fees. Changing Registered Executors # To change registered executors, call CSM.setClaimExecutors() with the new list of executors. This new list overwrites the current list. Disabling Automatic Claiming # To disable automatic claiming, remove all executors by sending an empty array of executors with CSM.setClaimExecutors() . Executor Operations # This section shows how to perform operations required in an executor-facing application, for example, becoming an executor. While the main step for manual executors is only claiming rewards, the main steps for registered executors are registering, setting a fee, and claiming rewards. Other operations like changing the fee, unregistering as an executor, and learning which addresses to claim for are also explained. Becoming an Executor # There are two ways to become an executor: Manual and Registered . Manual Executor # Setting an executor manually means doing so off-chain. Therefore, there is no operation required for executors, besides communicating to the users the address of the executor they need to use. Registered Executor # The ClaimSetupManager contract contains a list of self-registered executors that users can use to discover executors and their service fees, avoiding the need for off-chain operations as in manual claiming. To automatically receive fees for claiming, an executor address must register, set the fee for claiming rewards, and pay the registration fee. Register an executor by calling CSM.registerExecutor(uint256 feeValue) , where feeValue is the fee in wei that the executor requires to perform this service. The fee value must be at least CSM.minFeeValueWei , currently 0.1 FLR, and no greater than CSM.maxFeeValueWei , currently 100 FLR. This transaction must include a registration fee equal to CSM.registerExecutorFeeValueWei , currently 1000 FLR, which is burned. Claiming Rewards # How to Claim # Executors can now only claim FTSO delegation rewards on behalf of users. As other rewards become available, they will also be claimable by executors without any user intervention. Manual and registered executors use the same function, the only difference being that unregistered executors do not receive a fee automatically. To claim FTSO rewards for all of a user's unclaimed epochs, call FTSO.autoClaim(address[] rewardOwners, uint256 rewardEpoch) . This method can be used to claim for multiple users, since rewardOwners is an array. The rewardEpoch is the most current one that the executor wants to claim for, typically the one before the current epoch. If a user has more unclaimed epochs from the past, the function claims for all of them. The claimed amount gets the executor fee subtracted and is automatically wrapped, so it is sent to the user as $WFLR . What to Expect in Fees # The executor gets paid a fee for each user for which he claims the FTSO delegation reward. However, he only gets paid one fee per user regardless of whether he claims for one or more epochs. The fee is paid in native $FLR tokens. If the claimed reward for a user is lower than the executor fee, the transaction is reverted. To see which users have enough rewards to complete and which would revert, call FTSO.autoClaim with a specific user address. Changing the Fee # Registered executors can change the fee they charge for the successful execution of claims. To change the fee, call CSM.updateExecutorFeeValue() . The new fee value will be in effect after CSM.feeValueUpdateOffset reward epochs have elapsed (currently 3 epochs), where the first epoch is the one that is currently active. This function returns the reward epoch number when the setting will become effective. Unregistering an Executor # Registered executors can unregister by calling CSM.unregisterExecutor() and they will be removed from the list of executors. To help the users adjust to the change, executors will retain the current fee and continue claiming for the next 3 reward epochs ( feeValueUpdateOffset ). An executor's best practice is to notify users when unregistering. Updating the User List # Executors should keep a list of users to claim for, there is no mechanism to retrieve this list from the chain. There are two ways to keep this list updated: Listen to the CSM.ClaimExecutorsChanged event which is emitted every time a user sets its executors. This method is suitable for registered executors which might be selected at any time. If the executor is only interested in a closed list of users, e.g., the ones that enlisted on an application, it can call CSM.isClaimExecutor(address user, address executor) for each user to verify the executor's address is properly configured. User and Executor Reports # This section shows how to access information that can help you perform both user and executor functions. Executor Fees # Get the current fee for each executor on the Registered Executors list by calling CSM.getExecutorCurrentFeeValue(address executor) . For upcoming fee changes, call CSM.getExecutorScheduledFeeValueChanges(address executor) . Executors by User # A user can set more than one executor. To see a list of current executors for a user, call CSM.claimExecutors(address user) , which returns an array of executor addresses. It is a best practice for users to check this report periodically (at least every 90 days) to make sure their selected executors have not unregistered without notice. Executor Status # To check if an executor is registered, call CSM.getExecutorInfo(address executor) . It returns whether an executor is registered and its fee.","title":"Automatic Claiming"},{"location":"dev/reference/automatic-claiming/#automatic-claiming","text":"Users who do not want to claim rewards themselves can enlist executors to claim on their behalf. Executors can then initiate the claiming process, and rewards are sent directly to the user's account. Info This feature is only available on the Flare network.","title":"Automatic Claiming"},{"location":"dev/reference/automatic-claiming/#introduction","text":"Building an executor requires two parts: An executor bot that periodically claims on behalf of the users. An app that allows users to select the executor, such as the Flare Portal , which is free to use. This page contains the following information: The Required Contracts section briefly lists the smart contracts related to executor operation. The User Operations section shows how to perform the operations required in a user-facing application, such as setting an executor. The Executor Operations section shows how to perform the operations required by an executor bot, such as registering as an executor. The User and Executor Reports section shows how to access information useful for performing user and executor functions.","title":"Introduction"},{"location":"dev/reference/automatic-claiming/#required-contracts","text":"Setting up automatic claiming requires interacting with these contracts: ClaimSetupManager (CSM). FTSORewardManager (FTSO). To find the addresses of these contracts, see the Contract Addresses page.","title":"Required Contracts"},{"location":"dev/reference/automatic-claiming/#user-operations","text":"This section shows how to perform operations required to enable autoclaiming. The main step is to set the executor that will perform the claiming for the user who has accrued rewards. Then other operations are explained, such as changing the executor and disabling automatic claiming.","title":"User Operations"},{"location":"dev/reference/automatic-claiming/#setting-claim-executors","text":"There are two ways to set up automatic claiming: Manual and Registered .","title":"Setting Claim Executors"},{"location":"dev/reference/automatic-claiming/#manual-claiming","text":"With Manual Claiming , rewards are claimed on-chain, but any agreement between users and executors happens off-chain. Fees are not paid automatically. To set one or more executors to claim rewards for a user: Set a specific executor by calling CSM.setClaimExecutors() and providing the executor's address. This method must be called from the user's account, since they are the only ones that can authorize claiming on their behalf. This function removes all previously set executors and replaces them with the new set.","title":"Manual Claiming"},{"location":"dev/reference/automatic-claiming/#registered-claiming","text":"With Registered Claiming , a purpose-built ClaimSetupManager contract handles the on-chain agreement between users and executors, greatly simplifying the process. To set one or more registered executors to claim rewards for a user: Get a list of executors and their fees by calling CSM.getRegisteredExecutors() . To find the fee of a specific executor, call CSM.getExecutorCurrentFeeValue() . This fee is deducted from the user\u2019s reward after each claim and sent to the executor. You can show this information to the user and let them select which executor to use. Set the selected executors by calling CSM.setClaimExecutors() as shown for Manual Claiming . However, when setting registered executors, the call must include a value equal to the executor\u2019s fee (in FLR), which is sent to the executor as an enrollment fee. If more than one executor is set, the value must equal the sum of all the executor's fees.","title":"Registered Claiming"},{"location":"dev/reference/automatic-claiming/#changing-registered-executors","text":"To change registered executors, call CSM.setClaimExecutors() with the new list of executors. This new list overwrites the current list.","title":"Changing Registered Executors"},{"location":"dev/reference/automatic-claiming/#disabling-automatic-claiming","text":"To disable automatic claiming, remove all executors by sending an empty array of executors with CSM.setClaimExecutors() .","title":"Disabling Automatic Claiming"},{"location":"dev/reference/automatic-claiming/#executor-operations","text":"This section shows how to perform operations required in an executor-facing application, for example, becoming an executor. While the main step for manual executors is only claiming rewards, the main steps for registered executors are registering, setting a fee, and claiming rewards. Other operations like changing the fee, unregistering as an executor, and learning which addresses to claim for are also explained.","title":"Executor Operations"},{"location":"dev/reference/automatic-claiming/#becoming-an-executor","text":"There are two ways to become an executor: Manual and Registered .","title":"Becoming an Executor"},{"location":"dev/reference/automatic-claiming/#manual-executor","text":"Setting an executor manually means doing so off-chain. Therefore, there is no operation required for executors, besides communicating to the users the address of the executor they need to use.","title":"Manual Executor"},{"location":"dev/reference/automatic-claiming/#registered-executor","text":"The ClaimSetupManager contract contains a list of self-registered executors that users can use to discover executors and their service fees, avoiding the need for off-chain operations as in manual claiming. To automatically receive fees for claiming, an executor address must register, set the fee for claiming rewards, and pay the registration fee. Register an executor by calling CSM.registerExecutor(uint256 feeValue) , where feeValue is the fee in wei that the executor requires to perform this service. The fee value must be at least CSM.minFeeValueWei , currently 0.1 FLR, and no greater than CSM.maxFeeValueWei , currently 100 FLR. This transaction must include a registration fee equal to CSM.registerExecutorFeeValueWei , currently 1000 FLR, which is burned.","title":"Registered Executor"},{"location":"dev/reference/automatic-claiming/#claiming-rewards","text":"","title":"Claiming Rewards"},{"location":"dev/reference/automatic-claiming/#how-to-claim","text":"Executors can now only claim FTSO delegation rewards on behalf of users. As other rewards become available, they will also be claimable by executors without any user intervention. Manual and registered executors use the same function, the only difference being that unregistered executors do not receive a fee automatically. To claim FTSO rewards for all of a user's unclaimed epochs, call FTSO.autoClaim(address[] rewardOwners, uint256 rewardEpoch) . This method can be used to claim for multiple users, since rewardOwners is an array. The rewardEpoch is the most current one that the executor wants to claim for, typically the one before the current epoch. If a user has more unclaimed epochs from the past, the function claims for all of them. The claimed amount gets the executor fee subtracted and is automatically wrapped, so it is sent to the user as $WFLR .","title":"How to Claim"},{"location":"dev/reference/automatic-claiming/#what-to-expect-in-fees","text":"The executor gets paid a fee for each user for which he claims the FTSO delegation reward. However, he only gets paid one fee per user regardless of whether he claims for one or more epochs. The fee is paid in native $FLR tokens. If the claimed reward for a user is lower than the executor fee, the transaction is reverted. To see which users have enough rewards to complete and which would revert, call FTSO.autoClaim with a specific user address.","title":"What to Expect in Fees"},{"location":"dev/reference/automatic-claiming/#changing-the-fee","text":"Registered executors can change the fee they charge for the successful execution of claims. To change the fee, call CSM.updateExecutorFeeValue() . The new fee value will be in effect after CSM.feeValueUpdateOffset reward epochs have elapsed (currently 3 epochs), where the first epoch is the one that is currently active. This function returns the reward epoch number when the setting will become effective.","title":"Changing the Fee"},{"location":"dev/reference/automatic-claiming/#unregistering-an-executor","text":"Registered executors can unregister by calling CSM.unregisterExecutor() and they will be removed from the list of executors. To help the users adjust to the change, executors will retain the current fee and continue claiming for the next 3 reward epochs ( feeValueUpdateOffset ). An executor's best practice is to notify users when unregistering.","title":"Unregistering an Executor"},{"location":"dev/reference/automatic-claiming/#updating-the-user-list","text":"Executors should keep a list of users to claim for, there is no mechanism to retrieve this list from the chain. There are two ways to keep this list updated: Listen to the CSM.ClaimExecutorsChanged event which is emitted every time a user sets its executors. This method is suitable for registered executors which might be selected at any time. If the executor is only interested in a closed list of users, e.g., the ones that enlisted on an application, it can call CSM.isClaimExecutor(address user, address executor) for each user to verify the executor's address is properly configured.","title":"Updating the User List"},{"location":"dev/reference/automatic-claiming/#user-and-executor-reports","text":"This section shows how to access information that can help you perform both user and executor functions.","title":"User and Executor Reports"},{"location":"dev/reference/automatic-claiming/#executor-fees","text":"Get the current fee for each executor on the Registered Executors list by calling CSM.getExecutorCurrentFeeValue(address executor) . For upcoming fee changes, call CSM.getExecutorScheduledFeeValueChanges(address executor) .","title":"Executor Fees"},{"location":"dev/reference/automatic-claiming/#executors-by-user","text":"A user can set more than one executor. To see a list of current executors for a user, call CSM.claimExecutors(address user) , which returns an array of executor addresses. It is a best practice for users to check this report periodically (at least every 90 days) to make sure their selected executors have not unregistered without notice.","title":"Executors by User"},{"location":"dev/reference/automatic-claiming/#executor-status","text":"To check if an executor is registered, call CSM.getExecutorInfo(address executor) . It returns whether an executor is registered and its fee.","title":"Executor Status"},{"location":"dev/reference/explorers-and-indexers/","text":"Block Explorers and Indexers # Flare provides a block explorer for each of the networks in its ecosystem. All explorers are a fork of Blockscout , adapted to the Flare networks ( Blockscout Docs ). API documentation for each network's explorer: Flare Songbird Coston Coston2 API access to the Coston Explorer is enabled for noncommercial use only. Related User Guides # Block Explorers","title":"Block Explorers and Indexers"},{"location":"dev/reference/explorers-and-indexers/#block-explorers-and-indexers","text":"Flare provides a block explorer for each of the networks in its ecosystem. All explorers are a fork of Blockscout , adapted to the Flare networks ( Blockscout Docs ). API documentation for each network's explorer: Flare Songbird Coston Coston2 API access to the Coston Explorer is enabled for noncommercial use only.","title":"Block Explorers and Indexers"},{"location":"dev/reference/explorers-and-indexers/#related-user-guides","text":"Block Explorers","title":"Related User Guides"},{"location":"dev/reference/network-config/","text":"Network Configuration # Flare Networks # These are the values required to configure the different Flare networks : Flare Songbird Coston Coston2 Flare Chain ID 14 Asset Ticker FLR RPC endpoint BETA https://flare-api.flare.network/ext/C/rpc Rosetta API https://flare-rosetta-api.flare.network/ Block Explorer https://flare-explorer.flare.network Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://flare-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Songbird Chain ID 19 Asset Ticker SGB RPC endpoint BETA https://songbird-api.flare.network/ext/C/rpc Block Explorer https://songbird-explorer.flare.network Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://songbird-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Coston Chain ID 16 Asset Ticker CFLR RPC endpoint BETA https://coston-api.flare.network/ext/C/rpc Block Explorer https://coston-explorer.flare.network Test Faucet https://faucet.towolabs.com Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://coston-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Coston2 Chain ID 114 Asset Ticker C2FLR RPC endpoint BETA https://coston2-api.flare.network/ext/C/rpc Block Explorer https://coston2-explorer.flare.network Test Faucet https://coston2-faucet.towolabs.com Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://coston2-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } All public RPC endpoints are experimental and rate-limited to avoid spamming attacks. For a production-grade option check out Flare's API Portal Connected Networks # Along with the endpoints listed above to interact with its own networks, Flare offers public RPC nodes for a series of other blockchain networks, to bootstrap development of connected services like attestation providers . All public RPC endpoints are experimental and rate-limited to avoid spamming attacks. For a production-grade option check out Flare's API Portal Bitcoin BNB-BSC Litecoin Dogecoin XRPL Algorand Ethereum RPC endpoint BETA https://bitcoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:d681co1pe2l3wcj9adrm2orlk0j5r5gr3wghgxt58tvge594co0k1ciljxq9glei \\ https://bitcoin-api.flare.network | jq RPC endpoint BETA https://bnb-bsc-api.flare.network/ Sample query curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\ -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\ https://bnb-bsc-api.flare.network | jq RPC endpoint BETA https://litecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:ntvzi4i1yne499t7vcdjqhhp92m3jvm0bb6dkpr406gkndvuns9sg6th3jd393uc \\ https://litecoin-api.flare.network | jq RPC endpoint BETA https://dogecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:6r1e5z3w9g6qruvkzkqvz8w67yqrq5js2cmyl2f1cncbp7gpp7tqixqskuub5v70 \\ https://dogecoin-api.flare.network | jq RPC endpoint BETA https://xrpl-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"method\": \"server_info\", \"params\":[{\"api_version\": 1}]}' \\ https://xrpl-api.flare.network | jq RPC endpoint BETA https://algorand-api.flare.network Sample query curl -s -m 10 \\ -H \"X-Algo-API-Token: zl748k3wddvld8cvn64utnslbf7otorkijp84se0f58pmuu0shgm27gttpcjpmuq\" \\ https://algorand-api.flare.network/v2/status | jq RPC endpoint BETA https://ethereum-api.flare.network/ Sample query curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\ -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\ https://ethereum-api.flare.network | jq","title":"Network Configuration"},{"location":"dev/reference/network-config/#network-configuration","text":"","title":"Network Configuration"},{"location":"dev/reference/network-config/#flare-networks","text":"These are the values required to configure the different Flare networks : Flare Songbird Coston Coston2 Flare Chain ID 14 Asset Ticker FLR RPC endpoint BETA https://flare-api.flare.network/ext/C/rpc Rosetta API https://flare-rosetta-api.flare.network/ Block Explorer https://flare-explorer.flare.network Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://flare-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Songbird Chain ID 19 Asset Ticker SGB RPC endpoint BETA https://songbird-api.flare.network/ext/C/rpc Block Explorer https://songbird-explorer.flare.network Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://songbird-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Coston Chain ID 16 Asset Ticker CFLR RPC endpoint BETA https://coston-api.flare.network/ext/C/rpc Block Explorer https://coston-explorer.flare.network Test Faucet https://faucet.towolabs.com Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://coston-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } Coston2 Chain ID 114 Asset Ticker C2FLR RPC endpoint BETA https://coston2-api.flare.network/ext/C/rpc Block Explorer https://coston2-explorer.flare.network Test Faucet https://coston2-faucet.towolabs.com Sample query You can check that you are accessing the RPC endpoint correctly with this sample query: curl -s -m 10 --request POST 'https://coston2-api.flare.network/ext/C/rpc' \\ -H 'Content-Type: application/json' \\ -d '{ \"jsonrpc\":\"2.0\", \"method\":\"eth_blockNumber\", \"params\":[], \"id\":1 }' It should return the current chain height in a message similar to: { \"jsonrpc\" : \"2.0\" , \"id\" : 1 , \"result\" : \"0x103384\" } All public RPC endpoints are experimental and rate-limited to avoid spamming attacks. For a production-grade option check out Flare's API Portal","title":"Flare Networks"},{"location":"dev/reference/network-config/#connected-networks","text":"Along with the endpoints listed above to interact with its own networks, Flare offers public RPC nodes for a series of other blockchain networks, to bootstrap development of connected services like attestation providers . All public RPC endpoints are experimental and rate-limited to avoid spamming attacks. For a production-grade option check out Flare's API Portal Bitcoin BNB-BSC Litecoin Dogecoin XRPL Algorand Ethereum RPC endpoint BETA https://bitcoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:d681co1pe2l3wcj9adrm2orlk0j5r5gr3wghgxt58tvge594co0k1ciljxq9glei \\ https://bitcoin-api.flare.network | jq RPC endpoint BETA https://bnb-bsc-api.flare.network/ Sample query curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\ -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\ https://bnb-bsc-api.flare.network | jq RPC endpoint BETA https://litecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:ntvzi4i1yne499t7vcdjqhhp92m3jvm0bb6dkpr406gkndvuns9sg6th3jd393uc \\ https://litecoin-api.flare.network | jq RPC endpoint BETA https://dogecoin-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\ -u public:6r1e5z3w9g6qruvkzkqvz8w67yqrq5js2cmyl2f1cncbp7gpp7tqixqskuub5v70 \\ https://dogecoin-api.flare.network | jq RPC endpoint BETA https://xrpl-api.flare.network Sample query curl -s -X POST -m 10 -H \"Content-type: application/json\" \\ -d '{\"method\": \"server_info\", \"params\":[{\"api_version\": 1}]}' \\ https://xrpl-api.flare.network | jq RPC endpoint BETA https://algorand-api.flare.network Sample query curl -s -m 10 \\ -H \"X-Algo-API-Token: zl748k3wddvld8cvn64utnslbf7otorkijp84se0f58pmuu0shgm27gttpcjpmuq\" \\ https://algorand-api.flare.network/v2/status | jq RPC endpoint BETA https://ethereum-api.flare.network/ Sample query curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\ -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\ https://ethereum-api.flare.network | jq","title":"Connected Networks"},{"location":"dev/reference/personal-delegation-account/","text":"Personal Delegation Accounts # Personal Delegation Accounts (PDAs) temporarily store rewards, such as FTSO delegation rewards, that users do not want to claim to their main accounts as explained in the Concept page . This page explains how to manage PDA functionality in applications. Required contracts # Working with the PDAs requires interacting with these contracts: ClaimSetupManager (CSM). FTSORewardManager (FTSO). To find the addresses of these contracts read the Contract Addresses page. Enabling a PDA # CSM.enableDelegationAccount() returns the address of the PDA associated with the caller's address, creating the PDA in the process if it didn't exist. A single PDA can be associated with each address and it cannot be destroyed once created, only disabled (see below). There exist no private keys to the PDA account so it cannot sign any transactions. All interaction with the PDA happens through the CSM contract, and is usually triggered by the user's main account. Note that this means that a PDA cannot have its own PDA, since no calls to the CSM can be made from the PDA account. Once a PDA is created, certain functions like FTSO.autoClaim() automatically send claimed rewards to the PDA account instead of the main account. See Delegation and Rewards below. Disabling a PDA # To disable the use of a PDA, call CSM.disableDelegationAccount() . Any $WFLR tokens that are on the PDA address are transferred back to the user's main account. When users disable their PDA, FTSO.autoClaim() claims only the rewards for their main account and to their main account. CSM.disableDelegationAccount() disables the PDA contract but does not destroy it: its address is still returned by CSM.getDelegationAccountData() , but the enabled boolean will be false . Checking PDA State # To check if a user's PDA is enabled, call CSM.getDelegationAccountData() . It returns both the PDA address and its state: Condition Address State PDA is enabled PDA address true PDA is disabled PDA address false PDA has never been created 0x000...000 false Never rely solely on the returned address being non-zero to check if an account has a PDA. Delegation and Rewards # A PDA is a regular account for which there are no private keys and which must be managed through the CSM contract instead. Conveniently, the method signatures to delegate on the CSM are the same as on the WNat contract where delegation is usually performed, for instance CSM.batchDelegate() . FTSO reward claiming, though, is still performed through the FTSORewardManager , for example using claimReward(address recipient, ...) where recipient allows sending to any address, including a PDA. For information on how to delegate and claim FTSO rewards, see Delegation and Rewards . In addition to the methods used for regular accounts, FTSO.autoClaim() automatically claims for both the main account and the PDA, to the PDA or the main account depending on whether the PDA is enabled or not. If users disable their PDA, autoClaim() claims rewards for only their main account and to only their main account. Note The autoClaim() method is unrelated to Automatic Claiming performed by executors. Governance Voting # Flare network users have a right to vote on proposals that can change the behavior of the network or add new features. The number of votes an address has is equal to the amount of wrapped Flare tokens ( $WFLR ) that the address holds. PDA addresses cannot vote directly, but their owners can transfer all their votes to another address (e.g., the owner's address) by calling CSM.delegateGovernance(address recipient) . The recipient of the votes can then vote with its own votes as well as with the votes received from other addresses. Transferring Funds # Because a PDA is a regular account, anyone can send funds to it. However, FLR tokens transferred to a PDA are automatically converted to $WFLR , making them convenient for delegation. Only the owner of the main account and its PDA can transfer funds from the PDA and only to its main account. To transfer tokens, the owner calls CSM.withdraw() and states the amount to withdraw. Since it has no private keys, any token other than $FLR or $WFLR transferred to the PDA cannot be moved out by conventional means. Instead, CSM.transferExternalToken() must be used to transfer them to another account. This is useful, for example, to recover airdropped tokens accidentally sent to the PDA. Note CSM.transferExternalToken() only works on ERC-20 tokens or token contracts that support the transfer function. Wallet or Dapp Integration # To support personal delegation accounts, a wallet or dapp at a minimum should show its status, including: Checking the user's PDA address and whether it is enabled. Showing the amount of $WFLR on the user's PDA. Additional integration could support the following actions: Enabling and disabling the PDA. Allowing the delegation of funds from a PDA to FTSO price providers. Delegating votes for governance voting. Claiming rewards to the PDA. Withdrawing funds from users' PDAs to their main accounts. Withdrawing custom ERC-20 tokens to the users' main accounts. See the Flare Portal for an example of such integration.","title":"Personal Delegation Accounts"},{"location":"dev/reference/personal-delegation-account/#personal-delegation-accounts","text":"Personal Delegation Accounts (PDAs) temporarily store rewards, such as FTSO delegation rewards, that users do not want to claim to their main accounts as explained in the Concept page . This page explains how to manage PDA functionality in applications.","title":"Personal Delegation Accounts"},{"location":"dev/reference/personal-delegation-account/#required-contracts","text":"Working with the PDAs requires interacting with these contracts: ClaimSetupManager (CSM). FTSORewardManager (FTSO). To find the addresses of these contracts read the Contract Addresses page.","title":"Required contracts"},{"location":"dev/reference/personal-delegation-account/#enabling-a-pda","text":"CSM.enableDelegationAccount() returns the address of the PDA associated with the caller's address, creating the PDA in the process if it didn't exist. A single PDA can be associated with each address and it cannot be destroyed once created, only disabled (see below). There exist no private keys to the PDA account so it cannot sign any transactions. All interaction with the PDA happens through the CSM contract, and is usually triggered by the user's main account. Note that this means that a PDA cannot have its own PDA, since no calls to the CSM can be made from the PDA account. Once a PDA is created, certain functions like FTSO.autoClaim() automatically send claimed rewards to the PDA account instead of the main account. See Delegation and Rewards below.","title":"Enabling a PDA"},{"location":"dev/reference/personal-delegation-account/#disabling-a-pda","text":"To disable the use of a PDA, call CSM.disableDelegationAccount() . Any $WFLR tokens that are on the PDA address are transferred back to the user's main account. When users disable their PDA, FTSO.autoClaim() claims only the rewards for their main account and to their main account. CSM.disableDelegationAccount() disables the PDA contract but does not destroy it: its address is still returned by CSM.getDelegationAccountData() , but the enabled boolean will be false .","title":"Disabling a PDA"},{"location":"dev/reference/personal-delegation-account/#checking-pda-state","text":"To check if a user's PDA is enabled, call CSM.getDelegationAccountData() . It returns both the PDA address and its state: Condition Address State PDA is enabled PDA address true PDA is disabled PDA address false PDA has never been created 0x000...000 false Never rely solely on the returned address being non-zero to check if an account has a PDA.","title":"Checking PDA State"},{"location":"dev/reference/personal-delegation-account/#delegation-and-rewards","text":"A PDA is a regular account for which there are no private keys and which must be managed through the CSM contract instead. Conveniently, the method signatures to delegate on the CSM are the same as on the WNat contract where delegation is usually performed, for instance CSM.batchDelegate() . FTSO reward claiming, though, is still performed through the FTSORewardManager , for example using claimReward(address recipient, ...) where recipient allows sending to any address, including a PDA. For information on how to delegate and claim FTSO rewards, see Delegation and Rewards . In addition to the methods used for regular accounts, FTSO.autoClaim() automatically claims for both the main account and the PDA, to the PDA or the main account depending on whether the PDA is enabled or not. If users disable their PDA, autoClaim() claims rewards for only their main account and to only their main account. Note The autoClaim() method is unrelated to Automatic Claiming performed by executors.","title":"Delegation and Rewards"},{"location":"dev/reference/personal-delegation-account/#governance-voting","text":"Flare network users have a right to vote on proposals that can change the behavior of the network or add new features. The number of votes an address has is equal to the amount of wrapped Flare tokens ( $WFLR ) that the address holds. PDA addresses cannot vote directly, but their owners can transfer all their votes to another address (e.g., the owner's address) by calling CSM.delegateGovernance(address recipient) . The recipient of the votes can then vote with its own votes as well as with the votes received from other addresses.","title":"Governance Voting"},{"location":"dev/reference/personal-delegation-account/#transferring-funds","text":"Because a PDA is a regular account, anyone can send funds to it. However, FLR tokens transferred to a PDA are automatically converted to $WFLR , making them convenient for delegation. Only the owner of the main account and its PDA can transfer funds from the PDA and only to its main account. To transfer tokens, the owner calls CSM.withdraw() and states the amount to withdraw. Since it has no private keys, any token other than $FLR or $WFLR transferred to the PDA cannot be moved out by conventional means. Instead, CSM.transferExternalToken() must be used to transfer them to another account. This is useful, for example, to recover airdropped tokens accidentally sent to the PDA. Note CSM.transferExternalToken() only works on ERC-20 tokens or token contracts that support the transfer function.","title":"Transferring Funds"},{"location":"dev/reference/personal-delegation-account/#wallet-or-dapp-integration","text":"To support personal delegation accounts, a wallet or dapp at a minimum should show its status, including: Checking the user's PDA address and whether it is enabled. Showing the amount of $WFLR on the user's PDA. Additional integration could support the following actions: Enabling and disabling the PDA. Allowing the delegation of funds from a PDA to FTSO price providers. Delegating votes for governance voting. Claiming rewards to the PDA. Withdrawing funds from users' PDAs to their main accounts. Withdrawing custom ERC-20 tokens to the users' main accounts. See the Flare Portal for an example of such integration.","title":"Wallet or Dapp Integration"},{"location":"dev/reference/the-flaredrop/","text":"The FlareDrop # The FlareDrop , previously called the Delegation Incentive Pool in the FIP.01 , is a distribution method for the 24.25B remaining $FLR tokens after the original airdrop . This page explains how to manage FlareDrop functionality in applications. Required Contracts # Working with the FlareDrop requires interacting with these contracts: DistributionToDelegators (Dist). Manages all claims. ClaimSetupManager (CSM). Needed to configure autoclaiming. To find their addresses, read the Contract Addresses page. Operations # Basic Claiming # The Dist.claim method allows claiming the FlareDrop one account at a time. function claim ( address _rewardOwner , address _recipient , uint256 _month , bool _wrap ) external returns ( uint256 _rewardAmount ); It transfers the FlareDrop rewards accrued by account _rewardOwner during the specified _month to the specified _recipient . _wrap controls whether the reward is transferred in native $FLR tokens or wrapped in $WFLR tokens. You can use Dist.getCurrentMonth() to find out the current month (starting at 0), or Dist.getClaimableMonths() to get the interval of months which are currently available for claiming. Use Dist.getClaimableAmount() or Dist.getClaimableAmountOf() to find out if a given address has pending rewards on any given month. Dist.claim() returns the amount of claimed rewards. Two modes of operation are supported: Self-claiming and claiming on behalf of another account. Self-Claiming : When msg.sender matches _rewardOwner , the caller is claiming its own rewards. In this case _recipient can be any address. Claiming on behalf of another account : When msg.sender does not match _rewardOwner , the caller must be a claim executor , claiming on behalf of _rewardOwner . If _msg.sender is not in the authorized list of executors for _rewardOwner , the call will revert. Authorized executors must be set beforehand by _rewardOwner using CSM.setClaimExecutors() . The _recipient must either be _rewardOwner , its PDA , or any of the authorized recipients previously set by _rewardOwner using CSM.setAllowedClaimRecipients() . The call will revert otherwise. Batched Claiming # The Dist.autoClaim() method allows claiming the FlareDrop for an arbitrary amount of accounts in a single call, with convenient default values. function autoClaim ( address [] calldata _rewardOwners , uint256 _month ) external ; It claims the rewards accrued by all the accounts in the _rewardOwners array during the specified _month . If an account does not have an enabled PDA , the rewards are sent to the same account. However, if an account does have an enabled PDA, the rewards are sent to the PDA account. Any rewards accrued by the PDA account are also claimed and sent to the PDA. Rewards claimed with this method are always wrapped. If the executor is a registered executor with a nonzero fee, the fee is automatically deducted from each claimed reward and sent to the executor account (unwrapped). If rewards are claimed for both an address and its PDA, the fee is deducted only once. The call reverts if: msg.sender is not in the authorized list of executors for any of the _rewardOwners . The total claimed rewards for any of the _rewardOwners is not high enough to cover the executor's fee.","title":"The FlareDrop"},{"location":"dev/reference/the-flaredrop/#the-flaredrop","text":"The FlareDrop , previously called the Delegation Incentive Pool in the FIP.01 , is a distribution method for the 24.25B remaining $FLR tokens after the original airdrop . This page explains how to manage FlareDrop functionality in applications.","title":"The FlareDrop"},{"location":"dev/reference/the-flaredrop/#required-contracts","text":"Working with the FlareDrop requires interacting with these contracts: DistributionToDelegators (Dist). Manages all claims. ClaimSetupManager (CSM). Needed to configure autoclaiming. To find their addresses, read the Contract Addresses page.","title":"Required Contracts"},{"location":"dev/reference/the-flaredrop/#operations","text":"","title":"Operations"},{"location":"dev/reference/the-flaredrop/#basic-claiming","text":"The Dist.claim method allows claiming the FlareDrop one account at a time. function claim ( address _rewardOwner , address _recipient , uint256 _month , bool _wrap ) external returns ( uint256 _rewardAmount ); It transfers the FlareDrop rewards accrued by account _rewardOwner during the specified _month to the specified _recipient . _wrap controls whether the reward is transferred in native $FLR tokens or wrapped in $WFLR tokens. You can use Dist.getCurrentMonth() to find out the current month (starting at 0), or Dist.getClaimableMonths() to get the interval of months which are currently available for claiming. Use Dist.getClaimableAmount() or Dist.getClaimableAmountOf() to find out if a given address has pending rewards on any given month. Dist.claim() returns the amount of claimed rewards. Two modes of operation are supported: Self-claiming and claiming on behalf of another account. Self-Claiming : When msg.sender matches _rewardOwner , the caller is claiming its own rewards. In this case _recipient can be any address. Claiming on behalf of another account : When msg.sender does not match _rewardOwner , the caller must be a claim executor , claiming on behalf of _rewardOwner . If _msg.sender is not in the authorized list of executors for _rewardOwner , the call will revert. Authorized executors must be set beforehand by _rewardOwner using CSM.setClaimExecutors() . The _recipient must either be _rewardOwner , its PDA , or any of the authorized recipients previously set by _rewardOwner using CSM.setAllowedClaimRecipients() . The call will revert otherwise.","title":"Basic Claiming"},{"location":"dev/reference/the-flaredrop/#batched-claiming","text":"The Dist.autoClaim() method allows claiming the FlareDrop for an arbitrary amount of accounts in a single call, with convenient default values. function autoClaim ( address [] calldata _rewardOwners , uint256 _month ) external ; It claims the rewards accrued by all the accounts in the _rewardOwners array during the specified _month . If an account does not have an enabled PDA , the rewards are sent to the same account. However, if an account does have an enabled PDA, the rewards are sent to the PDA account. Any rewards accrued by the PDA account are also claimed and sent to the PDA. Rewards claimed with this method are always wrapped. If the executor is a registered executor with a nonzero fee, the fee is automatically deducted from each claimed reward and sent to the executor account (unwrapped). If rewards are claimed for both an address and its PDA, the fee is deducted only once. The call reverts if: msg.sender is not in the authorized list of executors for any of the _rewardOwners . The total claimed rewards for any of the _rewardOwners is not high enough to cover the executor's fee.","title":"Batched Claiming"},{"location":"dev/reference/wallets/","text":"Wallets # Information for wallet developers wanting to integrate with the Flare networks. First off, find all basic network information like Chain ID or public RPC endpoints in the Network Configuration page. This page then provides a few more pointers specific to wallet development. Block Explorers and Indexers # For all its networks, Flare offers public block explorers that double down as indexers. Learn about them in the Block Explorers section. Flare's Personal Delegation Accounts # See the Integration with a Personal Delegation Account page. Address Derivation Paths for HD Wallets # Address derivation and format validation on Flare are the same as on Ethereum. In particular, Flare uses the same coin type as Ethereum, this is, 60. The BIP-44 paths are therefore m/44\u2019/60\u2019/x\u2019/0/0 (hardened) and m/44\u2019/60\u2019/0\u2019/0/x .","title":"Wallets"},{"location":"dev/reference/wallets/#wallets","text":"Information for wallet developers wanting to integrate with the Flare networks. First off, find all basic network information like Chain ID or public RPC endpoints in the Network Configuration page. This page then provides a few more pointers specific to wallet development.","title":"Wallets"},{"location":"dev/reference/wallets/#block-explorers-and-indexers","text":"For all its networks, Flare offers public block explorers that double down as indexers. Learn about them in the Block Explorers section.","title":"Block Explorers and Indexers"},{"location":"dev/reference/wallets/#flares-personal-delegation-accounts","text":"See the Integration with a Personal Delegation Account page.","title":"Flare's Personal Delegation Accounts"},{"location":"dev/reference/wallets/#address-derivation-paths-for-hd-wallets","text":"Address derivation and format validation on Flare are the same as on Ethereum. In particular, Flare uses the same coin type as Ethereum, this is, 60. The BIP-44 paths are therefore m/44\u2019/60\u2019/x\u2019/0/0 (hardened) and m/44\u2019/60\u2019/0\u2019/0/x .","title":"Address Derivation Paths for HD Wallets"},{"location":"dev/tutorials/","text":"Tutorials # The Flare developer tutorials are divided into the following topics. Topics # Accessing the Network","title":"Tutorials"},{"location":"dev/tutorials/#tutorials","text":"The Flare developer tutorials are divided into the following topics.","title":"Tutorials"},{"location":"dev/tutorials/#topics","text":"Accessing the Network","title":"Topics"},{"location":"dev/tutorials/network-access/","text":"Accessing the Network # The following tutorials deal with common problems encountered when accessing the Flare networks, like sending transactions or reading events. Tutorials # Checking Transaction Finalization Reliable Event Reading Obtaining a Transaction's Revert Reason","title":"Accessing the Network"},{"location":"dev/tutorials/network-access/#accessing-the-network","text":"The following tutorials deal with common problems encountered when accessing the Flare networks, like sending transactions or reading events.","title":"Accessing the Network"},{"location":"dev/tutorials/network-access/#tutorials","text":"Checking Transaction Finalization Reliable Event Reading Obtaining a Transaction's Revert Reason","title":"Tutorials"},{"location":"dev/tutorials/network-access/obtaining-revert-reason/","text":"Obtaining a Transaction's Revert Reason # Sometimes contract calls revert and throw a generic \"Transaction has been reverted\" exception which is not very helpful, since it does not contain the revert reason. In this case, simulating the call in the EVM without sending any transaction, using the .call() syntax, can provide the missing information, assuming the blockchain's state has not changed much between calls. The whole process is: Catch the exception, and check if the revert reason is part of the exception data. If not: Repeat the same contract call using .call() syntax and parse the revert reason. Note that the second step should be performed as soon as possible, to ensure that the chain has a similar state in both calls. The function below demonstrates this process. async function contractCall ( account , to , gas , gasPrice , fnToEncode , nonce ) { let tx = { from : account . address , to , gas , gasPrice , data : fnToEncode . encodeABI (), nonce }; let signedTx = await account . signTransaction ( tx ); try { return await web3 . eth . sendSignedTransaction ( signedTx . rawTransaction ); } catch ( e ) { if ( e . message . indexOf ( \"Transaction has been reverted by the EVM\" ) >= 0 ) { // This call should throw a new exception containing the revert reason await fnToEncode . call ({ from : account . address }); } // Otherwise, either revert reason was already part of the original error or // we failed to get any additional information. throw e ; } } Where account and fnToEncode are obtained, for example, as follows: let account = web3 . eth . accounts . privateKeyToAccount ( privateKey ); let fnToEncode = web3Contract . methods . someMethodOnContract ( param1 , param2 );","title":"Obtaining a Transaction's Revert Reason"},{"location":"dev/tutorials/network-access/obtaining-revert-reason/#obtaining-a-transactions-revert-reason","text":"Sometimes contract calls revert and throw a generic \"Transaction has been reverted\" exception which is not very helpful, since it does not contain the revert reason. In this case, simulating the call in the EVM without sending any transaction, using the .call() syntax, can provide the missing information, assuming the blockchain's state has not changed much between calls. The whole process is: Catch the exception, and check if the revert reason is part of the exception data. If not: Repeat the same contract call using .call() syntax and parse the revert reason. Note that the second step should be performed as soon as possible, to ensure that the chain has a similar state in both calls. The function below demonstrates this process. async function contractCall ( account , to , gas , gasPrice , fnToEncode , nonce ) { let tx = { from : account . address , to , gas , gasPrice , data : fnToEncode . encodeABI (), nonce }; let signedTx = await account . signTransaction ( tx ); try { return await web3 . eth . sendSignedTransaction ( signedTx . rawTransaction ); } catch ( e ) { if ( e . message . indexOf ( \"Transaction has been reverted by the EVM\" ) >= 0 ) { // This call should throw a new exception containing the revert reason await fnToEncode . call ({ from : account . address }); } // Otherwise, either revert reason was already part of the original error or // we failed to get any additional information. throw e ; } } Where account and fnToEncode are obtained, for example, as follows: let account = web3 . eth . accounts . privateKeyToAccount ( privateKey ); let fnToEncode = web3Contract . methods . someMethodOnContract ( param1 , param2 );","title":"Obtaining a Transaction's Revert Reason"},{"location":"dev/tutorials/network-access/reliable-event-reading/","text":"Reliable Event Reading # Subscription to events, for example using listeners, has proved to be unreliable, especially when high traffic exists on the network. To reliably read events it is recommended to use the getPastEvents function on web3 contracts. This function has parameters fromBlock and toBlock so the caller has to keep track of which blocks have already been requested. The number of blocks the user can request in a single RPC call depends on the configuration of the RPC node being used. In particular, if the node is run with the environment variable WEB3_API set to debug (a so-called \"full node\"), usually 100 blocks of events can be read in one call. On the other hand, if WEB3_API is set to enabled (a \"light node\") only 1 block of events can be read.","title":"Reliable Event Reading"},{"location":"dev/tutorials/network-access/reliable-event-reading/#reliable-event-reading","text":"Subscription to events, for example using listeners, has proved to be unreliable, especially when high traffic exists on the network. To reliably read events it is recommended to use the getPastEvents function on web3 contracts. This function has parameters fromBlock and toBlock so the caller has to keep track of which blocks have already been requested. The number of blocks the user can request in a single RPC call depends on the configuration of the RPC node being used. In particular, if the node is run with the environment variable WEB3_API set to debug (a so-called \"full node\"), usually 100 blocks of events can be read in one call. On the other hand, if WEB3_API is set to enabled (a \"light node\") only 1 block of events can be read.","title":"Reliable Event Reading"},{"location":"dev/tutorials/network-access/transaction-finalization/","text":"Checking Transaction Finalization # On Flare and Songbird, obtaining the receipt of a submitted transaction does not guarantee that the transaction is finalized. One has to wait until the sender's account nonce (the total number of sent transactions) increases. The following function shows how to send a signed transaction and wait for its finalization. The function polls the current nonce up to 8 times before giving up, using an exponential backoff. This means that the time spent between successive polls of the nonce is increased exponentially to avoid taxing the network too much. async function sendAndFinalize ( senderAddress , signedTx , delay = 1000 ) { let oldNonce = await web3 . eth . getTransactionCount ( senderAddress ); let receipt = await web3 . eth . sendSignedTransaction ( signedTx . rawTransaction ) let backoff = 1.5 ; let maxRetries = 8 ; while (( await web3 . eth . getTransactionCount ( senderAddress )) == oldNonce ) { await new Promise (( resolve ) => { setTimeout (()=>{ resolve ()}, delay )}) maxRetries -- ; if ( maxRetries == 0 ) { throw new Error ( \"Response timeout\" ); } delay = Math . floor ( delay * backoff ); } return receipt ; }","title":"Checking Transaction Finalization"},{"location":"dev/tutorials/network-access/transaction-finalization/#checking-transaction-finalization","text":"On Flare and Songbird, obtaining the receipt of a submitted transaction does not guarantee that the transaction is finalized. One has to wait until the sender's account nonce (the total number of sent transactions) increases. The following function shows how to send a signed transaction and wait for its finalization. The function polls the current nonce up to 8 times before giving up, using an exponential backoff. This means that the time spent between successive polls of the nonce is increased exponentially to avoid taxing the network too much. async function sendAndFinalize ( senderAddress , signedTx , delay = 1000 ) { let oldNonce = await web3 . eth . getTransactionCount ( senderAddress ); let receipt = await web3 . eth . sendSignedTransaction ( signedTx . rawTransaction ) let backoff = 1.5 ; let maxRetries = 8 ; while (( await web3 . eth . getTransactionCount ( senderAddress )) == oldNonce ) { await new Promise (( resolve ) => { setTimeout (()=>{ resolve ()}, delay )}) maxRetries -- ; if ( maxRetries == 0 ) { throw new Error ( \"Response timeout\" ); } delay = Math . floor ( delay * backoff ); } return receipt ; }","title":"Checking Transaction Finalization"},{"location":"exchange/","text":"Exchange Guides # This section contains information and bits of advice for Exchanges willing to support the Flare blockchain. The first thing you should know is that: Flare is used just like Ethereum! Even though the node code is different, Flare offers the same API as Ethereum so you can integrate with it in the same way. Deploy a Flare Observer node to access the network. Use the appropriate Chain ID . Use standard Ethereum libraries like web3.js if you want. Quick Information about Flare # Website address flare.network Brand assets Google Drive Rosetta API endpoint https://flare-rosetta-api.flare.network/ Node source code github.com/flare-foundation/flare Node installation documentation docs.flare.network/infra/observation/deploying Node requirements 8 CPU, 16 GB RAM, 2 TB disk space Maximum block rate 1 block/second. Token names FLARE , SONGBIRD Tickers FLR , SGB Tokens precision 18 decimal places Supported wallets docs.flare.network/user/wallets Network configuration information, including: Flare Networks Configuration Values RPC Nodes for Connected Chains Note The $FLR and $SGB tokens are not ERC-20 tokens: they are the native currency of Flare (the Main network ) and Songbird (The Canary network ) respectively. As such, these tokens are handled the same way $ETH is handled on the Ethereum blockchain. Select one of the topics below: Architecture of an Exchange Delegating on the User's Behalf Troubleshooting Guide","title":"Exchange Guides"},{"location":"exchange/#exchange-guides","text":"This section contains information and bits of advice for Exchanges willing to support the Flare blockchain. The first thing you should know is that: Flare is used just like Ethereum! Even though the node code is different, Flare offers the same API as Ethereum so you can integrate with it in the same way. Deploy a Flare Observer node to access the network. Use the appropriate Chain ID . Use standard Ethereum libraries like web3.js if you want.","title":"Exchange Guides"},{"location":"exchange/#quick-information-about-flare","text":"Website address flare.network Brand assets Google Drive Rosetta API endpoint https://flare-rosetta-api.flare.network/ Node source code github.com/flare-foundation/flare Node installation documentation docs.flare.network/infra/observation/deploying Node requirements 8 CPU, 16 GB RAM, 2 TB disk space Maximum block rate 1 block/second. Token names FLARE , SONGBIRD Tickers FLR , SGB Tokens precision 18 decimal places Supported wallets docs.flare.network/user/wallets Network configuration information, including: Flare Networks Configuration Values RPC Nodes for Connected Chains Note The $FLR and $SGB tokens are not ERC-20 tokens: they are the native currency of Flare (the Main network ) and Songbird (The Canary network ) respectively. As such, these tokens are handled the same way $ETH is handled on the Ethereum blockchain. Select one of the topics below: Architecture of an Exchange Delegating on the User's Behalf Troubleshooting Guide","title":"Quick Information about Flare"},{"location":"exchange/architecture/","text":"Architecture of an Exchange # What follows is the suggested architecture for a centralized Exchange. Even if your Exchange does not adopt this exact design, it defines the concepts that are used throughout the other pages in this section. General Structure # The suggested architecture uses a Central Exchange wallet with multiple User reception wallets controlled by the Exchange. General structure of an Exchange. Exchange's Central Wallet (Hot) # This account contains the Exchange's funds required to perform user operations: Users' deposits are ultimately routed here, and users' withdrawals are taken from here. The private keys to this account need to be on an online machine (the Exchange server ) so this is considered a hot wallet . For security reasons, it is recommended that the hot wallet only contains enough funds to perform daily operations, whereas the bulk of the funds are kept in the cold wallet . Exchange's Central Wallet (Cold) # The private keys to this account are kept in an offline machine so it is less vulnerable to attacks. Moreover, it is recommended that this is a multi-signature account so the approval of more than one administrator is required to move funds from it. Periodically (e.g., once a day) funds are transferred from or to the hot wallet so it can continue operating while the bulk of the funds are protected in the cold wallet. Users' Reception Wallets # When users sign up with the Exchange, a reception wallet is created for them in order to perform deposits. The reception wallets are usually empty: as soon as they receive funds these are transferred to the Exchange's hot wallet . The private keys to the reception wallets always remain under the Exchange's control; these wallets are offered to users as a convenience only. Users cannot perform any operation on these wallets other than deposits. User's Wallet # This is the origin of deposits made to the Exchange and the receiver of withdrawals made from the Exchange. It can be a wallet in control of the user (the user holds its private key), a custodial wallet or another Exchange, for example. Exchange Server # This is an online server, part of the Exchange's infrastructure, that receives withdrawal requests from users and monitors the reception wallets to detect incoming deposits. It holds the private keys to the hot wallet and to all the reception wallets so it can move funds from them in response to user's requests. Caution This server must be available 24/7 so it is a clear target for malicious actors. Balances DB # This database keeps track of every user's funds, since the actual tokens from all users are pooled together in the hot and cold wallets. The Exchange server updates this DB in response to user's deposits and withdrawals. Flare Observer Node # An observer node is a regular Flare node that does not partake in consensus but is still aware of the current state of the blockchain and allows submitting transactions. It is highly recommended that Exchanges deploy their own observer nodes to access the network, instead of relying on third-party services. Read the Deploying an Observer Node guide to learn how to do this. Detecting Deposits # The Exchange server must be continuously monitoring transfers into ALL reception wallets to detect incoming deposits. Here's a summary of the process: Depositing to an Exchange. The user deposits (transfers) funds to their assigned reception wallet . The transaction is detected by the Exchange server monitoring the wallets. The server can discover a new transaction as soon as it is submitted by subscribing to the pendingTransactions event. This allows showing the transaction as \"pending\" in the UI, but there is still a chance that it is reverted. To avoid problems, the Exchange should only act on transactions appearing on blocks old enough for the chance of them being reverted to be negligible. This can be done by subscribing to the newBlockHeaders event and examining the transactions in a previous block (for example, 5 blocks behind). The code below exemplifies this process ( See the web3.js documentation for the API details): // https://web3js.readthedocs.io const Web3 = require ( 'web3' ); // Use your own node URL // https://docs.flare.network/dev/reference/coston-testnet/ const web3 = new Web3 ( \"wss://coston-api.flare.network/ext/bc/C/ws\" ); // Use your receiving wallet address const receivingAddress = \"0x947c76694491d3fD67a73688003c4d36C8780A97\" ; web3 . eth . subscribe ( \"pendingTransactions\" ) . on ( \"data\" , async ( transactionHash ) => { // New transaction hash received. // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as pending. console . log ( \"Transaction\" , tx . hash , \"is pending\" ); } }). on ( \"error\" , console . error ); web3 . eth . subscribe ( \"newBlockHeaders\" ) . on ( \"data\" , async ( blockHeader ) => { // New block has been produced. // Retrieve a block old enough to be considered confirmed. let block = await web3 . eth . getBlock ( blockHeader . number - 5 ); // Get all its transactions. block . transactions . forEach ( async ( transactionHash ) => { // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as confirmed. console . log ( \"Transaction\" , tx . hash , \"is confirmed in block\" , block . number ); } }); }). on ( \"error\" , console . error ); Caution Note that all transactions from a block are retrieved simultaneously and this can easily trigger a rate limit on the node. A proper implementation should avoid this by serializing requests or managing the request rate manually . The server then checks the wallet address to find which user account it belongs to, and adds the received amount to the user's balance . The server announces a transaction to the network (through the Exchange's own observer node ) to move the received funds to the hot wallet . See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. The received funds are transferred to the hot wallet when the transaction is approved by the network. The reception wallets always remain empty. Performing Withdrawals # Users must request withdrawals directly to the Exchange server through its user interface . After checking that the user has the required balance, the funds are transferred from the Exchange's hot wallet directly to the user's wallet. Here's a summary of the process: Withdrawing from an Exchange. The user requests a withdrawal to the Exchange server . The request includes some kind of user ID, the requested amount and the destination wallet's address. The server checks that the user has the required balance to perform the withdrawal. The server announces a transaction to the network (through the Exchange's own observer node ) to move the requested funds from the hot wallet to the requested destination address. See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. Caution Please make sure you sign the transaction before submitting it, as shown in the example. Unsigned transactions are ignored by the network. The requested funds are transferred to the user's wallet when the transaction is approved by the network.","title":"Architecture of an Exchange"},{"location":"exchange/architecture/#architecture-of-an-exchange","text":"What follows is the suggested architecture for a centralized Exchange. Even if your Exchange does not adopt this exact design, it defines the concepts that are used throughout the other pages in this section.","title":"Architecture of an Exchange"},{"location":"exchange/architecture/#general-structure","text":"The suggested architecture uses a Central Exchange wallet with multiple User reception wallets controlled by the Exchange. General structure of an Exchange.","title":"General Structure"},{"location":"exchange/architecture/#exchanges-central-wallet-hot","text":"This account contains the Exchange's funds required to perform user operations: Users' deposits are ultimately routed here, and users' withdrawals are taken from here. The private keys to this account need to be on an online machine (the Exchange server ) so this is considered a hot wallet . For security reasons, it is recommended that the hot wallet only contains enough funds to perform daily operations, whereas the bulk of the funds are kept in the cold wallet .","title":"Exchange's Central Wallet (Hot)"},{"location":"exchange/architecture/#exchanges-central-wallet-cold","text":"The private keys to this account are kept in an offline machine so it is less vulnerable to attacks. Moreover, it is recommended that this is a multi-signature account so the approval of more than one administrator is required to move funds from it. Periodically (e.g., once a day) funds are transferred from or to the hot wallet so it can continue operating while the bulk of the funds are protected in the cold wallet.","title":"Exchange's Central Wallet (Cold)"},{"location":"exchange/architecture/#users-reception-wallets","text":"When users sign up with the Exchange, a reception wallet is created for them in order to perform deposits. The reception wallets are usually empty: as soon as they receive funds these are transferred to the Exchange's hot wallet . The private keys to the reception wallets always remain under the Exchange's control; these wallets are offered to users as a convenience only. Users cannot perform any operation on these wallets other than deposits.","title":"Users' Reception Wallets"},{"location":"exchange/architecture/#users-wallet","text":"This is the origin of deposits made to the Exchange and the receiver of withdrawals made from the Exchange. It can be a wallet in control of the user (the user holds its private key), a custodial wallet or another Exchange, for example.","title":"User's Wallet"},{"location":"exchange/architecture/#exchange-server","text":"This is an online server, part of the Exchange's infrastructure, that receives withdrawal requests from users and monitors the reception wallets to detect incoming deposits. It holds the private keys to the hot wallet and to all the reception wallets so it can move funds from them in response to user's requests. Caution This server must be available 24/7 so it is a clear target for malicious actors.","title":"Exchange Server"},{"location":"exchange/architecture/#balances-db","text":"This database keeps track of every user's funds, since the actual tokens from all users are pooled together in the hot and cold wallets. The Exchange server updates this DB in response to user's deposits and withdrawals.","title":"Balances DB"},{"location":"exchange/architecture/#flare-observer-node","text":"An observer node is a regular Flare node that does not partake in consensus but is still aware of the current state of the blockchain and allows submitting transactions. It is highly recommended that Exchanges deploy their own observer nodes to access the network, instead of relying on third-party services. Read the Deploying an Observer Node guide to learn how to do this.","title":"Flare Observer Node"},{"location":"exchange/architecture/#detecting-deposits","text":"The Exchange server must be continuously monitoring transfers into ALL reception wallets to detect incoming deposits. Here's a summary of the process: Depositing to an Exchange. The user deposits (transfers) funds to their assigned reception wallet . The transaction is detected by the Exchange server monitoring the wallets. The server can discover a new transaction as soon as it is submitted by subscribing to the pendingTransactions event. This allows showing the transaction as \"pending\" in the UI, but there is still a chance that it is reverted. To avoid problems, the Exchange should only act on transactions appearing on blocks old enough for the chance of them being reverted to be negligible. This can be done by subscribing to the newBlockHeaders event and examining the transactions in a previous block (for example, 5 blocks behind). The code below exemplifies this process ( See the web3.js documentation for the API details): // https://web3js.readthedocs.io const Web3 = require ( 'web3' ); // Use your own node URL // https://docs.flare.network/dev/reference/coston-testnet/ const web3 = new Web3 ( \"wss://coston-api.flare.network/ext/bc/C/ws\" ); // Use your receiving wallet address const receivingAddress = \"0x947c76694491d3fD67a73688003c4d36C8780A97\" ; web3 . eth . subscribe ( \"pendingTransactions\" ) . on ( \"data\" , async ( transactionHash ) => { // New transaction hash received. // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as pending. console . log ( \"Transaction\" , tx . hash , \"is pending\" ); } }). on ( \"error\" , console . error ); web3 . eth . subscribe ( \"newBlockHeaders\" ) . on ( \"data\" , async ( blockHeader ) => { // New block has been produced. // Retrieve a block old enough to be considered confirmed. let block = await web3 . eth . getBlock ( blockHeader . number - 5 ); // Get all its transactions. block . transactions . forEach ( async ( transactionHash ) => { // Retrieve the actual transaction. let tx = await web3 . eth . getTransaction ( transactionHash ); // If it is directed to our address... if ( tx . to === receivingAddress ) { // Mark it as confirmed. console . log ( \"Transaction\" , tx . hash , \"is confirmed in block\" , block . number ); } }); }). on ( \"error\" , console . error ); Caution Note that all transactions from a block are retrieved simultaneously and this can easily trigger a rate limit on the node. A proper implementation should avoid this by serializing requests or managing the request rate manually . The server then checks the wallet address to find which user account it belongs to, and adds the received amount to the user's balance . The server announces a transaction to the network (through the Exchange's own observer node ) to move the received funds to the hot wallet . See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. The received funds are transferred to the hot wallet when the transaction is approved by the network. The reception wallets always remain empty.","title":"Detecting Deposits"},{"location":"exchange/architecture/#performing-withdrawals","text":"Users must request withdrawals directly to the Exchange server through its user interface . After checking that the user has the required balance, the funds are transferred from the Exchange's hot wallet directly to the user's wallet. Here's a summary of the process: Withdrawing from an Exchange. The user requests a withdrawal to the Exchange server . The request includes some kind of user ID, the requested amount and the destination wallet's address. The server checks that the user has the required balance to perform the withdrawal. The server announces a transaction to the network (through the Exchange's own observer node ) to move the requested funds from the hot wallet to the requested destination address. See a JavaScript example in the Ethereum documentation . Since you will be using your own node, you can skip the Alchemy part and directly use the web3 package as in the example above. Caution Please make sure you sign the transaction before submitting it, as shown in the example. Unsigned transactions are ignored by the network. The requested funds are transferred to the user's wallet when the transaction is approved by the network.","title":"Performing Withdrawals"},{"location":"exchange/delegation/","text":"Delegating on the User's Behalf # Delegation is one of the multiple ways in which the Flare blockchain rewards participants of the ecosystem. In particular, delegation allows token holders to put their stake behind an FTSO data provider to increase its relative weight (See this FTSO blog post for more information). In return, each time a data provider submits useful information it shares its reward with all the token holders that delegated to it . The Delegation Guide details this process for users. However, since Exchanges keep user's tokens, only Exchanges can perform delegation. If you are an Exchange and want to offer your users the ability to earn rewards by delegation, this page summarizes the process and explains how to perform it on the user's behalf. Introduction # Flare (and Songbird) accounts can delegate any percentage they choose of their tokens to one or two FTSO data providers . This limitation means that, if your Exchange keeps all users' tokens in a single wallet (as described in the Architecture of an Exchange page), you cannot give your users the option to select the data provider they want to delegate to: The wallet containing all tokens can only delegate to one (or two) data providers . Keeping this in mind, this page explains how to delegate the users' tokens and collect the rewards. Reward Epochs As shown later, several features of the delegation mechanism are timed in Reward Epochs . On Songbird, these epochs last 7 days and start every Saturday at around 8:40AM UTC . On Flare, they last 3.5 days and start roughly every Monday at 7:00 UTC and Thursday at 19:00 UTC . Selecting a Data Provider # It is the Exchange that must select the FTSO data provider upon which to delegate, so the first step is to choose the one you are most confident to provide consistently good data (and therefore higher rewards). Anyone can become an FTSO data provider, but only the ones that had the most voting power during the previous reward epoch are available for delegation. The list of available data providers for the current reward epoch can be retrieved from the VoterWhitelister smart contract, method getFtsoWhitelistedPriceProviders . There exist a number of websites like flaremetrics.io or ftso-signal-providers that display this information in a far more convenient way. Note Data providers take a fee before sharing their rewards with their delegators. An Exchange can decide to run its own data provider to avoid paying this fee to an external entity, at the cost of having to develop a good price prediction algorithm . Keep in mind that FTSO data providing is already a very competitive business, and only the most successful algorithms are being rewarded. Lastly, delegations can be changed at any time, but they are only taken into account once per reward epoch (See more details in the FTSO page). Therefore, depending on the time it is submitted, a new delegation will not take effect until the beginning of the next reward epoch, or the one after that . Furthermore, rewards cannot be collected until another reward epoch has elapsed . Delegation Process # See Manual Delegation and Claiming in the FTSO page.","title":"Delegating on the User's Behalf"},{"location":"exchange/delegation/#delegating-on-the-users-behalf","text":"Delegation is one of the multiple ways in which the Flare blockchain rewards participants of the ecosystem. In particular, delegation allows token holders to put their stake behind an FTSO data provider to increase its relative weight (See this FTSO blog post for more information). In return, each time a data provider submits useful information it shares its reward with all the token holders that delegated to it . The Delegation Guide details this process for users. However, since Exchanges keep user's tokens, only Exchanges can perform delegation. If you are an Exchange and want to offer your users the ability to earn rewards by delegation, this page summarizes the process and explains how to perform it on the user's behalf.","title":"Delegating on the User's Behalf"},{"location":"exchange/delegation/#introduction","text":"Flare (and Songbird) accounts can delegate any percentage they choose of their tokens to one or two FTSO data providers . This limitation means that, if your Exchange keeps all users' tokens in a single wallet (as described in the Architecture of an Exchange page), you cannot give your users the option to select the data provider they want to delegate to: The wallet containing all tokens can only delegate to one (or two) data providers . Keeping this in mind, this page explains how to delegate the users' tokens and collect the rewards. Reward Epochs As shown later, several features of the delegation mechanism are timed in Reward Epochs . On Songbird, these epochs last 7 days and start every Saturday at around 8:40AM UTC . On Flare, they last 3.5 days and start roughly every Monday at 7:00 UTC and Thursday at 19:00 UTC .","title":"Introduction"},{"location":"exchange/delegation/#selecting-a-data-provider","text":"It is the Exchange that must select the FTSO data provider upon which to delegate, so the first step is to choose the one you are most confident to provide consistently good data (and therefore higher rewards). Anyone can become an FTSO data provider, but only the ones that had the most voting power during the previous reward epoch are available for delegation. The list of available data providers for the current reward epoch can be retrieved from the VoterWhitelister smart contract, method getFtsoWhitelistedPriceProviders . There exist a number of websites like flaremetrics.io or ftso-signal-providers that display this information in a far more convenient way. Note Data providers take a fee before sharing their rewards with their delegators. An Exchange can decide to run its own data provider to avoid paying this fee to an external entity, at the cost of having to develop a good price prediction algorithm . Keep in mind that FTSO data providing is already a very competitive business, and only the most successful algorithms are being rewarded. Lastly, delegations can be changed at any time, but they are only taken into account once per reward epoch (See more details in the FTSO page). Therefore, depending on the time it is submitted, a new delegation will not take effect until the beginning of the next reward epoch, or the one after that . Furthermore, rewards cannot be collected until another reward epoch has elapsed .","title":"Selecting a Data Provider"},{"location":"exchange/delegation/#delegation-process","text":"See Manual Delegation and Claiming in the FTSO page.","title":"Delegation Process"},{"location":"exchange/troubleshooting/","text":"Troubleshooting Guide # This page contains links to other sections answering the most common support requests received when integrating with the Flare network. Regarding Node Deployment Regarding Delegation Regarding Reward Claiming","title":"Troubleshooting Guide"},{"location":"exchange/troubleshooting/#troubleshooting-guide","text":"This page contains links to other sections answering the most common support requests received when integrating with the Flare network. Regarding Node Deployment Regarding Delegation Regarding Reward Claiming","title":"Troubleshooting Guide"},{"location":"infra/","text":"Infrastructure Guides # This section contains step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it. Select one of the topics below: FTSO Data Providers Observer Nodes Validator Nodes","title":"Infrastructure Guides"},{"location":"infra/#infrastructure-guides","text":"This section contains step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it. Select one of the topics below: FTSO Data Providers Observer Nodes Validator Nodes","title":"Infrastructure Guides"},{"location":"infra/data/","text":"FTSO Data Providers # Select one of the topics below: Managing the Ecosystem Operating a Data Provider Working with Whitelists","title":"FTSO Data Providers"},{"location":"infra/data/#ftso-data-providers","text":"Select one of the topics below: Managing the Ecosystem Operating a Data Provider Working with Whitelists","title":"FTSO Data Providers"},{"location":"infra/data/managing-ecosystem/","text":"Managing the Ecosystem # The following information explains how to manage the FTSO ecosystem by participating in the FTSO Management Group, as described in FIP.02 , which was accepted on March 6, 2023. To prevent malicious behaviors that impair the FTSO ecosystem, the FTSO Management Group reports possible infractions committed by FTSO data providers and determines whether to punish them . Punished data providers are chilled , which means they are removed from the whitelist , either temporarily or permanently, depending on the quantity of infractions they have committed. Any address can request to be a member of the group, but only upstanding FTSO data providers are accepted. As a security measure to be used only when absolutely necessary, the Flare Foundation reserves the right to add and remove members on its own accord. Management Process # The group adheres to the following management process . For complete details about each step in the process, click each hyperlink. Discuss possible infractions (section 2.2.1). Submit a chill proposal (section 2.2.2). Vote on the proposal (sections 2.2.2 - 2.2.4). Depending on the outcome of the vote, the provider might be chilled (section 2.3). Discussing Infractions # When you suspect a data provider is harming the ecosystem, you must discuss the malicious behavior with other group members in the Flare FTSO Self-Policing Forum to inform the FTSO community about the problem and gather the necessary quorum for a potential vote. It facilitates the decision about whether to submit a formal proposal to chill the attacker. The discussion is not binding. Retrieving the PollingFtso contract # The PollingFtso contract handles interactions such as managing group members, submitting proposals, voting, and more. The following procedure explains how to interact directly with this contract. However, if you prefer a simpler interface, the Flare community is developing front-ends to facilitate the interactions, such as Flaremetrics . Open a block explorer for the appropriate network. Follow the Retrieval from Blockchain procedure to find and open the PollingFtso contract. The Contract Address Details page is displayed. Optional: If you need to call a method in the Write tab, click the Write Contract tab, click Connect Wallet , and complete the steps to connect your wallet. After the PollingFtso contract is open in the explorer, you can complete operations to manage members and chill proposals. Managing Group Members # To be a member you need to be an upstanding data provider , which means: You have received FTSO rewards for the last 20 reward epochs. You have not been chilled in the last 20 reward epochs. You have not been removed from the group in the last week. After the PollingFtso contract is open in the explorer, you can do the following operations, among others. Adding Members # Anyone can request to become a member of the FTSO Management Group. In the Write tab, locate the addMember method, and click Write to call it. Follow the steps to complete the transaction in your wallet. Your request to be added to the group is submitted. If you meet the conditions of an upstanding data provider , you are automatically added to the group. Removing Members # Anyone can ask for a member of the FTSO Management Group to be removed. In the Write tab, locate the removeMember method, and specify a value for this parameter: _account(address) : The address of the member you want to remove from the group. Click Write to call the removeMember method. Follow the steps to complete the transaction in your wallet. Your request to remove a member from the group is submitted. If the member no longer meets the conditions of an upstanding data provider , the member is immediately removed. Managing Chill Proposals # After the PollingFtso contract is open in the explorer, you can do the following operations, among others. Submitting a Proposal # If you are a member of the FTSO Management Group or a member's proxy , you can submit a chill proposal. In the Write tab, locate the propose method, and specify values for these parameters: _description(string) : A free-form description of the problem to be voted on. It does not have a fixed structure, but it must contain at least the URL for the discussion in the forum (section 2.2.2.d) value(FLR or SGB) : The cost to call the propose method to submit the proposal, which you must specify as the value. The current cost is 100 $FLR or $SGB . Because this cost can fluctuate, retrieve the current cost by locating the proposalFeeValueWei method in the Read tab, which automatically displays the cost. Click Write to call the propose method. Follow the steps to complete the transaction in your wallet. Your proposal is submitted, and the proposalId is returned. Post the proposalId in the discussion thread so that members of the group can use it to vote on the proposal. Voting on a Proposal # You can vote on a proposal when the following conditions are met: You are a member of the FTSO Management Group or a member's proxy . The proposal is active. To vote on a proposal: In the Write tab, locate the castVote method, and specify values for these parameters: _proposalId(uint256) : The proposal ID posted by the proponent in the discussion thread. This ID was obtained by proponent when the proposal was submitted. If you specify nonexistent IDs or IDs for proposals that have completed, the transaction reverts, and the explorer returns empty results. _support(uint8) : Specify one of the following values. 0 : Vote against the proposal. 1 : Vote in favor of the proposal. If you specify values other than 0 or 1 , the transaction reverts. Click Write to call the castVote method. Follow the steps to complete the transaction in your wallet. Your vote is cast. Setting a Proxy Voter # If you are a member of the group, you can declare one address that can manage proposals and vote on them on your behalf. This address is known as your proxy. Your proxy can submit proposals and vote on them. In the Write tab, locate the setProxyVoter method, and specify the value for this parameter: _proxyVoter(address) : The address you want to declare as your proxy. Click Write to call the setProxyVoter method. Follow the steps to complete the transaction in your wallet. The specified address is set as your proxy voter. Removing a Proxy Voter # In the Write tab, locate the setProxyVoter method, and specify the value for this parameter: _proxyVoter(address) : Specify the zero address 0x0000000000000000000000000000000000000000 . Click Write to call the setProxyVoter method. Follow the steps to complete the transaction in your wallet. The previously specified proxy address is revoked. Determining Your Proxy Voter's Address # In the Read tab, locate the providerToProxy method, and specify the value for this parameter: (address) : The address that declared the proxy. Click Query to call the providerToProxy method. The address of the proxy voter is returned. Retrieving the Last Proposal # In the Read tab, locate the getLastProposal method. The number of the most recent proposal and its description are displayed. Retrieving a List of Group Members # In the Read tab, locate the getManagementGroupMembers method. A list of the addresses of members is displayed. Retrieving a Proposal Description # In the Read tab, locate the getProposalDescription method, and specify the value for this parameter: proposalId(uint256) : The ID of the proposal whose description you want. If you don't know the proposal ID, refer to the proposal's discussion thread. Click Query to call the getProposalDescription method. The description of the specified proposal ID is returned. If you specified a nonexistent ID for the proposalId parameter, an empty string is returned. Retrieving a Vote Count # In the Read tab, locate the getProposalVotes method, and specify the value for this parameter: proposalId(uint256) : The ID of the proposal whose vote count you want. Proposal IDs are posted in its corresponding discussion thread. Click Query to call the getProposalVotes method. The number of votes in favor of the proposal and the number of votes against it are returned. If you specified a nonexistent ID for the proposalId parameter, 0 is returned as the number of votes for the proposal and as the number of votes against it. Determining a Member's Vote Status # In the Read tab, locate the hasVoted method, and specify the value for these parameters: proposalId(uint256) : The ID of the proposal for which you want to determine a member's vote status. voter(address) : The address of the member. If you do not know the address, refer to the list of addresses for all group members . Click Query to call the hasVoted method. A boolean value indicating whether the member has voted is returned. If you specified a nonexistent ID for the proposalId parameter, false is returned.","title":"Managing the Ecosystem"},{"location":"infra/data/managing-ecosystem/#managing-the-ecosystem","text":"The following information explains how to manage the FTSO ecosystem by participating in the FTSO Management Group, as described in FIP.02 , which was accepted on March 6, 2023. To prevent malicious behaviors that impair the FTSO ecosystem, the FTSO Management Group reports possible infractions committed by FTSO data providers and determines whether to punish them . Punished data providers are chilled , which means they are removed from the whitelist , either temporarily or permanently, depending on the quantity of infractions they have committed. Any address can request to be a member of the group, but only upstanding FTSO data providers are accepted. As a security measure to be used only when absolutely necessary, the Flare Foundation reserves the right to add and remove members on its own accord.","title":"Managing the Ecosystem"},{"location":"infra/data/managing-ecosystem/#management-process","text":"The group adheres to the following management process . For complete details about each step in the process, click each hyperlink. Discuss possible infractions (section 2.2.1). Submit a chill proposal (section 2.2.2). Vote on the proposal (sections 2.2.2 - 2.2.4). Depending on the outcome of the vote, the provider might be chilled (section 2.3).","title":"Management Process"},{"location":"infra/data/managing-ecosystem/#discussing-infractions","text":"When you suspect a data provider is harming the ecosystem, you must discuss the malicious behavior with other group members in the Flare FTSO Self-Policing Forum to inform the FTSO community about the problem and gather the necessary quorum for a potential vote. It facilitates the decision about whether to submit a formal proposal to chill the attacker. The discussion is not binding.","title":"Discussing Infractions"},{"location":"infra/data/managing-ecosystem/#retrieving-the-pollingftso-contract","text":"The PollingFtso contract handles interactions such as managing group members, submitting proposals, voting, and more. The following procedure explains how to interact directly with this contract. However, if you prefer a simpler interface, the Flare community is developing front-ends to facilitate the interactions, such as Flaremetrics . Open a block explorer for the appropriate network. Follow the Retrieval from Blockchain procedure to find and open the PollingFtso contract. The Contract Address Details page is displayed. Optional: If you need to call a method in the Write tab, click the Write Contract tab, click Connect Wallet , and complete the steps to connect your wallet. After the PollingFtso contract is open in the explorer, you can complete operations to manage members and chill proposals.","title":"Retrieving the PollingFtso contract"},{"location":"infra/data/managing-ecosystem/#managing-group-members","text":"To be a member you need to be an upstanding data provider , which means: You have received FTSO rewards for the last 20 reward epochs. You have not been chilled in the last 20 reward epochs. You have not been removed from the group in the last week. After the PollingFtso contract is open in the explorer, you can do the following operations, among others.","title":"Managing Group Members"},{"location":"infra/data/managing-ecosystem/#adding-members","text":"Anyone can request to become a member of the FTSO Management Group. In the Write tab, locate the addMember method, and click Write to call it. Follow the steps to complete the transaction in your wallet. Your request to be added to the group is submitted. If you meet the conditions of an upstanding data provider , you are automatically added to the group.","title":"Adding Members"},{"location":"infra/data/managing-ecosystem/#removing-members","text":"Anyone can ask for a member of the FTSO Management Group to be removed. In the Write tab, locate the removeMember method, and specify a value for this parameter: _account(address) : The address of the member you want to remove from the group. Click Write to call the removeMember method. Follow the steps to complete the transaction in your wallet. Your request to remove a member from the group is submitted. If the member no longer meets the conditions of an upstanding data provider , the member is immediately removed.","title":"Removing Members"},{"location":"infra/data/managing-ecosystem/#managing-chill-proposals","text":"After the PollingFtso contract is open in the explorer, you can do the following operations, among others.","title":"Managing Chill Proposals"},{"location":"infra/data/managing-ecosystem/#submitting-a-proposal","text":"If you are a member of the FTSO Management Group or a member's proxy , you can submit a chill proposal. In the Write tab, locate the propose method, and specify values for these parameters: _description(string) : A free-form description of the problem to be voted on. It does not have a fixed structure, but it must contain at least the URL for the discussion in the forum (section 2.2.2.d) value(FLR or SGB) : The cost to call the propose method to submit the proposal, which you must specify as the value. The current cost is 100 $FLR or $SGB . Because this cost can fluctuate, retrieve the current cost by locating the proposalFeeValueWei method in the Read tab, which automatically displays the cost. Click Write to call the propose method. Follow the steps to complete the transaction in your wallet. Your proposal is submitted, and the proposalId is returned. Post the proposalId in the discussion thread so that members of the group can use it to vote on the proposal.","title":"Submitting a Proposal"},{"location":"infra/data/managing-ecosystem/#voting-on-a-proposal","text":"You can vote on a proposal when the following conditions are met: You are a member of the FTSO Management Group or a member's proxy . The proposal is active. To vote on a proposal: In the Write tab, locate the castVote method, and specify values for these parameters: _proposalId(uint256) : The proposal ID posted by the proponent in the discussion thread. This ID was obtained by proponent when the proposal was submitted. If you specify nonexistent IDs or IDs for proposals that have completed, the transaction reverts, and the explorer returns empty results. _support(uint8) : Specify one of the following values. 0 : Vote against the proposal. 1 : Vote in favor of the proposal. If you specify values other than 0 or 1 , the transaction reverts. Click Write to call the castVote method. Follow the steps to complete the transaction in your wallet. Your vote is cast.","title":"Voting on a Proposal"},{"location":"infra/data/managing-ecosystem/#setting-a-proxy-voter","text":"If you are a member of the group, you can declare one address that can manage proposals and vote on them on your behalf. This address is known as your proxy. Your proxy can submit proposals and vote on them. In the Write tab, locate the setProxyVoter method, and specify the value for this parameter: _proxyVoter(address) : The address you want to declare as your proxy. Click Write to call the setProxyVoter method. Follow the steps to complete the transaction in your wallet. The specified address is set as your proxy voter.","title":"Setting a Proxy Voter"},{"location":"infra/data/managing-ecosystem/#removing-a-proxy-voter","text":"In the Write tab, locate the setProxyVoter method, and specify the value for this parameter: _proxyVoter(address) : Specify the zero address 0x0000000000000000000000000000000000000000 . Click Write to call the setProxyVoter method. Follow the steps to complete the transaction in your wallet. The previously specified proxy address is revoked.","title":"Removing a Proxy Voter"},{"location":"infra/data/managing-ecosystem/#determining-your-proxy-voters-address","text":"In the Read tab, locate the providerToProxy method, and specify the value for this parameter: (address) : The address that declared the proxy. Click Query to call the providerToProxy method. The address of the proxy voter is returned.","title":"Determining Your Proxy Voter's Address"},{"location":"infra/data/managing-ecosystem/#retrieving-the-last-proposal","text":"In the Read tab, locate the getLastProposal method. The number of the most recent proposal and its description are displayed.","title":"Retrieving the Last Proposal"},{"location":"infra/data/managing-ecosystem/#retrieving-a-list-of-group-members","text":"In the Read tab, locate the getManagementGroupMembers method. A list of the addresses of members is displayed.","title":"Retrieving a List of Group Members"},{"location":"infra/data/managing-ecosystem/#retrieving-a-proposal-description","text":"In the Read tab, locate the getProposalDescription method, and specify the value for this parameter: proposalId(uint256) : The ID of the proposal whose description you want. If you don't know the proposal ID, refer to the proposal's discussion thread. Click Query to call the getProposalDescription method. The description of the specified proposal ID is returned. If you specified a nonexistent ID for the proposalId parameter, an empty string is returned.","title":"Retrieving a Proposal Description"},{"location":"infra/data/managing-ecosystem/#retrieving-a-vote-count","text":"In the Read tab, locate the getProposalVotes method, and specify the value for this parameter: proposalId(uint256) : The ID of the proposal whose vote count you want. Proposal IDs are posted in its corresponding discussion thread. Click Query to call the getProposalVotes method. The number of votes in favor of the proposal and the number of votes against it are returned. If you specified a nonexistent ID for the proposalId parameter, 0 is returned as the number of votes for the proposal and as the number of votes against it.","title":"Retrieving a Vote Count"},{"location":"infra/data/managing-ecosystem/#determining-a-members-vote-status","text":"In the Read tab, locate the hasVoted method, and specify the value for these parameters: proposalId(uint256) : The ID of the proposal for which you want to determine a member's vote status. voter(address) : The address of the member. If you do not know the address, refer to the list of addresses for all group members . Click Query to call the hasVoted method. A boolean value indicating whether the member has voted is returned. If you specified a nonexistent ID for the proposalId parameter, false is returned.","title":"Determining a Member's Vote Status"},{"location":"infra/data/operating/","text":"Operating a Data Provider # Introduction # Quick links NPM Kickoff package Reference implementation Data providers play an essential role in the decentralized oracle system by submitting data to on-chain contracts deployed on the Flare and Songbird networks. Operating a data provider generates rewards in $FLR , $SGB , or both for you and the people who delegate tokens to you. To maximize your rewards, your data provider needs to be constantly available and operating. If your data provider is unavailable and doesn't send data during a specific epoch, you and your delegators won't earn rewards during that epoch. If all the submission and reveal transactions are successful, the cost is approximately 3 - 4 $FLR or $SGB per day. Data providers consist of the following code components, and you can write them in any language: FTSO interface : The code that submits data to the FTSO. This code is all the necessary logic to determine which data epoch you want to submit data in and to assess when and what to submit throughout all reward epochs. Data algorithm : The code that runs the algorithm that collects and processes data. The more efficient this code is the better advantage over competing data providers you will have. Consider these tips for maximizing your advantage . The rest of this guide explains how to deploy and operate a data provider. Prerequisites # While none of the listed prerequisites are required, you will be more successful if you have them before you try to deploy an FTSO data provider: Familiarity with smart contracts, signal processing, game theory, and prompt data submission on blockchains Experience with a coding language that has a web3 library, for example: Language Web3 Library Go go-web3 Java web3.j JavaScript ethers.js , web3.j Node.js ethers.js , web3.j Python web3.py Rust rust-web3 Getting Started # To start building your data provider, use the npm kick-off package . It showcases the main contracts related to whitelisting a data provider and submitting data, and it enables you to deploy FTSO mock contracts in a local setup and submit data to those contracts. Providing data by using this package is like providing data on-chain. The following aspects work identically in the package and on-chain: Smart-contract APIs Events Timing aspects in the package work similarly but not identically to timing aspects on-chain. The package does not run the weighted-median algorithm or do calculations to distribute rewards like the FTSO smart contract deployed on-chain does. The Flare Network price provider repository shows an example of a data-provider implementation. This implementation shows the FTSO interface and a sample data algorithm. To earn rewards, you must write your own data algorithm. Interacting with Smart Contracts # Data providers interact primarily with the PriceSubmitter contract and the different FTSO contracts. Other useful contracts are: FtsoRegistry : Holds information about specific FTSOs, their symbols, indices, and addresses. To see supported tickers, query the getSupportedSymbols method. New tickers can be added by a governance vote. FtsoManager : Holds epoch and voting-related configuration data, oversees all FTSOs, and gives access to additional useful contracts, such as the Inflation and Supply contracts. VoterWhitelister : Accepts the names of data providers that list themselves to submit data. Find these contract's addresses in the Contract Addresses page. Generating Random Numbers # The data-providing process is structured as a commit-and-reveal scheme to prevent users from copying another user's submitted data. The commit-and-reveal phases are restricted to only a few minutes in duration. With each reveal the data provider also provides a random number. The random number is used first as a salt in the commit-and-reveal scheme and later during the reward calculation process. Strong random numbers are important for network security because they are the only true source of randomness on the network, and they make the commit-and-reveal scheme resilient to attacks. Random numbers below 2 128 are considered weak and unsafe, and they are rejected when they are revealed. To provide strong, cryptographically secure, random numbers with high entropy and sufficient range, consider implementing the following strategies: Use available random-number generators, such as the csprng library for Node.js applications or the web3.utils.toBN(web3.utils.randomHex(32)) function in the web3.utils package for JavaScript. Submit 256-bit random numbers. Calculating Hash for the Commit-and-Reveal Scheme # The FTSO price provider shows the complete specification for the commit-and-reveal scheme. The following code snippets show how to generate hashes in Typescript and Python using publicly available web3 libraries: Typescript Python import BN from \"bn.js\" ; import { BigNumber } from \"ethers\" ; import { ethers } from \"hardhat\" ; const MIN_RANDOM = web3 . utils . toBN ( 2 ). pow ( web3 . utils . toBN ( 128 )); function submitHash ( ftsoIndices : ( number | BN | BigNumber )[], prices : ( number | BN | BigNumber )[], random : number | BN | BigNumber , address : string ) : string { return ethers . utils . keccak256 ( web3 . eth . abi . encodeParameters ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ])); } const ftsoIndices = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; const randoms = [ MIN_RANDOM , MIN_RANDOM . addn ( 5 ), MIN_RANDOM . addn ( 1059 ), MIN_RANDOM . addn ( 10682 ), MIN_RANDOM . addn ( 159726 ) ]; const prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ]; const addrs = [ accounts [ 10 ], accounts [ 11 ], accounts [ 12 ], accounts [ 13 ]]; console . log ( `Prices: ${ prices } ` ); for ( let addr of addrs ) { console . log ( `Address: ${ addr } ` ); for ( let random of randoms ) { console . log ( `\\tRandom: ${ random } ` ) const hash = submitHash ( ftsoIndices , prices , random , addr ); console . log ( `\\t\\t ${ hash } ` ); } } from typing import List from web3 import Web3 import eth_abi minimal_random = 2 ** 128 def submit_price_hash ( ftsoIndices : List [ int ], prices : List [ int ], random : int , address : str ) -> str : assert len ( ftsoIndices ) == len ( prices ) assert list ( sorted ( ftsoIndices )) == ftsoIndices and len ( set ( ftsoIndices ) ) == len ( ftsoIndices ), \"Indices are non increasing\" return Web3 . keccak ( eth_abi . encode_abi ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ], ) ) . hex () def test_fun ( prices : List [ int ], random : int , address = \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , ) -> List [ str ]: return submit_price_hash ( list ( range ( len ( prices ))), prices , random , address ) addrs = [ \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , \"0xEa960515F8b4C237730F028cBAcF0a28E7F45dE0\" , \"0x3d91185a02774C70287F6c74Dd26d13DFB58ff16\" , ] prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ] randoms = [ min_random + r for r in [ 0 , 1 , 100 , 101 , 100000000000000000000 ] ] for addr in addrs : print ( f \"Address: { addr } \" ) for rand in randoms : print ( f \" Random: { rand } \" ) print ( \" hash:\" , test_fun ( prices , rand , addr )) print () Info To see sample code for calculating submit hashes using the web3.py library, see the hasher.py gist . Retrieving Information About Rewarded Data # Listen for PriceFinalized events, which contain information about calculated median data and rewarding bounds. Each FTSO emits these events. Managing Vote Power # To check your vote power in a specific vote power block, use the votePowerOfAt method in the WNat contract. To find the vote-power block of the current reward epoch, use the getCurrentRewardEpoch method in the FtsoManager contract. Then, use the getRewardEpochVotePowerBlock method in the same contract. Vote power delegated to you belongs to only you; you cannot redelegate it. To retrieve information about delegations you receive, listen to Delegate events because this information is not contained in any on-chain structure. Retrieving Price Epoch Information # Use the getPriceEpochConfiguration method in the FtsoManager contract to retrieve: When the first price epoch started, as a UNIX timestamp. The duration of every price epoch, in seconds. The duration of every reveal phase, in seconds. These numbers allow you to calculate the price epoch number from any timestamp. The duration of price epochs is fixed and can only change through a governance decision. Submitting Data On-Chain # After you feel comfortable running the local npm package, you can start submitting your data on the real network. To run on the real network, you need to: Gain vote power : You can whitelist yourself as a data provider only if you have enough vote power. Optimize your timing : Align with the on-chain time data. Because the network is decentralized, the on-chain timestamp might skew up to 30 - 40 seconds from the real-world time. To avoid missing commit-and-reveal periods, synchronize local time with global time through the Network Time Protocol (NTP) . The later you submit, the more time you have to gather data. However, if you submit too late, you might miss the epoch window. Find the balance that works best for you. Claim rewards : Ensure you regularly claim your rewards and wrap them to earn more vote power. Each FTSO emits a PriceFinalized event that contains information about calculated median data and rewarding bounds. Set the gas limit of your commit-and-reveal transactions to around 2'500'000 gwei so that you provide enough gas. Maximizing Your Data Algorithm's Performance # Use the following tips: Run your own observer node and submit all your data through it. This will allow you to more efficiently and securely operate your data provider. Gather your data directly from each source instead of using APIs provided by data aggregators. Write your own code instead of relying entirely on third-party code. Keep an open mind, and try new strategies to find your advantage over other data providers and keep it. If your submissions are reverted, ensure the node you submit them through is healthy and has enough peers, and review the above tips.","title":"Operating a Data Provider"},{"location":"infra/data/operating/#operating-a-data-provider","text":"","title":"Operating a Data Provider"},{"location":"infra/data/operating/#introduction","text":"Quick links NPM Kickoff package Reference implementation Data providers play an essential role in the decentralized oracle system by submitting data to on-chain contracts deployed on the Flare and Songbird networks. Operating a data provider generates rewards in $FLR , $SGB , or both for you and the people who delegate tokens to you. To maximize your rewards, your data provider needs to be constantly available and operating. If your data provider is unavailable and doesn't send data during a specific epoch, you and your delegators won't earn rewards during that epoch. If all the submission and reveal transactions are successful, the cost is approximately 3 - 4 $FLR or $SGB per day. Data providers consist of the following code components, and you can write them in any language: FTSO interface : The code that submits data to the FTSO. This code is all the necessary logic to determine which data epoch you want to submit data in and to assess when and what to submit throughout all reward epochs. Data algorithm : The code that runs the algorithm that collects and processes data. The more efficient this code is the better advantage over competing data providers you will have. Consider these tips for maximizing your advantage . The rest of this guide explains how to deploy and operate a data provider.","title":"Introduction"},{"location":"infra/data/operating/#prerequisites","text":"While none of the listed prerequisites are required, you will be more successful if you have them before you try to deploy an FTSO data provider: Familiarity with smart contracts, signal processing, game theory, and prompt data submission on blockchains Experience with a coding language that has a web3 library, for example: Language Web3 Library Go go-web3 Java web3.j JavaScript ethers.js , web3.j Node.js ethers.js , web3.j Python web3.py Rust rust-web3","title":"Prerequisites"},{"location":"infra/data/operating/#getting-started","text":"To start building your data provider, use the npm kick-off package . It showcases the main contracts related to whitelisting a data provider and submitting data, and it enables you to deploy FTSO mock contracts in a local setup and submit data to those contracts. Providing data by using this package is like providing data on-chain. The following aspects work identically in the package and on-chain: Smart-contract APIs Events Timing aspects in the package work similarly but not identically to timing aspects on-chain. The package does not run the weighted-median algorithm or do calculations to distribute rewards like the FTSO smart contract deployed on-chain does. The Flare Network price provider repository shows an example of a data-provider implementation. This implementation shows the FTSO interface and a sample data algorithm. To earn rewards, you must write your own data algorithm.","title":"Getting Started"},{"location":"infra/data/operating/#interacting-with-smart-contracts","text":"Data providers interact primarily with the PriceSubmitter contract and the different FTSO contracts. Other useful contracts are: FtsoRegistry : Holds information about specific FTSOs, their symbols, indices, and addresses. To see supported tickers, query the getSupportedSymbols method. New tickers can be added by a governance vote. FtsoManager : Holds epoch and voting-related configuration data, oversees all FTSOs, and gives access to additional useful contracts, such as the Inflation and Supply contracts. VoterWhitelister : Accepts the names of data providers that list themselves to submit data. Find these contract's addresses in the Contract Addresses page.","title":"Interacting with Smart Contracts"},{"location":"infra/data/operating/#generating-random-numbers","text":"The data-providing process is structured as a commit-and-reveal scheme to prevent users from copying another user's submitted data. The commit-and-reveal phases are restricted to only a few minutes in duration. With each reveal the data provider also provides a random number. The random number is used first as a salt in the commit-and-reveal scheme and later during the reward calculation process. Strong random numbers are important for network security because they are the only true source of randomness on the network, and they make the commit-and-reveal scheme resilient to attacks. Random numbers below 2 128 are considered weak and unsafe, and they are rejected when they are revealed. To provide strong, cryptographically secure, random numbers with high entropy and sufficient range, consider implementing the following strategies: Use available random-number generators, such as the csprng library for Node.js applications or the web3.utils.toBN(web3.utils.randomHex(32)) function in the web3.utils package for JavaScript. Submit 256-bit random numbers.","title":"Generating Random Numbers"},{"location":"infra/data/operating/#calculating-hash-for-the-commit-and-reveal-scheme","text":"The FTSO price provider shows the complete specification for the commit-and-reveal scheme. The following code snippets show how to generate hashes in Typescript and Python using publicly available web3 libraries: Typescript Python import BN from \"bn.js\" ; import { BigNumber } from \"ethers\" ; import { ethers } from \"hardhat\" ; const MIN_RANDOM = web3 . utils . toBN ( 2 ). pow ( web3 . utils . toBN ( 128 )); function submitHash ( ftsoIndices : ( number | BN | BigNumber )[], prices : ( number | BN | BigNumber )[], random : number | BN | BigNumber , address : string ) : string { return ethers . utils . keccak256 ( web3 . eth . abi . encodeParameters ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ])); } const ftsoIndices = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]; const randoms = [ MIN_RANDOM , MIN_RANDOM . addn ( 5 ), MIN_RANDOM . addn ( 1059 ), MIN_RANDOM . addn ( 10682 ), MIN_RANDOM . addn ( 159726 ) ]; const prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ]; const addrs = [ accounts [ 10 ], accounts [ 11 ], accounts [ 12 ], accounts [ 13 ]]; console . log ( `Prices: ${ prices } ` ); for ( let addr of addrs ) { console . log ( `Address: ${ addr } ` ); for ( let random of randoms ) { console . log ( `\\tRandom: ${ random } ` ) const hash = submitHash ( ftsoIndices , prices , random , addr ); console . log ( `\\t\\t ${ hash } ` ); } } from typing import List from web3 import Web3 import eth_abi minimal_random = 2 ** 128 def submit_price_hash ( ftsoIndices : List [ int ], prices : List [ int ], random : int , address : str ) -> str : assert len ( ftsoIndices ) == len ( prices ) assert list ( sorted ( ftsoIndices )) == ftsoIndices and len ( set ( ftsoIndices ) ) == len ( ftsoIndices ), \"Indices are non increasing\" return Web3 . keccak ( eth_abi . encode_abi ( [ \"uint256[]\" , \"uint256[]\" , \"uint256\" , \"address\" ], [ ftsoIndices , prices , random , address ], ) ) . hex () def test_fun ( prices : List [ int ], random : int , address = \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , ) -> List [ str ]: return submit_price_hash ( list ( range ( len ( prices ))), prices , random , address ) addrs = [ \"0xD7de703D9BBC4602242D0f3149E5fFCD30Eb3ADF\" , \"0xEa960515F8b4C237730F028cBAcF0a28E7F45dE0\" , \"0x3d91185a02774C70287F6c74Dd26d13DFB58ff16\" , ] prices = [ 0 , 1 , 2 , 3 , 5 , 10 , 50 , 100 , 101 , 10 ** 5 + 1 , 10 ** 8 ] randoms = [ min_random + r for r in [ 0 , 1 , 100 , 101 , 100000000000000000000 ] ] for addr in addrs : print ( f \"Address: { addr } \" ) for rand in randoms : print ( f \" Random: { rand } \" ) print ( \" hash:\" , test_fun ( prices , rand , addr )) print () Info To see sample code for calculating submit hashes using the web3.py library, see the hasher.py gist .","title":"Calculating Hash for the Commit-and-Reveal Scheme"},{"location":"infra/data/operating/#retrieving-information-about-rewarded-data","text":"Listen for PriceFinalized events, which contain information about calculated median data and rewarding bounds. Each FTSO emits these events.","title":"Retrieving Information About Rewarded Data"},{"location":"infra/data/operating/#managing-vote-power","text":"To check your vote power in a specific vote power block, use the votePowerOfAt method in the WNat contract. To find the vote-power block of the current reward epoch, use the getCurrentRewardEpoch method in the FtsoManager contract. Then, use the getRewardEpochVotePowerBlock method in the same contract. Vote power delegated to you belongs to only you; you cannot redelegate it. To retrieve information about delegations you receive, listen to Delegate events because this information is not contained in any on-chain structure.","title":"Managing Vote Power"},{"location":"infra/data/operating/#retrieving-price-epoch-information","text":"Use the getPriceEpochConfiguration method in the FtsoManager contract to retrieve: When the first price epoch started, as a UNIX timestamp. The duration of every price epoch, in seconds. The duration of every reveal phase, in seconds. These numbers allow you to calculate the price epoch number from any timestamp. The duration of price epochs is fixed and can only change through a governance decision.","title":"Retrieving Price Epoch Information"},{"location":"infra/data/operating/#submitting-data-on-chain","text":"After you feel comfortable running the local npm package, you can start submitting your data on the real network. To run on the real network, you need to: Gain vote power : You can whitelist yourself as a data provider only if you have enough vote power. Optimize your timing : Align with the on-chain time data. Because the network is decentralized, the on-chain timestamp might skew up to 30 - 40 seconds from the real-world time. To avoid missing commit-and-reveal periods, synchronize local time with global time through the Network Time Protocol (NTP) . The later you submit, the more time you have to gather data. However, if you submit too late, you might miss the epoch window. Find the balance that works best for you. Claim rewards : Ensure you regularly claim your rewards and wrap them to earn more vote power. Each FTSO emits a PriceFinalized event that contains information about calculated median data and rewarding bounds. Set the gas limit of your commit-and-reveal transactions to around 2'500'000 gwei so that you provide enough gas.","title":"Submitting Data On-Chain"},{"location":"infra/data/operating/#maximizing-your-data-algorithms-performance","text":"Use the following tips: Run your own observer node and submit all your data through it. This will allow you to more efficiently and securely operate your data provider. Gather your data directly from each source instead of using APIs provided by data aggregators. Write your own code instead of relying entirely on third-party code. Keep an open mind, and try new strategies to find your advantage over other data providers and keep it. If your submissions are reverted, ensure the node you submit them through is healthy and has enough peers, and review the above tips.","title":"Maximizing Your Data Algorithm's Performance"},{"location":"infra/data/whitelisting/","text":"Working with Whitelists # Introduction # To be a data provider, you must be whitelisted . Only the top 100 data providers with the most vote power per FTSO can submit data. No minimum amount of vote power is required. Per FTSO, a data provider's vote power is based on its balance of $WFLR or $WSGB . When a data provider tries to whitelist itself, its vote power is calculated by the vote-power block of the current reward epoch. Increased vote power on a different block will not enable your address to be whitelisted. Vote power is only read and whitelists updated once per reward epoch. Reward epochs start roughly on Saturdays at 8:40AM UTC on Songbird, and on Monday at 7:00 UTC and Thursday at 19:00 UTC on Flare. Whitelisting a data provider is a fully decentralized process facilitated by the VoterWhitelister contract. To retrieve this contract, see Contract Addresses . To be added to the whitelist, submit a request for your address by using one of the functions listed in the next section. When the whitelist is not full, your address is immediately added to it. If both the list is full and your vote power is greater than the data provider with the lowest vote power, your address replaces that data provider's address on the whitelist. If the number of spaces for data providers is ever reduced by governance, addresses will be removed from the whitelist one by one, beginning with the address with the lowest vote power. Events are emitted to notify providers about changes of their status on the whitelist. Once an address is delisted, submissions will also start reverting. Requesting to be Added to the Whitelist or Relisted # Use the following methods in the VoterWhitelister contract: requestWhitelistingVoter() : Requests whitelisting for a specific asset index. requestFullVoterWhitelisting() : Requests whitelisting for all assets. Ensure you have more delegations and vote power than the data provider that has the lowest amount before the vote power block is chosen and before you submit the request to be relisted. Reading Whitelists # Each FTSO contains an array of whitelisted addresses. Use the functions in the following contracts to determine whether you are on the list and eligible to submit data: VoterWhitelister contract The getFtsoWhitelistedPriceProviders function returns a list of addresses for all data providers on the whitelist. Specify the required index, run the query, and search for your address. PriceSubmitter contract The voterWhitelistBitmap function returns a bitmap corresponding to allowed FTSO indices in big-endian format. Specify your address, run the query and examine the returned bitmap. E.g., if you were allowed to submit prices for FTSOs with indices 0, 2 and 3, the returned bitmap would be 13 ( 1101 in binary). Monitoring Your Whitelist Status # When you are added to a whitelist, the VoterWhitelisted event is emitted from the VoterWhitelister contract. When you are removed from a whitelist, the VoterRemovedFromWhitelist event is emitted, and your subsequent submissions fail. To stay aware of your whitelist status, consider listening to events that notify you about additions and removals when they happen.","title":"Working with Whitelists"},{"location":"infra/data/whitelisting/#working-with-whitelists","text":"","title":"Working with Whitelists"},{"location":"infra/data/whitelisting/#introduction","text":"To be a data provider, you must be whitelisted . Only the top 100 data providers with the most vote power per FTSO can submit data. No minimum amount of vote power is required. Per FTSO, a data provider's vote power is based on its balance of $WFLR or $WSGB . When a data provider tries to whitelist itself, its vote power is calculated by the vote-power block of the current reward epoch. Increased vote power on a different block will not enable your address to be whitelisted. Vote power is only read and whitelists updated once per reward epoch. Reward epochs start roughly on Saturdays at 8:40AM UTC on Songbird, and on Monday at 7:00 UTC and Thursday at 19:00 UTC on Flare. Whitelisting a data provider is a fully decentralized process facilitated by the VoterWhitelister contract. To retrieve this contract, see Contract Addresses . To be added to the whitelist, submit a request for your address by using one of the functions listed in the next section. When the whitelist is not full, your address is immediately added to it. If both the list is full and your vote power is greater than the data provider with the lowest vote power, your address replaces that data provider's address on the whitelist. If the number of spaces for data providers is ever reduced by governance, addresses will be removed from the whitelist one by one, beginning with the address with the lowest vote power. Events are emitted to notify providers about changes of their status on the whitelist. Once an address is delisted, submissions will also start reverting.","title":"Introduction"},{"location":"infra/data/whitelisting/#requesting-to-be-added-to-the-whitelist-or-relisted","text":"Use the following methods in the VoterWhitelister contract: requestWhitelistingVoter() : Requests whitelisting for a specific asset index. requestFullVoterWhitelisting() : Requests whitelisting for all assets. Ensure you have more delegations and vote power than the data provider that has the lowest amount before the vote power block is chosen and before you submit the request to be relisted.","title":"Requesting to be Added to the Whitelist or Relisted"},{"location":"infra/data/whitelisting/#reading-whitelists","text":"Each FTSO contains an array of whitelisted addresses. Use the functions in the following contracts to determine whether you are on the list and eligible to submit data: VoterWhitelister contract The getFtsoWhitelistedPriceProviders function returns a list of addresses for all data providers on the whitelist. Specify the required index, run the query, and search for your address. PriceSubmitter contract The voterWhitelistBitmap function returns a bitmap corresponding to allowed FTSO indices in big-endian format. Specify your address, run the query and examine the returned bitmap. E.g., if you were allowed to submit prices for FTSOs with indices 0, 2 and 3, the returned bitmap would be 13 ( 1101 in binary).","title":"Reading Whitelists"},{"location":"infra/data/whitelisting/#monitoring-your-whitelist-status","text":"When you are added to a whitelist, the VoterWhitelisted event is emitted from the VoterWhitelister contract. When you are removed from a whitelist, the VoterRemovedFromWhitelist event is emitted, and your subsequent submissions fail. To stay aware of your whitelist status, consider listening to events that notify you about additions and removals when they happen.","title":"Monitoring Your Whitelist Status"},{"location":"infra/observation/","text":"Observer Nodes # Select one of the topics below: Deploying an Observer Node FAQ","title":"Observer Nodes"},{"location":"infra/observation/#observer-nodes","text":"Select one of the topics below: Deploying an Observer Node FAQ","title":"Observer Nodes"},{"location":"infra/observation/deploying/","text":"Deploying an Observer Node # Introduction # Observer nodes enable anyone to observe the network and submit transactions. Unlike validator nodes , which provide state consensus and add blocks, observer nodes remain outside the network and have no effect on consensus or blocks. Running an observer node is optional. However, submitting transactions through your own node offers a number of benefits: Transactions are sent directly to the network instead of through a third party, removing a potential security risk. Public nodes are usually rate-limited (the amount of requests they accept per second is restricted). Your own node does not have such restriction. The time savings described above allow FTSO data providers to submit their data a few seconds later, thus having more time to gather data before submitting. This guide explains how to deploy your own observer node so you can reap these benefits. Prerequisites # This guide contains different instructions depending on which Flare network you want to deploy to, so make sure you are aware of the available networks . Flare Songbird Coston Coston 2 Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 GB Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 GB Dependencies Go (>= 1.16.8) Disk space 3.5 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 GB Dependencies Go (>= 1.16.8) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 GB Dependencies Go (>= 1.18.5) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Plus a reliable IPv4 or IPv6 network connection, with an open public port. Keep in mind that enabling pruning as described below can reduce the required disk space by as much as 60%. Guide # 1. Installation # Flare & Coston 2 Songbird & Coston Clone the go-flare repository and run the build.sh script: git clone https://github.com/flare-foundation/go-flare.git cd go-flare/avalanchego ./scripts/build.sh The resulting executable will be build/avalanchego . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd ../coreth go test ./... # coreth unit tests cd ../avalanchego Clone the go-songbird repository and run the build.sh script: git clone https://github.com/flare-foundation/go-songbird.git cd go-songbird/avalanchego ./scripts/build.sh The resulting executable will be build/flare . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd coreth go test ./... # coreth unit tests cd .. 2. Songbird Node Whitelisting # While Songbird network is being tested, all nodes wanting to peer with it (including observer nodes) need to have their IP address whitelisted . To do this, please contact Tom T. over Discord ( Tom T#7603 ), Telegram ( @TampaBay7 ) or email ( tom@flare.network ) and request to be whitelisted. Checking the status of your Songbird whitelisting request curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info If your IP address is whitelisted, this command returns a JSON response. Otherwise you will get a 403 error (\"Forbidden\"). Please note that whitelisting is not needed on the Flare network or any of the Coston networks . 3. Run the Node # This is the minimum command to quickly get your node up and running. To understand each parameter read the following step before launching the node. Flare Songbird Coston Coston 2 ./build/avalanchego --network-id = flare --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = songbird --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = coston --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/avalanchego --network-id = costwo --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" After a lot of log messages the node should start synchronizing with the network, which might take a long time (currently about 4 hours for Flare, over a week for Songbird, depending on network speed and machine specs). You can stop the node at any time by pressing Ctrl-C . Use the same command line as before to restart the node. Synchronization will resume where it left if it is interrupted. You will know your node is fully booted and accepting transactions when the output of this command: curl http://127.0.0.1:9650/ext/health Contains the field \"healthy\":true in the returned JSON object. Note If the node gets stuck during bootstrap (it takes far longer than the estimates given above), try to add the parameter --bootstrap-retry-enabled=false . 4. Additional Configuration # These are some of the most relevant command line parameters you can use. You can read about all of them in the Avalanche documentation . --bootstrap-ips , --bootstrap-ids : IP address and node ID of the peer used to connect to the rest of the network for bootstrapping. You can use Flare's public nodes for this, as shown in the quick start command given above: Flare Songbird Coston Coston 2 Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.nodeID\" Remember that you need to whitelist your node's IP address or your queries will always be answered with 403 error codes. --http-host : Use --http-host= (empty) to allow connections from other machines. Otherwise, only connections from localhost are accepted. --http-port : The port through which the node will listen to API requests. The default value is 9650 . --staking-port : The port through which the network peers will connect to this node externally. Having this port accessible from the internet is required for correct node operation. The default value is 9651 . --db-dir : Directory where the database is stored. Make sure to use a disk with enough space as recommended in the Hardware prerequisites section. It defaults to ~/.avalanchego/db on Flare and Coston 2, and to ~/.flare/db on Songbird and Coston. You can use this option to store the database on an external drive, for example. --chain-config-dir : Optional JSON configuration file, in case you want to use lots of non-default values. Sample configuration file for observer nodes These are the most common configuration options. Put them in a file in the {chain-config-dir}/C/config.json folder. { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"eth-apis\" : [ \"public-eth\" , \"public-eth-filter\" , \"net\" , \"web3\" , \"internal-public-eth\" , \"internal-public-blockchain\" , \"internal-public-transaction-pool\" ], \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"pruning-enabled\" : true , \"local-txs-enabled\" : false , \"api-max-duration\" : 0 , \"api-max-blocks-per-request\" : 0 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"remote-tx-gossip-only-enabled\" : false , \"log-level\" : \"info\" } Archival nodes : An archival node keeps the whole history of the blockchain, instead of pruning old transactions which is the default setting. Use the pruning-enabled configuration setting to control whether your node performs pruning or not. Archival nodes have significantly increased disk requirements.","title":"Deploying an Observer Node"},{"location":"infra/observation/deploying/#deploying-an-observer-node","text":"","title":"Deploying an Observer Node"},{"location":"infra/observation/deploying/#introduction","text":"Observer nodes enable anyone to observe the network and submit transactions. Unlike validator nodes , which provide state consensus and add blocks, observer nodes remain outside the network and have no effect on consensus or blocks. Running an observer node is optional. However, submitting transactions through your own node offers a number of benefits: Transactions are sent directly to the network instead of through a third party, removing a potential security risk. Public nodes are usually rate-limited (the amount of requests they accept per second is restricted). Your own node does not have such restriction. The time savings described above allow FTSO data providers to submit their data a few seconds later, thus having more time to gather data before submitting. This guide explains how to deploy your own observer node so you can reap these benefits.","title":"Introduction"},{"location":"infra/observation/deploying/#prerequisites","text":"This guide contains different instructions depending on which Flare network you want to deploy to, so make sure you are aware of the available networks . Flare Songbird Coston Coston 2 Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 GB Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 8 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 32 GB Dependencies Go (>= 1.16.8) Disk space 3.5 TB SSD gcc Disk growth 2.5 TB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 GB Dependencies Go (>= 1.16.8) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Hardware Software CPU cores 4 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 16 GB Dependencies Go (>= 1.18.5) Disk space 500 GB SSD gcc Disk growth 250 GB/year g++ jq Plus a reliable IPv4 or IPv6 network connection, with an open public port. Keep in mind that enabling pruning as described below can reduce the required disk space by as much as 60%.","title":"Prerequisites"},{"location":"infra/observation/deploying/#guide","text":"","title":"Guide"},{"location":"infra/observation/deploying/#1-installation","text":"Flare & Coston 2 Songbird & Coston Clone the go-flare repository and run the build.sh script: git clone https://github.com/flare-foundation/go-flare.git cd go-flare/avalanchego ./scripts/build.sh The resulting executable will be build/avalanchego . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd ../coreth go test ./... # coreth unit tests cd ../avalanchego Clone the go-songbird repository and run the build.sh script: git clone https://github.com/flare-foundation/go-songbird.git cd go-songbird/avalanchego ./scripts/build.sh The resulting executable will be build/flare . Note You can verify the installation by running: go test $( go list ./... | grep -v /tests/ ) # avalanchego unit tests cd coreth go test ./... # coreth unit tests cd ..","title":"1. Installation"},{"location":"infra/observation/deploying/#2-songbird-node-whitelisting","text":"While Songbird network is being tested, all nodes wanting to peer with it (including observer nodes) need to have their IP address whitelisted . To do this, please contact Tom T. over Discord ( Tom T#7603 ), Telegram ( @TampaBay7 ) or email ( tom@flare.network ) and request to be whitelisted. Checking the status of your Songbird whitelisting request curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info If your IP address is whitelisted, this command returns a JSON response. Otherwise you will get a 403 error (\"Forbidden\"). Please note that whitelisting is not needed on the Flare network or any of the Coston networks .","title":"2. Songbird Node Whitelisting"},{"location":"infra/observation/deploying/#3-run-the-node","text":"This is the minimum command to quickly get your node up and running. To understand each parameter read the following step before launching the node. Flare Songbird Coston Coston 2 ./build/avalanchego --network-id = flare --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://flare.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = songbird --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://songbird.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/flare --network-id = coston --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" ./build/avalanchego --network-id = costwo --http-host = \\ --bootstrap-ips = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.ip\" ) \" \\ --bootstrap-ids = \" $( curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' https://coston2.flare.network/ext/info \\ | jq -r \".result.nodeID\" ) \" After a lot of log messages the node should start synchronizing with the network, which might take a long time (currently about 4 hours for Flare, over a week for Songbird, depending on network speed and machine specs). You can stop the node at any time by pressing Ctrl-C . Use the same command line as before to restart the node. Synchronization will resume where it left if it is interrupted. You will know your node is fully booted and accepting transactions when the output of this command: curl http://127.0.0.1:9650/ext/health Contains the field \"healthy\":true in the returned JSON object. Note If the node gets stuck during bootstrap (it takes far longer than the estimates given above), try to add the parameter --bootstrap-retry-enabled=false .","title":"3. Run the Node"},{"location":"infra/observation/deploying/#4-additional-configuration","text":"These are some of the most relevant command line parameters you can use. You can read about all of them in the Avalanche documentation . --bootstrap-ips , --bootstrap-ids : IP address and node ID of the peer used to connect to the rest of the network for bootstrapping. You can use Flare's public nodes for this, as shown in the quick start command given above: Flare Songbird Coston Coston 2 Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://flare.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://songbird.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston.flare.network/ext/info | jq -r \".result.nodeID\" Peer's IP address: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeIP\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.ip\" Peer's node ID: curl -m 10 -sX POST \\ --data '{ \"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"info.getNodeID\" }' \\ -H 'content-type:application/json;' \\ https://coston2.flare.network/ext/info | jq -r \".result.nodeID\" Remember that you need to whitelist your node's IP address or your queries will always be answered with 403 error codes. --http-host : Use --http-host= (empty) to allow connections from other machines. Otherwise, only connections from localhost are accepted. --http-port : The port through which the node will listen to API requests. The default value is 9650 . --staking-port : The port through which the network peers will connect to this node externally. Having this port accessible from the internet is required for correct node operation. The default value is 9651 . --db-dir : Directory where the database is stored. Make sure to use a disk with enough space as recommended in the Hardware prerequisites section. It defaults to ~/.avalanchego/db on Flare and Coston 2, and to ~/.flare/db on Songbird and Coston. You can use this option to store the database on an external drive, for example. --chain-config-dir : Optional JSON configuration file, in case you want to use lots of non-default values. Sample configuration file for observer nodes These are the most common configuration options. Put them in a file in the {chain-config-dir}/C/config.json folder. { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"eth-apis\" : [ \"public-eth\" , \"public-eth-filter\" , \"net\" , \"web3\" , \"internal-public-eth\" , \"internal-public-blockchain\" , \"internal-public-transaction-pool\" ], \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"pruning-enabled\" : true , \"local-txs-enabled\" : false , \"api-max-duration\" : 0 , \"api-max-blocks-per-request\" : 0 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"remote-tx-gossip-only-enabled\" : false , \"log-level\" : \"info\" } Archival nodes : An archival node keeps the whole history of the blockchain, instead of pruning old transactions which is the default setting. Use the pruning-enabled configuration setting to control whether your node performs pruning or not. Archival nodes have significantly increased disk requirements.","title":"4. Additional Configuration"},{"location":"infra/observation/faq/","text":"FAQ # Do I need to re-whitelist my peering node IP? # No, you do not need to re-whitelist the IP address. I want to have greater redundancy and would like to whitelist multiple nodes, can I do that? # Yes, you can whitelist multiple IPs per single provider. Can an unhealthy node cause my transactions to revert? # Yes, at times, not enough connected peers can cause your transactions to revert. Make sure your node state is healthy and that it has enough connected peers. How do I check the number of connected peers? # curl http://127.0.0.1:9650/ext/health | jq And look for the line containing connectedPeers . If you want to automate the process you can use: curl -s http://127.0.0.1:9650/ext/health | \\ jq -r \".checks.network.message.connectedPeers\" What is the required number of connected peers? # If the number of peers falls below 16, chances are your node will not work correctly. While the network is being decentralized, any number below 20 is indication of a problem. In any case, try restarting the node. The node does not sync after a long time and dies abruptly, what should I do? # Make sure, that the database location has sufficient disk space (database size might change a lot during bootstrapping). I am getting strange errors on submission and revert messages are cryptic # This might be a symptom of a node connection error. Try to restart the node and make sure you have enough disk space. I am getting a strange error related to GetAcceptedFrontier during bootstrapping # failed to send GetAcceptedFrontier(MtF8bVH241hetCQJgsKEdKyJBs8vhp1BC, 11111111111111111111111111111111LpoYY, NUMBER) It looks like your node got disconnected during bootstrapping. Try restarting the node. I have synced the node but it does not become healthy. What can I do? # It often happens that a new node gets synced but stays unhealthy for no apparent reason. A restart usually helps.","title":"FAQ"},{"location":"infra/observation/faq/#faq","text":"","title":"FAQ"},{"location":"infra/observation/faq/#do-i-need-to-re-whitelist-my-peering-node-ip","text":"No, you do not need to re-whitelist the IP address.","title":"Do I need to re-whitelist my peering node IP?"},{"location":"infra/observation/faq/#i-want-to-have-greater-redundancy-and-would-like-to-whitelist-multiple-nodes-can-i-do-that","text":"Yes, you can whitelist multiple IPs per single provider.","title":"I want to have greater redundancy and would like to whitelist multiple nodes, can I do that?"},{"location":"infra/observation/faq/#can-an-unhealthy-node-cause-my-transactions-to-revert","text":"Yes, at times, not enough connected peers can cause your transactions to revert. Make sure your node state is healthy and that it has enough connected peers.","title":"Can an unhealthy node cause my transactions to revert?"},{"location":"infra/observation/faq/#how-do-i-check-the-number-of-connected-peers","text":"curl http://127.0.0.1:9650/ext/health | jq And look for the line containing connectedPeers . If you want to automate the process you can use: curl -s http://127.0.0.1:9650/ext/health | \\ jq -r \".checks.network.message.connectedPeers\"","title":"How do I check the number of connected peers?"},{"location":"infra/observation/faq/#what-is-the-required-number-of-connected-peers","text":"If the number of peers falls below 16, chances are your node will not work correctly. While the network is being decentralized, any number below 20 is indication of a problem. In any case, try restarting the node.","title":"What is the required number of connected peers?"},{"location":"infra/observation/faq/#the-node-does-not-sync-after-a-long-time-and-dies-abruptly-what-should-i-do","text":"Make sure, that the database location has sufficient disk space (database size might change a lot during bootstrapping).","title":"The node does not sync after a long time and dies abruptly, what should I do?"},{"location":"infra/observation/faq/#i-am-getting-strange-errors-on-submission-and-revert-messages-are-cryptic","text":"This might be a symptom of a node connection error. Try to restart the node and make sure you have enough disk space.","title":"I am getting strange errors on submission and revert messages are cryptic"},{"location":"infra/observation/faq/#i-am-getting-a-strange-error-related-to-getacceptedfrontier-during-bootstrapping","text":"failed to send GetAcceptedFrontier(MtF8bVH241hetCQJgsKEdKyJBs8vhp1BC, 11111111111111111111111111111111LpoYY, NUMBER) It looks like your node got disconnected during bootstrapping. Try restarting the node.","title":"I am getting a strange error related to GetAcceptedFrontier during bootstrapping"},{"location":"infra/observation/faq/#i-have-synced-the-node-but-it-does-not-become-healthy-what-can-i-do","text":"It often happens that a new node gets synced but stays unhealthy for no apparent reason. A restart usually helps.","title":"I have synced the node but it does not become healthy. What can I do?"},{"location":"infra/validation/","text":"Validator Nodes # Select the topic below: Deploying a Validator Node","title":"Validator Nodes"},{"location":"infra/validation/#validator-nodes","text":"Select the topic below: Deploying a Validator Node","title":"Validator Nodes"},{"location":"infra/validation/deploying/","text":"Deploying a Validator Node # Introduction # As explained in the Validator Nodes page, these servers fulfill a critical role in securing the network: They check that all received transactions are valid. They run a consensus algorithm so that all validators in the network agree on the transactions to add to the blockchain. Finally, they add the agreed-upon transactions to their copy of the ledger . Additionally, all blockchains must employ measures against Sybil attacks and the Flare network is planning two such measures: Validators will need to stake native tokens, just like in regular Proof of Stake . Validators will also need to be FTSO Data Providers , and their performance in this role will have an impact on their validation rewards, leading to a meritocratic system. However, given the importance of the validator role and the novelty of the meritocratic approach, these measures are being implemented in phases: Implementation phases Phase 0 : Only validators with preregistered keys can be deployed. Some users will receive preregistered validator keys , this is, the keys required to launch a node which has already been registered as a validator . This is the only way to deploy a validator node during this phase. Phase 1 : Candidate FTSO validators. FTSO data providers that wish to become validators need to undergo a KYC process (Contact Tom T. over Discord ( Tom T#7603 ), Telegram ( @TampaBay7 ) or email ) and operate an Observer node . Random security scans will be performed on the node, and if all of them are successful (see Mandatory security measures below) validator rewards will be accrued. Validator rewards are split evenly among all candidate validators that passed the security scans. More phases will be added as the process is refined. Information affecting only specific phases is indicated in this guide with colored boxes like this one. This guide explains how to deploy your own validator node so you can participate in the consensus and collect the rewards that the network provides to those who help secure it. The following instructions apply to the Flare network only. Prerequisites # Validators run the same software as regular observer nodes , therefore, this guide assumes you have already read the Deploying an Observer Node guide. The requirements to deploy a validator node are the same as for observer nodes, except on the CPU and RAM front which are heavier due to the extra work required: Hardware Software CPU cores 16 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 64 GB Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq npm (>= 8.11) Guide # 1. Configure the Node # A validator node is deployed like an observer node, but there are some additional considerations. Firstly, validators do more work than plain observer nodes so please consider the recommended hardware specifications above. And secondly, validator security impacts the whole network. Please consider the following items carefully: Mandatory security measures # Ensure port 9650 is not externally reachable. This is the port used to answer API requests and validators should not be doing that. Disallow password authentication over SSH. Don't run any non-validator services on the same IP (website, mail server, etc). Warning A monitoring tool run by Flare periodically checks that the above measures are followed by all validators. Failure to comply impacts the validator's rewards. Phase 1 exemption To ease the deployment of candidate validators during phase 1 port 9650, used to answer API requests, might be left open. This allows running the candidate validator on the same machine currently running the observer node used to submit FTSO data. Suggested security measures # Disallow any ICMP traffic. Have the machine firewalled . Only the ports required for validator operation should be open (i.e. only the staking port, which defaults to 9651). If you use a virtual server, use only its web interface for management and close the SSH port. If the SSH port must be open, it should ideally be restricted to a private IP (i.e. only accessible through VPN) or only temporarily open to the operator's office/home static IP or a bastion SSH VM that can be turned off between use. The node should only act as a validator , and not accept RPC API calls. You should deploy a separate observer node for tasks requiring RPC API access. Additionally, this observer node can point to your validator for peering and bootstrapping. The validator should only enable the minimum set of EVM APIs by adding this line to a configuration file : \"eth-apis\" : [ \"web3\" ] Sample configuration file for validator nodes { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"coreth-admin-api-dir\" : \"\" , \"eth-apis\" : [ \"web3\" ], \"continuous-profiler-dir\" : \"\" , \"continuous-profiler-frequency\" : 900000000000 , \"continuous-profiler-max-files\" : 5 , \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"preimages-enabled\" : false , \"pruning-enabled\" : false , \"snapshot-async\" : true , \"snapshot-verification-enabled\" : false , \"metrics-enabled\" : true , \"metrics-expensive-enabled\" : false , \"local-txs-enabled\" : false , \"api-max-duration\" : 30000000000 , \"ws-cpu-refill-rate\" : 0 , \"ws-cpu-max-stored\" : 0 , \"api-max-blocks-per-request\" : 30 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"keystore-directory\" : \"\" , \"keystore-external-signer\" : \"\" , \"keystore-insecure-unlock-allowed\" : false , \"remote-tx-gossip-only-enabled\" : false , \"tx-regossip-frequency\" : 60000000000 , \"tx-regossip-max-size\" : 15 , \"log-level\" : \"info\" , \"offline-pruning-enabled\" : false , \"offline-pruning-bloom-filter-size\" : 512 , \"offline-pruning-data-directory\" : \"\" } 2. Run the Node # After taking the above considerations into account, you can now start up your node by following the Deploying an Observation Node guide. Preregistered validator keys Some users have received preregistered validator keys , this is, the keys required to deploy a node which has already been registered as a validator. If that is your case, you just need to add these parameters to the launch command line, and jump to step 6. --staking-tls-cert-file = <NODE_CRT_PATH> \\ --staking-tls-key-file = <NODE_KEY_PATH>","title":"Deploying a Validator Node"},{"location":"infra/validation/deploying/#deploying-a-validator-node","text":"","title":"Deploying a Validator Node"},{"location":"infra/validation/deploying/#introduction","text":"As explained in the Validator Nodes page, these servers fulfill a critical role in securing the network: They check that all received transactions are valid. They run a consensus algorithm so that all validators in the network agree on the transactions to add to the blockchain. Finally, they add the agreed-upon transactions to their copy of the ledger . Additionally, all blockchains must employ measures against Sybil attacks and the Flare network is planning two such measures: Validators will need to stake native tokens, just like in regular Proof of Stake . Validators will also need to be FTSO Data Providers , and their performance in this role will have an impact on their validation rewards, leading to a meritocratic system. However, given the importance of the validator role and the novelty of the meritocratic approach, these measures are being implemented in phases: Implementation phases Phase 0 : Only validators with preregistered keys can be deployed. Some users will receive preregistered validator keys , this is, the keys required to launch a node which has already been registered as a validator . This is the only way to deploy a validator node during this phase. Phase 1 : Candidate FTSO validators. FTSO data providers that wish to become validators need to undergo a KYC process (Contact Tom T. over Discord ( Tom T#7603 ), Telegram ( @TampaBay7 ) or email ) and operate an Observer node . Random security scans will be performed on the node, and if all of them are successful (see Mandatory security measures below) validator rewards will be accrued. Validator rewards are split evenly among all candidate validators that passed the security scans. More phases will be added as the process is refined. Information affecting only specific phases is indicated in this guide with colored boxes like this one. This guide explains how to deploy your own validator node so you can participate in the consensus and collect the rewards that the network provides to those who help secure it. The following instructions apply to the Flare network only.","title":"Introduction"},{"location":"infra/validation/deploying/#prerequisites","text":"Validators run the same software as regular observer nodes , therefore, this guide assumes you have already read the Deploying an Observer Node guide. The requirements to deploy a validator node are the same as for observer nodes, except on the CPU and RAM front which are heavier due to the extra work required: Hardware Software CPU cores 16 Operating System Ubuntu (18.04 or 20.04) or macOS (>= 10.15 Catalina) RAM 64 GB Dependencies Go (>= 1.18.5) Disk space 1 TB SSD gcc Disk growth 2.5 TB/year g++ jq npm (>= 8.11)","title":"Prerequisites"},{"location":"infra/validation/deploying/#guide","text":"","title":"Guide"},{"location":"infra/validation/deploying/#1-configure-the-node","text":"A validator node is deployed like an observer node, but there are some additional considerations. Firstly, validators do more work than plain observer nodes so please consider the recommended hardware specifications above. And secondly, validator security impacts the whole network. Please consider the following items carefully:","title":"1. Configure the Node"},{"location":"infra/validation/deploying/#mandatory-security-measures","text":"Ensure port 9650 is not externally reachable. This is the port used to answer API requests and validators should not be doing that. Disallow password authentication over SSH. Don't run any non-validator services on the same IP (website, mail server, etc). Warning A monitoring tool run by Flare periodically checks that the above measures are followed by all validators. Failure to comply impacts the validator's rewards. Phase 1 exemption To ease the deployment of candidate validators during phase 1 port 9650, used to answer API requests, might be left open. This allows running the candidate validator on the same machine currently running the observer node used to submit FTSO data.","title":"Mandatory security measures"},{"location":"infra/validation/deploying/#suggested-security-measures","text":"Disallow any ICMP traffic. Have the machine firewalled . Only the ports required for validator operation should be open (i.e. only the staking port, which defaults to 9651). If you use a virtual server, use only its web interface for management and close the SSH port. If the SSH port must be open, it should ideally be restricted to a private IP (i.e. only accessible through VPN) or only temporarily open to the operator's office/home static IP or a bastion SSH VM that can be turned off between use. The node should only act as a validator , and not accept RPC API calls. You should deploy a separate observer node for tasks requiring RPC API access. Additionally, this observer node can point to your validator for peering and bootstrapping. The validator should only enable the minimum set of EVM APIs by adding this line to a configuration file : \"eth-apis\" : [ \"web3\" ] Sample configuration file for validator nodes { \"snowman-api-enabled\" : false , \"coreth-admin-api-enabled\" : false , \"coreth-admin-api-dir\" : \"\" , \"eth-apis\" : [ \"web3\" ], \"continuous-profiler-dir\" : \"\" , \"continuous-profiler-frequency\" : 900000000000 , \"continuous-profiler-max-files\" : 5 , \"rpc-gas-cap\" : 50000000 , \"rpc-tx-fee-cap\" : 100 , \"preimages-enabled\" : false , \"pruning-enabled\" : false , \"snapshot-async\" : true , \"snapshot-verification-enabled\" : false , \"metrics-enabled\" : true , \"metrics-expensive-enabled\" : false , \"local-txs-enabled\" : false , \"api-max-duration\" : 30000000000 , \"ws-cpu-refill-rate\" : 0 , \"ws-cpu-max-stored\" : 0 , \"api-max-blocks-per-request\" : 30 , \"allow-unfinalized-queries\" : false , \"allow-unprotected-txs\" : false , \"keystore-directory\" : \"\" , \"keystore-external-signer\" : \"\" , \"keystore-insecure-unlock-allowed\" : false , \"remote-tx-gossip-only-enabled\" : false , \"tx-regossip-frequency\" : 60000000000 , \"tx-regossip-max-size\" : 15 , \"log-level\" : \"info\" , \"offline-pruning-enabled\" : false , \"offline-pruning-bloom-filter-size\" : 512 , \"offline-pruning-data-directory\" : \"\" }","title":"Suggested security measures"},{"location":"infra/validation/deploying/#2-run-the-node","text":"After taking the above considerations into account, you can now start up your node by following the Deploying an Observation Node guide. Preregistered validator keys Some users have received preregistered validator keys , this is, the keys required to deploy a node which has already been registered as a validator. If that is your case, you just need to add these parameters to the launch command line, and jump to step 6. --staking-tls-cert-file = <NODE_CRT_PATH> \\ --staking-tls-key-file = <NODE_KEY_PATH>","title":"2. Run the Node"},{"location":"tech/","text":"Flare Fundamentals # This section contains in-depth descriptions of Flare's key concepts, technology and tools. Select one of the topics below: What is Flare Automatic Claiming The FlareDrop Flare Launch Process Flare API Portal FTSO Governance Personal Delegation Accounts State Connector Tokenomics Validator Nodes Glossary","title":"Flare Fundamentals"},{"location":"tech/#flare-fundamentals","text":"This section contains in-depth descriptions of Flare's key concepts, technology and tools. Select one of the topics below: What is Flare Automatic Claiming The FlareDrop Flare Launch Process Flare API Portal FTSO Governance Personal Delegation Accounts State Connector Tokenomics Validator Nodes Glossary","title":"Flare Fundamentals"},{"location":"tech/api-portal/","text":"Flare API Portal # Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchains, including Flare, Songbird and Coston , but also other networks like Bitcoin or XRPL. These nodes are not rate-limited , so it is typically more convenient to connect your apps to them than to deploy your own nodes, or connect to public nodes. This is one more step towards Flare's goal to connect all blockchains . Visit Flare's API Portal website Visit the API Portal's FAQ if you are having authentication issues!","title":"Flare API Portal"},{"location":"tech/api-portal/#flare-api-portal","text":"Flare's API Portal is a paid product that gives developers access to a number of private nodes running on different blockchains, including Flare, Songbird and Coston , but also other networks like Bitcoin or XRPL. These nodes are not rate-limited , so it is typically more convenient to connect your apps to them than to deploy your own nodes, or connect to public nodes. This is one more step towards Flare's goal to connect all blockchains . Visit Flare's API Portal website Visit the API Portal's FAQ if you are having authentication issues!","title":"Flare API Portal"},{"location":"tech/automatic-claiming/","text":"Automatic Claiming # Automatic claiming enables users to appoint an executor to claim rewards on their behalf. Info This feature is only available on the Flare network. Introduction # The Flare network rewards users that contribute to it, for example, by delegating to an FTSO data provider . Delegation rewards accrue every 3.5 days when users have delegated wrapped Flare tokens (WFLR) to FTSO data providers. These rewards must be claimed periodically by users, since rewards expire after a few months. For users, claiming rewards can be inconvenient and can risk losing rewards and compound interest if overlooked. If users are claiming rewards from a cold wallet, they can expose the wallet more often than necessary. Instead, users can enlist the services of executors to claim for them, putting the responsibility of remembering to claim on the executor. Automatic claiming through an executor saves user time and inconvenience, optimizes the opportunity for compound interest, and avoids unnecessary exposure of users' cold wallets. Automatic claiming is secure because the executor cannot claim to any address but the ones the user provides. It is trustless (does not require trust) because it is managed by a smart contract, not the executor. For executors, automatic claiming is an opportunity to earn a fee for performing claiming as a service to users. How Automatic Claiming Works # Without an executor, users need to claim twice a week if they want to benefit from the rewards as soon as possible. The claiming process without an executor. With an executor, a third party can claim for users, for an optional fee. The claiming process with an executor. There are two ways to claim with an executor: manual and registered. They both provide \"automatic claiming\" for the user in the sense that claiming rewards requires no intervention from the user once the executor takes over. However, when the executor does not register, several parts of the process are not automated, such as finding each other and paying the fee. The \"manual\" version is less automated. The registered version is highly automated. Manual Claiming Process # If an executor account is not registered, claiming is said to be Manual . With Manual claiming users only need to provide the executor's address, which authorizes the executor to claim on the user's behalf. How the user discovers the executor's address and whether they will pay a service fee can only be settled off-chain. Example For example, executors could create a dapp where users pay a fee (in fiat or spot) and sign the transaction that sets the executor's address. Only reward claiming remains automated, whereby rewards are sent directly to the user's address. Executors do not receive a fee automatically. Here is how the process works when executor claiming is manual: Users who have accrued rewards and want an executor to claim on their behalf can identify an executor known to them off-chain. These users then make an off-chain agreement with the executor and they exchange addresses. Agreeing to a fee is optional and off-chain. If they do agree to a fee, they pay manually. Executors claim rewards for one or more users. Their fees are not automatically deducted from the claimed rewards. Executors notify users off-chain if they discontinue providing this service. Registered Claiming Process # On the other hand, the process can be simplified if the executor address is Registered . Registration allows accounts to list themselves on-chain as registered executors and post their service fees. Registration simplifies both the user task of finding a suitable executor and the executor's task, since its fee is automatically transferred when user rewards are claimed. The users pay a fee to set an executor to claim their rewards and their rewards are claimed automatically, i.e., without their intervention. With a registered executor, all agreements happen on-chain. Here is how the registered claiming process works, with applications performing these actions on behalf of executors and users: Executors who want to make themselves publicly available to users register as executors, paying a registration fee. The fee to register as an executor is burned. Registered executors post their fee for claiming rewards. Users who have accrued rewards and want an executor to claim on their behalf can choose from the list of registered executors. These users pay a setup fee to enable a registered executor to claim their rewards. The fee to enable a registered executor is sent to the executor. Executors claim rewards for one or more users, and their fees are automatically deducted from the claimed rewards. Executors notify users off-chain if they discontinue providing this service. Throughout the process: Users and executors can see reports on which addresses executors are claiming for and which executors are registered. Registered executors can change fees or unregister, and users can change the registered executors claiming on their behalf or disable automatic claiming. Other Use Cases # Cold Wallets # Many users claim from a cold wallet because they can reap the most rewards where they store the greatest share of their holdings. When they claim from a cold wallet, they are exposing it online. Setting an executor can protect the cold wallet, as the executor would claim the rewards and pass them on to the user's account automatically without putting the cold wallet online. Your Own Executor # If a user has multiple addresses, it may be convenient to designate one of their own addresses as an executor, and claim for all of them from it. Additionally, this avoids the fee that a public executor will typically charge. Warning By using the automatic claiming feature, neither Flare Foundation nor any of the contracts published on the Flare network guarantee that the selected executor will actually claim any or all of the user\u2019s rewards. This agreement is solely between the user and the selected executor. The Flare network offers only the possibility of setting up an automatic execution service and is not liable for any damages if this service is not performed. For more information, see FLARE TERMS OF SERVICE & PRIVACY POLICY . Developing autoclaiming functionality For information on how to develop an executor, or how to write an application that supports autoclaiming, see Automatic Claiming in the Developer section. Related User Guides # Automatic claiming Related Developer Docs # Automatic claiming","title":"Automatic Claiming"},{"location":"tech/automatic-claiming/#automatic-claiming","text":"Automatic claiming enables users to appoint an executor to claim rewards on their behalf. Info This feature is only available on the Flare network.","title":"Automatic Claiming"},{"location":"tech/automatic-claiming/#introduction","text":"The Flare network rewards users that contribute to it, for example, by delegating to an FTSO data provider . Delegation rewards accrue every 3.5 days when users have delegated wrapped Flare tokens (WFLR) to FTSO data providers. These rewards must be claimed periodically by users, since rewards expire after a few months. For users, claiming rewards can be inconvenient and can risk losing rewards and compound interest if overlooked. If users are claiming rewards from a cold wallet, they can expose the wallet more often than necessary. Instead, users can enlist the services of executors to claim for them, putting the responsibility of remembering to claim on the executor. Automatic claiming through an executor saves user time and inconvenience, optimizes the opportunity for compound interest, and avoids unnecessary exposure of users' cold wallets. Automatic claiming is secure because the executor cannot claim to any address but the ones the user provides. It is trustless (does not require trust) because it is managed by a smart contract, not the executor. For executors, automatic claiming is an opportunity to earn a fee for performing claiming as a service to users.","title":"Introduction"},{"location":"tech/automatic-claiming/#how-automatic-claiming-works","text":"Without an executor, users need to claim twice a week if they want to benefit from the rewards as soon as possible. The claiming process without an executor. With an executor, a third party can claim for users, for an optional fee. The claiming process with an executor. There are two ways to claim with an executor: manual and registered. They both provide \"automatic claiming\" for the user in the sense that claiming rewards requires no intervention from the user once the executor takes over. However, when the executor does not register, several parts of the process are not automated, such as finding each other and paying the fee. The \"manual\" version is less automated. The registered version is highly automated.","title":"How Automatic Claiming Works"},{"location":"tech/automatic-claiming/#manual-claiming-process","text":"If an executor account is not registered, claiming is said to be Manual . With Manual claiming users only need to provide the executor's address, which authorizes the executor to claim on the user's behalf. How the user discovers the executor's address and whether they will pay a service fee can only be settled off-chain. Example For example, executors could create a dapp where users pay a fee (in fiat or spot) and sign the transaction that sets the executor's address. Only reward claiming remains automated, whereby rewards are sent directly to the user's address. Executors do not receive a fee automatically. Here is how the process works when executor claiming is manual: Users who have accrued rewards and want an executor to claim on their behalf can identify an executor known to them off-chain. These users then make an off-chain agreement with the executor and they exchange addresses. Agreeing to a fee is optional and off-chain. If they do agree to a fee, they pay manually. Executors claim rewards for one or more users. Their fees are not automatically deducted from the claimed rewards. Executors notify users off-chain if they discontinue providing this service.","title":"Manual Claiming Process"},{"location":"tech/automatic-claiming/#registered-claiming-process","text":"On the other hand, the process can be simplified if the executor address is Registered . Registration allows accounts to list themselves on-chain as registered executors and post their service fees. Registration simplifies both the user task of finding a suitable executor and the executor's task, since its fee is automatically transferred when user rewards are claimed. The users pay a fee to set an executor to claim their rewards and their rewards are claimed automatically, i.e., without their intervention. With a registered executor, all agreements happen on-chain. Here is how the registered claiming process works, with applications performing these actions on behalf of executors and users: Executors who want to make themselves publicly available to users register as executors, paying a registration fee. The fee to register as an executor is burned. Registered executors post their fee for claiming rewards. Users who have accrued rewards and want an executor to claim on their behalf can choose from the list of registered executors. These users pay a setup fee to enable a registered executor to claim their rewards. The fee to enable a registered executor is sent to the executor. Executors claim rewards for one or more users, and their fees are automatically deducted from the claimed rewards. Executors notify users off-chain if they discontinue providing this service. Throughout the process: Users and executors can see reports on which addresses executors are claiming for and which executors are registered. Registered executors can change fees or unregister, and users can change the registered executors claiming on their behalf or disable automatic claiming.","title":"Registered Claiming Process"},{"location":"tech/automatic-claiming/#other-use-cases","text":"","title":"Other Use Cases"},{"location":"tech/automatic-claiming/#cold-wallets","text":"Many users claim from a cold wallet because they can reap the most rewards where they store the greatest share of their holdings. When they claim from a cold wallet, they are exposing it online. Setting an executor can protect the cold wallet, as the executor would claim the rewards and pass them on to the user's account automatically without putting the cold wallet online.","title":"Cold Wallets"},{"location":"tech/automatic-claiming/#your-own-executor","text":"If a user has multiple addresses, it may be convenient to designate one of their own addresses as an executor, and claim for all of them from it. Additionally, this avoids the fee that a public executor will typically charge. Warning By using the automatic claiming feature, neither Flare Foundation nor any of the contracts published on the Flare network guarantee that the selected executor will actually claim any or all of the user\u2019s rewards. This agreement is solely between the user and the selected executor. The Flare network offers only the possibility of setting up an automatic execution service and is not liable for any damages if this service is not performed. For more information, see FLARE TERMS OF SERVICE & PRIVACY POLICY . Developing autoclaiming functionality For information on how to develop an executor, or how to write an application that supports autoclaiming, see Automatic Claiming in the Developer section.","title":"Your Own Executor"},{"location":"tech/automatic-claiming/#related-user-guides","text":"Automatic claiming","title":"Related User Guides"},{"location":"tech/automatic-claiming/#related-developer-docs","text":"Automatic claiming","title":"Related Developer Docs"},{"location":"tech/flare-launch-process/","text":"Flare Launch Process # The Flare launch is delicate, as it involves a rather large airdrop , a community vote , and the deployment of a novel meritocratic consensus system. For this reason, it has been divided into a series of sequential phases with clearly-defined triggers that signal each transition. The main goal of this page is to remove any confusion around the launch process by clearly describing the purpose of each phase and what happens in them. The secondary goal is to serve as a real-time tracker of the current phase . Without further ado: Click on a phase to navigate to its description. Definitions # Some definitions are required so the rest of the page is clear and unambiguous. FIP.01 : A governance proposal that, among other things, changes the initial token distributions as explained below. This proposal needs to be voted on according to the schedule described in this page. Flare Airdrop for XRP Holders : Certain holders of XRP tokens on Dec 12, 2020, were eligible to register for the FLR token distribution (then called Spark tokens) once the Flare network launched. The claiming process is described in this (slightly outdated) Flare blog post . The FIP.01 proposal modifies the way in which the airdrop works. Original Airdrop : 28.53B FLR tokens, which in the original distribution plan went to those who registered for the distribution. New Airdrop : 4.28B FLR tokens destined for those that registered for the distribution. Delegation Incentive Pool (DIP) : 24.25B FLR tokens destined for any Flare holder that participates in the network over 36 months as per the FIP.01 distribution plan. Note that the New Airdrop plus the DIP match the Original Airdrop. Token Distribution Event (TDE) : The moment when the initial FLR tokens are distributed to those that registered for the FLR token distribution. These tokens were minted and locked when the network was created and will be released when it is sufficiently decentralized. Token Distribution Plans # It is worth summarizing the two current token distribution plans, as only one of them will be implemented depending on whether FIP.01 is approved or not. Original Distribution Plan : 15% of the original airdrop is sent to those that registered for the FLR distribution upon the TDE, with the rest delivered monthly over the following 36 months. Inflation is 10% of the fully diluted supply, per annum. FIP.01 Distribution Plan : The new airdrop is sent to those that registered for the FLR distribution upon the TDE, the DIP will be distributed to ALL FLR token holders (actually, wrapped FLR holders) over 36 months (Flare employees and companies excluded). Inflation is 10% of available supply in the first year, then 7% the following year, 5% the year after and in perpetuity, except that from year 3 onwards inflation is capped at 5bn FLR per year. Inflation distribution: 70% to FTSO rewards, 20% to validator rewards and 10% to the default Attestation Provider Set of the state connector . Flare Beta # Decentralization will be achieved by moving the transaction validation duty from the Flare Foundation to community-run FTSO data providers , but this will not happen instantly. Instead, in order to ensure a safe transition, a number of professional validators will be initially employed. The professional validators will be chosen among companies with proven experience running blockchain infrastructure, and will at first hold most of the validation power . This power, though, will be progressively shifted onto the community-run validators until they run the network on their own. This initial period is called Flare Beta , and it will span several launch phases (marked in blue in the diagram above). Flare Beta Details # During this period: There are 22 total validators with equal validation power (20K FLR each, initially). 4 run by the Flare Foundation. 16 run by 4 professional validators. 2 \"virtual validators\" collectively run by ALL FTSO data providers together. FTSO data providers have their initial validation power artificially reduced so that all of them combined have the power of two validators (i.e. 40K FLR tokens). Validator rewards (20% of inflation) are split 50% for the professional validators and 50% for the FTSO data providers. The validation power for each FTSO validator will be calculated monthly by an external script (public, auditable and based on on-chain data) and shared among all validators. Each FTSO's share of validation power will depend on its FTSO performance and its own stake, as is done with the voting power used in the normal FTSO operation . The total validation power allocated for FTSO will start at 40K FLR but will gradually increase until it matches the real stake each FTSO has (including delegations). Validation rewards for FTSOs will increase accordingly as their collective validation power increases. Estimated duration: 6-9 months, depending on the evolution of the network. Launch Phases # Private Observation Mode # Trigger: The Flare network Launches On July 14th 2022 the network started centralized, with only 21 validators, run by the Flare Foundation. Flare validator source code is not available yet. FTSO data providers: Can submit data, as they do on Songbird, but don't act as validators since they cannot run nodes. Are not rewarded. All inflation is burned during observation mode . Public Observation Mode # Trigger: The Flare validator source code becomes publicly available Professional validators start onboarding, so the network starts becoming decentralized. FTSO data providers: Can submit data, as they do on Songbird, but don't act as validators since they won't have funds to stake until the TDE. Are not rewarded. All inflation is burned during observation mode . Initial Distribution Period # Trigger: 66% of validator power is independent of Flare, AND Exchanges agree to distribute the FLR token to their customers within a few days of the TDE Token Distribution Event (TDE) happens The new airdrop is sent to the Flare addresses provided by XRP token holders when they claimed. Part of the airdrop is expected to go to Exchange accounts, which will then distribute it to the users that originally claimed (the intended recipients ). Flare will monitor how many of the airdrop tokens have reached the intended recipients, by following the Exchange's communication channels. FTSO data providers: Can now deploy their own validator nodes. The guide to do so will be available. Act as validators and their voting power depends on their FTSO performance and stake . FTSO and validator rewards are enabled. Inflation is not burned anymore. FIP.01 Notice Period # Trigger: 66% of the new airdrop reaches its intended recipients The FIP.01 proposal modifies how the rest of the tokens (after the TDE) are to be distributed, so it needs to be voted on by the community. Users will vote with their FLR token stake, so voting cannot start until enough tokens have reached the intended recipients. Once 66% of the FLR tokens distributed during the TDE reach these users, a 1-week notice period will start. Flare will announce to the community that enough tokens have been distributed and the notice period has started. FIP.01 Voting Period # Trigger: 1 week after Notice Period starts All FLR token holders (obtained either from the new airdrop or bought at Exchanges) can vote on FIP.01 using a voting front-end (under development). Flare will announce to the community that the Voting Period has started and relay instructions on how to vote. Voting Period will last 1 week. Regular Operation (Beta) # Trigger: FIP.01 is approved after 1 week of voting The changes proposed in FIP.01 are implemented . The DIP is distributed to ALL holders of FLR during 37 months. Flare Beta is still in operation but community-run validators gradually gain more power. Regular Operation # Trigger: Community-run FTSO validators are deemed reliable enough Flare Beta ends. FTSO validators's validation power is not artificially reduced anymore and validator rewards (20% of inflation) are distributed equally among all validators according to their performance and stake. Regular Non-FIP.01 Operation # Trigger: FIP.01 is NOT approved after 1 week of voting The Original Distribution Plan is implemented.","title":"Flare Launch Process"},{"location":"tech/flare-launch-process/#flare-launch-process","text":"The Flare launch is delicate, as it involves a rather large airdrop , a community vote , and the deployment of a novel meritocratic consensus system. For this reason, it has been divided into a series of sequential phases with clearly-defined triggers that signal each transition. The main goal of this page is to remove any confusion around the launch process by clearly describing the purpose of each phase and what happens in them. The secondary goal is to serve as a real-time tracker of the current phase . Without further ado: Click on a phase to navigate to its description.","title":"Flare Launch Process"},{"location":"tech/flare-launch-process/#definitions","text":"Some definitions are required so the rest of the page is clear and unambiguous. FIP.01 : A governance proposal that, among other things, changes the initial token distributions as explained below. This proposal needs to be voted on according to the schedule described in this page. Flare Airdrop for XRP Holders : Certain holders of XRP tokens on Dec 12, 2020, were eligible to register for the FLR token distribution (then called Spark tokens) once the Flare network launched. The claiming process is described in this (slightly outdated) Flare blog post . The FIP.01 proposal modifies the way in which the airdrop works. Original Airdrop : 28.53B FLR tokens, which in the original distribution plan went to those who registered for the distribution. New Airdrop : 4.28B FLR tokens destined for those that registered for the distribution. Delegation Incentive Pool (DIP) : 24.25B FLR tokens destined for any Flare holder that participates in the network over 36 months as per the FIP.01 distribution plan. Note that the New Airdrop plus the DIP match the Original Airdrop. Token Distribution Event (TDE) : The moment when the initial FLR tokens are distributed to those that registered for the FLR token distribution. These tokens were minted and locked when the network was created and will be released when it is sufficiently decentralized.","title":"Definitions"},{"location":"tech/flare-launch-process/#token-distribution-plans","text":"It is worth summarizing the two current token distribution plans, as only one of them will be implemented depending on whether FIP.01 is approved or not. Original Distribution Plan : 15% of the original airdrop is sent to those that registered for the FLR distribution upon the TDE, with the rest delivered monthly over the following 36 months. Inflation is 10% of the fully diluted supply, per annum. FIP.01 Distribution Plan : The new airdrop is sent to those that registered for the FLR distribution upon the TDE, the DIP will be distributed to ALL FLR token holders (actually, wrapped FLR holders) over 36 months (Flare employees and companies excluded). Inflation is 10% of available supply in the first year, then 7% the following year, 5% the year after and in perpetuity, except that from year 3 onwards inflation is capped at 5bn FLR per year. Inflation distribution: 70% to FTSO rewards, 20% to validator rewards and 10% to the default Attestation Provider Set of the state connector .","title":"Token Distribution Plans"},{"location":"tech/flare-launch-process/#flare-beta","text":"Decentralization will be achieved by moving the transaction validation duty from the Flare Foundation to community-run FTSO data providers , but this will not happen instantly. Instead, in order to ensure a safe transition, a number of professional validators will be initially employed. The professional validators will be chosen among companies with proven experience running blockchain infrastructure, and will at first hold most of the validation power . This power, though, will be progressively shifted onto the community-run validators until they run the network on their own. This initial period is called Flare Beta , and it will span several launch phases (marked in blue in the diagram above).","title":"Flare Beta"},{"location":"tech/flare-launch-process/#flare-beta-details","text":"During this period: There are 22 total validators with equal validation power (20K FLR each, initially). 4 run by the Flare Foundation. 16 run by 4 professional validators. 2 \"virtual validators\" collectively run by ALL FTSO data providers together. FTSO data providers have their initial validation power artificially reduced so that all of them combined have the power of two validators (i.e. 40K FLR tokens). Validator rewards (20% of inflation) are split 50% for the professional validators and 50% for the FTSO data providers. The validation power for each FTSO validator will be calculated monthly by an external script (public, auditable and based on on-chain data) and shared among all validators. Each FTSO's share of validation power will depend on its FTSO performance and its own stake, as is done with the voting power used in the normal FTSO operation . The total validation power allocated for FTSO will start at 40K FLR but will gradually increase until it matches the real stake each FTSO has (including delegations). Validation rewards for FTSOs will increase accordingly as their collective validation power increases. Estimated duration: 6-9 months, depending on the evolution of the network.","title":"Flare Beta Details"},{"location":"tech/flare-launch-process/#launch-phases","text":"","title":"Launch Phases"},{"location":"tech/flare-launch-process/#private-observation-mode","text":"Trigger: The Flare network Launches On July 14th 2022 the network started centralized, with only 21 validators, run by the Flare Foundation. Flare validator source code is not available yet. FTSO data providers: Can submit data, as they do on Songbird, but don't act as validators since they cannot run nodes. Are not rewarded. All inflation is burned during observation mode .","title":"Private Observation Mode"},{"location":"tech/flare-launch-process/#public-observation-mode","text":"Trigger: The Flare validator source code becomes publicly available Professional validators start onboarding, so the network starts becoming decentralized. FTSO data providers: Can submit data, as they do on Songbird, but don't act as validators since they won't have funds to stake until the TDE. Are not rewarded. All inflation is burned during observation mode .","title":"Public Observation Mode"},{"location":"tech/flare-launch-process/#initial-distribution-period","text":"Trigger: 66% of validator power is independent of Flare, AND Exchanges agree to distribute the FLR token to their customers within a few days of the TDE Token Distribution Event (TDE) happens The new airdrop is sent to the Flare addresses provided by XRP token holders when they claimed. Part of the airdrop is expected to go to Exchange accounts, which will then distribute it to the users that originally claimed (the intended recipients ). Flare will monitor how many of the airdrop tokens have reached the intended recipients, by following the Exchange's communication channels. FTSO data providers: Can now deploy their own validator nodes. The guide to do so will be available. Act as validators and their voting power depends on their FTSO performance and stake . FTSO and validator rewards are enabled. Inflation is not burned anymore.","title":"Initial Distribution Period"},{"location":"tech/flare-launch-process/#fip01-notice-period","text":"Trigger: 66% of the new airdrop reaches its intended recipients The FIP.01 proposal modifies how the rest of the tokens (after the TDE) are to be distributed, so it needs to be voted on by the community. Users will vote with their FLR token stake, so voting cannot start until enough tokens have reached the intended recipients. Once 66% of the FLR tokens distributed during the TDE reach these users, a 1-week notice period will start. Flare will announce to the community that enough tokens have been distributed and the notice period has started.","title":"FIP.01 Notice Period"},{"location":"tech/flare-launch-process/#fip01-voting-period","text":"Trigger: 1 week after Notice Period starts All FLR token holders (obtained either from the new airdrop or bought at Exchanges) can vote on FIP.01 using a voting front-end (under development). Flare will announce to the community that the Voting Period has started and relay instructions on how to vote. Voting Period will last 1 week.","title":"FIP.01 Voting Period"},{"location":"tech/flare-launch-process/#regular-operation-beta","text":"Trigger: FIP.01 is approved after 1 week of voting The changes proposed in FIP.01 are implemented . The DIP is distributed to ALL holders of FLR during 37 months. Flare Beta is still in operation but community-run validators gradually gain more power.","title":"Regular Operation (Beta)"},{"location":"tech/flare-launch-process/#regular-operation","text":"Trigger: Community-run FTSO validators are deemed reliable enough Flare Beta ends. FTSO validators's validation power is not artificially reduced anymore and validator rewards (20% of inflation) are distributed equally among all validators according to their performance and stake.","title":"Regular Operation"},{"location":"tech/flare-launch-process/#regular-non-fip01-operation","text":"Trigger: FIP.01 is NOT approved after 1 week of voting The Original Distribution Plan is implemented.","title":"Regular Non-FIP.01 Operation"},{"location":"tech/flare/","text":"What is Flare? # Flare is a layer-1 blockchain network aimed at working with decentralized data. Flare is used just like Ethereum: even though the code is different, Flare offers the same API, supports the same smart contracts and the EVM just like Ethereum. As an example, Flare also supports NFTs . Common blockchain tools like wallets and block explorers are fully available on Flare. The native currency of the Flare network is the $FLR token, which is not an ERC-20 token. $FLR is handled the same way $ETH is handled on the Ethereum blockchain. The Flare Protocols # A number of protocols are actively being developed on the Flare network that provide on-chain decentralized data: The Flare Time-Series Oracle (FTSO) provides continuous estimations for different types of data. The State Connector allows querying non-changing, verifiable information from outside the Flare network. The Flare Networks # Flare has 4 networks with different purposes: Flare is the main network . Songbird is the canary network , used for testing features under \"real fire\" conditions, before deploying them on the main network. Coston is Songbird's public test network . Coston2 is Flare's public test network . General feature adoption flow.","title":"What is Flare?"},{"location":"tech/flare/#what-is-flare","text":"Flare is a layer-1 blockchain network aimed at working with decentralized data. Flare is used just like Ethereum: even though the code is different, Flare offers the same API, supports the same smart contracts and the EVM just like Ethereum. As an example, Flare also supports NFTs . Common blockchain tools like wallets and block explorers are fully available on Flare. The native currency of the Flare network is the $FLR token, which is not an ERC-20 token. $FLR is handled the same way $ETH is handled on the Ethereum blockchain.","title":"What is Flare?"},{"location":"tech/flare/#the-flare-protocols","text":"A number of protocols are actively being developed on the Flare network that provide on-chain decentralized data: The Flare Time-Series Oracle (FTSO) provides continuous estimations for different types of data. The State Connector allows querying non-changing, verifiable information from outside the Flare network.","title":"The Flare Protocols"},{"location":"tech/flare/#the-flare-networks","text":"Flare has 4 networks with different purposes: Flare is the main network . Songbird is the canary network , used for testing features under \"real fire\" conditions, before deploying them on the main network. Coston is Songbird's public test network . Coston2 is Flare's public test network . General feature adoption flow.","title":"The Flare Networks"},{"location":"tech/ftso/","text":"FTSO # The Flare Time Series Oracle (FTSO) is a smart contract running on the Flare network that provides continuous estimations for different types of data . It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). To achieve a secure, decentralized system, a set of independent data providers retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's vote power , and a median is calculated to produce the final estimate. Important When FTSOs were initially designed, they supported only cryptocurrency price pairs. Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work. The following diagram shows how price pairs are submitted to and filtered by the FTSO system. FTSO summary. Data providers that supply useful information , such as price pairs that are not removed as outliers because they are too far away from the median value, are rewarded , and the resulting data estimates are finally published on-chain . The following information describes: The FTSO workflow How results are calculated Vote power Delegation How developers can submit data , claim rewards , and use the data in an app Procedure Overview # Using price data as an example, the procedure in the following diagram runs continuously. It produces new data estimates during every price epoch , which is 3 minutes long . FTSO workflow. Any user with an account (address) on the Flare network can act as an FTSO data provider, submit data , and collect rewards . During each epoch, only submissions from the 100 data providers with the most vote power are considered. An account's vote power is based on its wrapped $FLR or $SGB balance and the delegations made to it (see Vote Power below). In this example, submitted data must be the current price (in $USD ) for one or more of the supported price pairs, currently: $XRP , $LTC , $XLM , $DOGE , $ADA , $ALGO , $BCH , $DGB , $BTC , $ETH , and $FIL . On Songbird, additionally, you have $SGB . More general data types might be added in the future. FTSO data providers submit data in rounds in a commit-and-reveal process, so they cannot see each other's submissions until a round is over. This process is like submitting data in a closed envelope, and when the round is over, all envelopes are opened. During a 3-minute price epoch, providers fetch the information, run their algorithms, and submit a hash of the data ( commit ). Then, during the first half of the following price epoch ( 1.5 minutes ), providers submit the actual data ( reveal ). See technical details about the data-submission process below. The FTSO system calculates the resulting median , taking into account each provider's vote power (see How Results are Calculated below). Results are publicly available for 5 price epochs for any app or contract to read. Previous epochs can always be retrieved from an archival node. For each price epoch in which the submitted data is close enough to the median value, data providers and their delegators are rewarded . Rewards are accumulated in reward epochs , which last 3.5 days on the Flare network and 7 days on Songbird, and you can claim them after the epoch finishes. See Rewards below. How Results are Calculated # The following example uses price pairs to show the filtering process that turns all submitted data into a single estimate. See all details in the Flare whitepaper . FTSO price calculation. The contract in charge of each price pair calculates the resulting price for a price epoch using the submissions received from all data providers during that epoch. Price epochs are 3 minutes long. Each submission has a price and a weight . Weight is based on the data provider's vote power , as explained below. The weighted median of the prices is the resulting price for the price epoch. Submissions in the top and bottom 25% range are not rewarded . Vote Power # FTSO delegation weight calculation. As explained above, an FTSO data provider's submissions are weighted by its vote power . A data provider's vote power is proportional to the amount of wrapped Flare or Songbird tokens ( $WFLR or $WSGB ) it holds, plus any amount delegated to it . A data provider's influence is limited A vote-power cap limits the influence of individual data providers to 2.5% of the total vote power on both Flare and Songbird. Any vote power above this cap is ignored. If vote power exceeds the limit, consider delegating those $WFLR or $WSGB to a different data provider. A snapshot of each data provider's vote power is taken once per reward epoch, and the resulting weight is then used throughout the next reward epoch . The actual snapshot block is called the vote-power block , and it is randomly chosen from the last blocks of the previous epoch. On Flare, the vote-power block is randomly chosen from roughly the last 50% of the blocks, and on Songbird, it is randomly chosen from roughly the last 25%. The random selection only roughly corresponds to the last 50% or 25% of the time because block production times are not constant. Reward epochs The first reward epoch on Songbird started on Saturday, 18 September 2021 08:41:39 (GMT), 1631954499 in Unix time and repeats every 7 days. Therefore, all Songbird reward epochs start on Saturday morning (GMT) . The first reward epoch on Flare started on Thursday, 21 July 2022 19:00:05 (GMT), 1658430005 in Unix time and repeats every 3.5 days. Therefore, all Flare reward epochs start on Thursday evening (GMT) and Monday morning (GMT) . Delegation # If you hold $FLR or $SGB tokens, you can delegate them to an FTSO data provider to increase its vote power and earn a share of its rewards , resulting in a mutually beneficial arrangement . When you delegate your vote power, you not only earn rewards but also support reliable data providers, which strengthens the stability of the FTSO and the whole ecosystem. Before you can delegate your native $FLR and $SGB tokens, you must wrap these tokens into ERC-20 $WFLR and $WSGB tokens, an operation you can reverse at any time. After you wrap your tokens, you will have the vote power that is equivalent to the wrapped token balance, and you can delegate 100% of this vote power to 1 or 2 data providers. Delegating 100% of your vote power to reliable data providers committed to providing accurate data maximizes your rewards and enhances the stability of the ecosystem. The reward rate (for advanced users) As you explore data providers, consider the expected reward rate each one offers. The reward rate describes how many tokens were earned by a data provider during a reward epoch for every 100 tokens delegated. The reward rate is calculated as \\(total\\_reward / vote\\_power * (100 - fee)\\) , where: \\(total\\_reward\\) : All accumulated rewards for the data provider and its delegators in the reward epoch. \\(vote\\_power\\) : All the data provider's $WFLR and all the $WFLR delegated to it in the vote-power block selected for the reward epoch. \\(fee\\) : The amount kept by the data provider as compensation for the service it provides. The value is specified as a percentage. For example, if the data provider's fee is 21.3%, specify 21.3 to calculate the reward rate. Because rewards are distributed in units of $FLR , the reward rate is calculated in units of $FLR . For the duration of the delegation, you will earn rewards that are commensurate with vote power and the performance of the chosen data providers. Rewards accumulate, and they become claimable for each reward epoch that is finalized. Inflation is distributed to everyone who participates in the FTSO system, which includes data providers and entities that delegate their vote power to the data providers. Delegated tokens are not locked , meaning that they remain in the user's control and the delegation can be removed at any time. Any $WFLR or $WSGB that is newly wrapped, sent, or received will automatically update your actual delegated vote power. However, if you receive native tokens, you must wrap them before you contribute to existing delegations. Immediate Delegation Revocation # Sometimes, a data provider might maliciously attack the FTSO system to skew the reported data. If this type of attack occurs, the vote power of a data provider can be revoked immediately instead of in the next reward epoch. In this situation, an off-chain process, such as a Twitter storm, calls for users to revoke vote power from the data provider that has attacked the system. When vote power is revoked, the revocation occurs immediately. Learn how to perform this operation from the block explorer. Effects of the Vote-Power Block Snapshot on Delegations # The following table shows when new, changed, and revoked delegations take effect in relation to the vote-power block snapshot. Delegation Type Before or After Vote-Power Block Snapshot When Delegation Takes Effect New or changed Before In the next reward epoch After After the next reward epoch ends Revoked N/A Immediately Delegation Procedure # You can delegate your tokens using the Flare Portal , a supported wallet like Bifrost , or a dapp . Some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer. If you are an advanced user, you can delegate manually by interacting directly with the FTSO smart contracts. Rewards # A percentage of the annual network inflation is reserved to reward FTSO data providers and distributed uniformly among the year's reward epochs. The mechanism that distributes rewards to data providers consists of several bands: Primary reward band : This band rewards 50% of submitted data, weighted by vote power and centered around the median price . That is, the primary reward band fixes the rewarded vote power at 50%, which makes the width of the primary reward band in each epoch variable. Secondary reward band : This band rewards submitted data that falls within a fixed percentage around the calculated median . That is, the width of the secondary reward band is fixed, which makes the rewarded vote power in each epoch variable. Submitted data in each reward epoch belongs to one of the following: Primary reward band Primary and secondary reward band Neither reward band On Flare, only the primary reward band is enabled, and reward epochs are 3.5 days. Important Support for the secondary reward band on Flare is planned and will be managed by a governance vote on a proposal similar to STP.02 . On Songbird, both the primary reward band and secondary reward band are enabled, and reward epochs are 7 days. In each reward epoch, rewards are distributed to providers whose submission falls within the primary or secondary reward bands. Because the secondary reward band is wider, it rewards more data providers than the primary band. However, submissions still must be close enough to the median to be included. If a submission falls within both bands, it receives both rewards because each reward band is independent. The secondary reward band receives 30% of all FTSO rewards, and the primary reward band receives the remaining 70%. As the FTSO system evolves, these reward percentages might be revised later, in accordance with an accepted proposal that requests changes to the secondary reward band. After the band rewards are distributed, each provider can take an optional, configurable fee , which is set to 20% by default, and distributes the rest of the reward among all contributors to its vote power , i.e., itself and all its delegators, according to the delegated amounts. If you delegated to a data provider, the amount of your rewards depends on multiple factors: The percentage of vote power you delegated The data providers to which you delegated your vote power The performance of those data providers The fee charged by those data providers Whether the total vote power of one or both of those data providers exceeded the vote power cap You can claim your rewards at the end of each reward epoch. You must claim your rewards within 90 days of their availability. After 90 days, unclaimed rewards on Flare are burned, and on Songbird, they are reallocated. Reward-Claiming Procedure # FTSO rewards are not automatically transferred to their recipients. Instead, the amounts are accumulated in a contract, as described in the System Architecture , and must be claimed once the reward epoch is finished . You can claim your rewards using the Flare Portal , a supported wallet like Bifrost , or a dapp . Take a look at flaremetrics.io and pick the one you prefer. If you are an advanced user, you can claim manually by interacting directly with the FTSO smart contracts. To save on gas costs, rewards from multiple reward epochs are claimed simultaneously when you use the Portal. However, be aware that rewards expire after 90 days . Moreover, you probably want to claim soon, to redelegate the received amount and obtain compounded rewards. It is also worth noting that: Rewards are paid in the network's native currency. On Flare, the native token is $FLR , and on Songbird, the native token is $SGB . Data providers and their delegators must claim independently. Technical Details # This section is aimed at developers. System Architecture # The FTSO system is composed of multiple smart contracts running on the Flare Network. Using prices as an example, the following diagram shows the flow of data, queries, and rewards through the FTSO system: FTSO component smart contracts. The following list describes the most relevant contracts and their purposes: FTSO : Each data type is handled by its own FTSO contract, including calculation of the filtered feed. To retrieve information about a data type, access this contract. Note If an FTSO contract is redeployed (for example, to fix a bug), its address will change and apps using it will need to be updated. The FTSO Registry contract below tracks this change for you. You can retrieve the addresses of all FTSO contracts using the getAllFtsos method in the FTSO Registry. FTSO Registry : Aggregates the output of each individual FTSO contract and provides a convenient one-stop API to retrieve all data. Price Submitter : This contract is used by the FTSO data providers to submit their data. Although the contract is called PriceSubmitter , data is not limited to prices. Reward Manager : Use this contract to claim your rewards, whether you are a data provider or a delegator. Wrapped Native (WNat) : This contract is not exclusively related to the FTSO system, but it is required to wrap and unwrap native tokens into the $WFLR and $WSGB that delegation requires. Note The Contract Addresses page explains how to securely retrieve each contract's address. Other contracts, like the FTSO Manager or the FTSO Daemon, are only meant for internal use by the FTSO system. Manual Delegation and Claiming # The following graphic shows the delegation process. You can call methods in several different smart contracts to manually delegate vote power and claim rewards . FTSO delegation process summary. Data-Submission Process # Data submission uses a commit-and-reveal scheme to prevent providers from viewing each other's submissions until a round is over. To speed up the process, both phases are actually overlapped so: All Commit phases happen continuously in so-called 3-minute Price Epochs . Reveal phases happen during the first half ( first 90 seconds ) of the following Commit phase. The published price information is therefore updated every 3 minutes . Only a hash of the data is submitted during the Commit phase. Next, in the Reveal phase the actual data is sent. If its hash does not match the previous commitment, the data is discarded. The submission API is slightly different for the Flare and Songbird networks: Flare Songbird FTSO data providers submit data through the PriceSubmitter contract . Commit : A single hash is needed for each submission. function submitHash ( uint256 _epochId , bytes32 _hash ) external ; Reveal : After all data is submitted, a single random number must be submitted. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 _random ) external ; FTSO data providers submit data through the PriceSubmitter contract . Commit : A separate hash is needed for each submission. function submitPriceHashes ( uint256 _epochId , uint256 [] memory _ftsoIndices , bytes32 [] memory _hashes ) external ; Reveal : Along with each data submission, a random number must be submitted too. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 [] memory _randoms ) external ; Retrieving Data # Data produced by the FTSO is publicly available on the Flare and Songbird networks. All data can be retrieved either through the FtsoRegistry contract or directly through one of the Ftso contracts. In any case, using the getCurrentPriceWithDecimals method is recommended. The following examples show how to use this method to retrieve price data. Retrieve by pair index Retrieve by pair symbol Retrieve directly From the FtsoRegistry contract: function getCurrentPriceWithDecimals ( uint256 _ftsoIndex ) external view returns ( uint256 _price , uint256 _timestamp , uint256 _assetPriceUsdDecimals ); Where _ftsoIndex is one of the allowed indices returned by getSupportedIndices , for example. From the FtsoRegistry contract: function getCurrentPriceWithDecimals ( string memory _symbol ) external view returns ( uint256 _price , uint256 _timestamp , uint256 _assetPriceUsdDecimals ); Where _symbol is one of the allowed symbols returned by getSupportedSymbols , for example. First you need to obtain the address of the Ftso contract managing the price pair you are interested in. You can use getSupportedIndicesSymbolsAndFtsos from the FtsoRegistry , for example. Then call getCurrentPriceWithDecimals on the FTSO directly: function getCurrentPriceWithDecimals ( ) external view returns ( uint256 _price , uint256 _timestamp , uint256 _assetPriceUsdDecimals ); Note Individual FTSO contracts might be updated periodically, which will change their addresses. Instead of caching these addresses, use the FtsoRegistry . GetCurrentPriceWithDecimals returns the requested price (the outcome of the previous 3-minute price epoch) in $USD shifting the comma by the amount of decimal places returned in _assetPriceUsdDecimals . That is, the actual price is _price * 10 - _assetPriceUsdDecimals . For example, a return value of 2603 with _assetPriceUsdDecimals of 5 means a price of 0.02603 USD (There are only 5 significant decimal places). A standard Unix timestamp of the last price update is also returned. Related User Guides # Managing delegations Managing rewards Wrapping tokens","title":"FTSO"},{"location":"tech/ftso/#ftso","text":"The Flare Time Series Oracle (FTSO) is a smart contract running on the Flare network that provides continuous estimations for different types of data . It does so in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). To achieve a secure, decentralized system, a set of independent data providers retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's vote power , and a median is calculated to produce the final estimate. Important When FTSOs were initially designed, they supported only cryptocurrency price pairs. Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work. The following diagram shows how price pairs are submitted to and filtered by the FTSO system. FTSO summary. Data providers that supply useful information , such as price pairs that are not removed as outliers because they are too far away from the median value, are rewarded , and the resulting data estimates are finally published on-chain . The following information describes: The FTSO workflow How results are calculated Vote power Delegation How developers can submit data , claim rewards , and use the data in an app","title":"FTSO"},{"location":"tech/ftso/#procedure-overview","text":"Using price data as an example, the procedure in the following diagram runs continuously. It produces new data estimates during every price epoch , which is 3 minutes long . FTSO workflow. Any user with an account (address) on the Flare network can act as an FTSO data provider, submit data , and collect rewards . During each epoch, only submissions from the 100 data providers with the most vote power are considered. An account's vote power is based on its wrapped $FLR or $SGB balance and the delegations made to it (see Vote Power below). In this example, submitted data must be the current price (in $USD ) for one or more of the supported price pairs, currently: $XRP , $LTC , $XLM , $DOGE , $ADA , $ALGO , $BCH , $DGB , $BTC , $ETH , and $FIL . On Songbird, additionally, you have $SGB . More general data types might be added in the future. FTSO data providers submit data in rounds in a commit-and-reveal process, so they cannot see each other's submissions until a round is over. This process is like submitting data in a closed envelope, and when the round is over, all envelopes are opened. During a 3-minute price epoch, providers fetch the information, run their algorithms, and submit a hash of the data ( commit ). Then, during the first half of the following price epoch ( 1.5 minutes ), providers submit the actual data ( reveal ). See technical details about the data-submission process below. The FTSO system calculates the resulting median , taking into account each provider's vote power (see How Results are Calculated below). Results are publicly available for 5 price epochs for any app or contract to read. Previous epochs can always be retrieved from an archival node. For each price epoch in which the submitted data is close enough to the median value, data providers and their delegators are rewarded . Rewards are accumulated in reward epochs , which last 3.5 days on the Flare network and 7 days on Songbird, and you can claim them after the epoch finishes. See Rewards below.","title":"Procedure Overview"},{"location":"tech/ftso/#how-results-are-calculated","text":"The following example uses price pairs to show the filtering process that turns all submitted data into a single estimate. See all details in the Flare whitepaper . FTSO price calculation. The contract in charge of each price pair calculates the resulting price for a price epoch using the submissions received from all data providers during that epoch. Price epochs are 3 minutes long. Each submission has a price and a weight . Weight is based on the data provider's vote power , as explained below. The weighted median of the prices is the resulting price for the price epoch. Submissions in the top and bottom 25% range are not rewarded .","title":"How Results are Calculated"},{"location":"tech/ftso/#vote-power","text":"FTSO delegation weight calculation. As explained above, an FTSO data provider's submissions are weighted by its vote power . A data provider's vote power is proportional to the amount of wrapped Flare or Songbird tokens ( $WFLR or $WSGB ) it holds, plus any amount delegated to it . A data provider's influence is limited A vote-power cap limits the influence of individual data providers to 2.5% of the total vote power on both Flare and Songbird. Any vote power above this cap is ignored. If vote power exceeds the limit, consider delegating those $WFLR or $WSGB to a different data provider. A snapshot of each data provider's vote power is taken once per reward epoch, and the resulting weight is then used throughout the next reward epoch . The actual snapshot block is called the vote-power block , and it is randomly chosen from the last blocks of the previous epoch. On Flare, the vote-power block is randomly chosen from roughly the last 50% of the blocks, and on Songbird, it is randomly chosen from roughly the last 25%. The random selection only roughly corresponds to the last 50% or 25% of the time because block production times are not constant. Reward epochs The first reward epoch on Songbird started on Saturday, 18 September 2021 08:41:39 (GMT), 1631954499 in Unix time and repeats every 7 days. Therefore, all Songbird reward epochs start on Saturday morning (GMT) . The first reward epoch on Flare started on Thursday, 21 July 2022 19:00:05 (GMT), 1658430005 in Unix time and repeats every 3.5 days. Therefore, all Flare reward epochs start on Thursday evening (GMT) and Monday morning (GMT) .","title":"Vote Power"},{"location":"tech/ftso/#delegation","text":"If you hold $FLR or $SGB tokens, you can delegate them to an FTSO data provider to increase its vote power and earn a share of its rewards , resulting in a mutually beneficial arrangement . When you delegate your vote power, you not only earn rewards but also support reliable data providers, which strengthens the stability of the FTSO and the whole ecosystem. Before you can delegate your native $FLR and $SGB tokens, you must wrap these tokens into ERC-20 $WFLR and $WSGB tokens, an operation you can reverse at any time. After you wrap your tokens, you will have the vote power that is equivalent to the wrapped token balance, and you can delegate 100% of this vote power to 1 or 2 data providers. Delegating 100% of your vote power to reliable data providers committed to providing accurate data maximizes your rewards and enhances the stability of the ecosystem. The reward rate (for advanced users) As you explore data providers, consider the expected reward rate each one offers. The reward rate describes how many tokens were earned by a data provider during a reward epoch for every 100 tokens delegated. The reward rate is calculated as \\(total\\_reward / vote\\_power * (100 - fee)\\) , where: \\(total\\_reward\\) : All accumulated rewards for the data provider and its delegators in the reward epoch. \\(vote\\_power\\) : All the data provider's $WFLR and all the $WFLR delegated to it in the vote-power block selected for the reward epoch. \\(fee\\) : The amount kept by the data provider as compensation for the service it provides. The value is specified as a percentage. For example, if the data provider's fee is 21.3%, specify 21.3 to calculate the reward rate. Because rewards are distributed in units of $FLR , the reward rate is calculated in units of $FLR . For the duration of the delegation, you will earn rewards that are commensurate with vote power and the performance of the chosen data providers. Rewards accumulate, and they become claimable for each reward epoch that is finalized. Inflation is distributed to everyone who participates in the FTSO system, which includes data providers and entities that delegate their vote power to the data providers. Delegated tokens are not locked , meaning that they remain in the user's control and the delegation can be removed at any time. Any $WFLR or $WSGB that is newly wrapped, sent, or received will automatically update your actual delegated vote power. However, if you receive native tokens, you must wrap them before you contribute to existing delegations.","title":"Delegation"},{"location":"tech/ftso/#immediate-delegation-revocation","text":"Sometimes, a data provider might maliciously attack the FTSO system to skew the reported data. If this type of attack occurs, the vote power of a data provider can be revoked immediately instead of in the next reward epoch. In this situation, an off-chain process, such as a Twitter storm, calls for users to revoke vote power from the data provider that has attacked the system. When vote power is revoked, the revocation occurs immediately. Learn how to perform this operation from the block explorer.","title":"Immediate Delegation Revocation"},{"location":"tech/ftso/#effects-of-the-vote-power-block-snapshot-on-delegations","text":"The following table shows when new, changed, and revoked delegations take effect in relation to the vote-power block snapshot. Delegation Type Before or After Vote-Power Block Snapshot When Delegation Takes Effect New or changed Before In the next reward epoch After After the next reward epoch ends Revoked N/A Immediately","title":"Effects of the Vote-Power Block Snapshot on Delegations"},{"location":"tech/ftso/#delegation-procedure","text":"You can delegate your tokens using the Flare Portal , a supported wallet like Bifrost , or a dapp . Some FTSO data providers have already started providing these dapps as a convenience. Take a look at flaremetrics.io and pick the one you prefer. If you are an advanced user, you can delegate manually by interacting directly with the FTSO smart contracts.","title":"Delegation Procedure"},{"location":"tech/ftso/#rewards","text":"A percentage of the annual network inflation is reserved to reward FTSO data providers and distributed uniformly among the year's reward epochs. The mechanism that distributes rewards to data providers consists of several bands: Primary reward band : This band rewards 50% of submitted data, weighted by vote power and centered around the median price . That is, the primary reward band fixes the rewarded vote power at 50%, which makes the width of the primary reward band in each epoch variable. Secondary reward band : This band rewards submitted data that falls within a fixed percentage around the calculated median . That is, the width of the secondary reward band is fixed, which makes the rewarded vote power in each epoch variable. Submitted data in each reward epoch belongs to one of the following: Primary reward band Primary and secondary reward band Neither reward band On Flare, only the primary reward band is enabled, and reward epochs are 3.5 days. Important Support for the secondary reward band on Flare is planned and will be managed by a governance vote on a proposal similar to STP.02 . On Songbird, both the primary reward band and secondary reward band are enabled, and reward epochs are 7 days. In each reward epoch, rewards are distributed to providers whose submission falls within the primary or secondary reward bands. Because the secondary reward band is wider, it rewards more data providers than the primary band. However, submissions still must be close enough to the median to be included. If a submission falls within both bands, it receives both rewards because each reward band is independent. The secondary reward band receives 30% of all FTSO rewards, and the primary reward band receives the remaining 70%. As the FTSO system evolves, these reward percentages might be revised later, in accordance with an accepted proposal that requests changes to the secondary reward band. After the band rewards are distributed, each provider can take an optional, configurable fee , which is set to 20% by default, and distributes the rest of the reward among all contributors to its vote power , i.e., itself and all its delegators, according to the delegated amounts. If you delegated to a data provider, the amount of your rewards depends on multiple factors: The percentage of vote power you delegated The data providers to which you delegated your vote power The performance of those data providers The fee charged by those data providers Whether the total vote power of one or both of those data providers exceeded the vote power cap You can claim your rewards at the end of each reward epoch. You must claim your rewards within 90 days of their availability. After 90 days, unclaimed rewards on Flare are burned, and on Songbird, they are reallocated.","title":"Rewards"},{"location":"tech/ftso/#reward-claiming-procedure","text":"FTSO rewards are not automatically transferred to their recipients. Instead, the amounts are accumulated in a contract, as described in the System Architecture , and must be claimed once the reward epoch is finished . You can claim your rewards using the Flare Portal , a supported wallet like Bifrost , or a dapp . Take a look at flaremetrics.io and pick the one you prefer. If you are an advanced user, you can claim manually by interacting directly with the FTSO smart contracts. To save on gas costs, rewards from multiple reward epochs are claimed simultaneously when you use the Portal. However, be aware that rewards expire after 90 days . Moreover, you probably want to claim soon, to redelegate the received amount and obtain compounded rewards. It is also worth noting that: Rewards are paid in the network's native currency. On Flare, the native token is $FLR , and on Songbird, the native token is $SGB . Data providers and their delegators must claim independently.","title":"Reward-Claiming Procedure"},{"location":"tech/ftso/#technical-details","text":"This section is aimed at developers.","title":"Technical Details"},{"location":"tech/ftso/#system-architecture","text":"The FTSO system is composed of multiple smart contracts running on the Flare Network. Using prices as an example, the following diagram shows the flow of data, queries, and rewards through the FTSO system: FTSO component smart contracts. The following list describes the most relevant contracts and their purposes: FTSO : Each data type is handled by its own FTSO contract, including calculation of the filtered feed. To retrieve information about a data type, access this contract. Note If an FTSO contract is redeployed (for example, to fix a bug), its address will change and apps using it will need to be updated. The FTSO Registry contract below tracks this change for you. You can retrieve the addresses of all FTSO contracts using the getAllFtsos method in the FTSO Registry. FTSO Registry : Aggregates the output of each individual FTSO contract and provides a convenient one-stop API to retrieve all data. Price Submitter : This contract is used by the FTSO data providers to submit their data. Although the contract is called PriceSubmitter , data is not limited to prices. Reward Manager : Use this contract to claim your rewards, whether you are a data provider or a delegator. Wrapped Native (WNat) : This contract is not exclusively related to the FTSO system, but it is required to wrap and unwrap native tokens into the $WFLR and $WSGB that delegation requires. Note The Contract Addresses page explains how to securely retrieve each contract's address. Other contracts, like the FTSO Manager or the FTSO Daemon, are only meant for internal use by the FTSO system.","title":"System Architecture"},{"location":"tech/ftso/#manual-delegation-and-claiming","text":"The following graphic shows the delegation process. You can call methods in several different smart contracts to manually delegate vote power and claim rewards . FTSO delegation process summary.","title":"Manual Delegation and Claiming"},{"location":"tech/ftso/#data-submission-process","text":"Data submission uses a commit-and-reveal scheme to prevent providers from viewing each other's submissions until a round is over. To speed up the process, both phases are actually overlapped so: All Commit phases happen continuously in so-called 3-minute Price Epochs . Reveal phases happen during the first half ( first 90 seconds ) of the following Commit phase. The published price information is therefore updated every 3 minutes . Only a hash of the data is submitted during the Commit phase. Next, in the Reveal phase the actual data is sent. If its hash does not match the previous commitment, the data is discarded. The submission API is slightly different for the Flare and Songbird networks: Flare Songbird FTSO data providers submit data through the PriceSubmitter contract . Commit : A single hash is needed for each submission. function submitHash ( uint256 _epochId , bytes32 _hash ) external ; Reveal : After all data is submitted, a single random number must be submitted. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 _random ) external ; FTSO data providers submit data through the PriceSubmitter contract . Commit : A separate hash is needed for each submission. function submitPriceHashes ( uint256 _epochId , uint256 [] memory _ftsoIndices , bytes32 [] memory _hashes ) external ; Reveal : Along with each data submission, a random number must be submitted too. function revealPrices ( uint256 _epochId , uint256 [] memory _ftsoIndices , uint256 [] memory _prices , uint256 [] memory _randoms ) external ;","title":"Data-Submission Process"},{"location":"tech/ftso/#retrieving-data","text":"Data produced by the FTSO is publicly available on the Flare and Songbird networks. All data can be retrieved either through the FtsoRegistry contract or directly through one of the Ftso contracts. In any case, using the getCurrentPriceWithDecimals method is recommended. The following examples show how to use this method to retrieve price data. Retrieve by pair index Retrieve by pair symbol Retrieve directly From the FtsoRegistry contract: function getCurrentPriceWithDecimals ( uint256 _ftsoIndex ) external view returns ( uint256 _price , uint256 _timestamp , uint256 _assetPriceUsdDecimals ); Where _ftsoIndex is one of the allowed indices returned by getSupportedIndices , for example. From the FtsoRegistry contract: function getCurrentPriceWithDecimals ( string memory _symbol ) external view returns ( uint256 _price , uint256 _timestamp , uint256 _assetPriceUsdDecimals ); Where _symbol is one of the allowed symbols returned by getSupportedSymbols , for example. First you need to obtain the address of the Ftso contract managing the price pair you are interested in. You can use getSupportedIndicesSymbolsAndFtsos from the FtsoRegistry , for example. Then call getCurrentPriceWithDecimals on the FTSO directly: function getCurrentPriceWithDecimals ( ) external view returns ( uint256 _price , uint256 _timestamp , uint256 _assetPriceUsdDecimals ); Note Individual FTSO contracts might be updated periodically, which will change their addresses. Instead of caching these addresses, use the FtsoRegistry . GetCurrentPriceWithDecimals returns the requested price (the outcome of the previous 3-minute price epoch) in $USD shifting the comma by the amount of decimal places returned in _assetPriceUsdDecimals . That is, the actual price is _price * 10 - _assetPriceUsdDecimals . For example, a return value of 2603 with _assetPriceUsdDecimals of 5 means a price of 0.02603 USD (There are only 5 significant decimal places). A standard Unix timestamp of the last price update is also returned.","title":"Retrieving Data"},{"location":"tech/ftso/#related-user-guides","text":"Managing delegations Managing rewards Wrapping tokens","title":"Related User Guides"},{"location":"tech/glossary/","text":"Glossary # Attestation A data proof provided to the State Connector by a decentralized set of Attestation Providers that confirms the validity or otherwise of any request. Autoclaiming Automatic claiming enables users to appoint an executor to claim rewards on their behalf. Read more... Avalanche An open-source blockchain using the Snow family of consensus protocols and Proof of Stake for Sybil resistance . It is advertised as the fastest smart contract platform. Read more... Block For performance reasons, blockchains do not process transactions one by one. Instead, transactions are grouped together in blocks which are then validated by the consensus algorithm. Blockchain Digital ledger storing data and transactions on a distributed network of computers to make it more robust. Cryptography protects against information tampering, and a consensus algorithm ensures that the majority of the network agrees on the stored data even if some of its nodes act maliciously. Byzantine Fault Tolerance Property of a distributed system that is capable of continuous operation even when some of its participants are unreliable. Participants acting against the interest of the whole system, by accident or on purpose, are said to have \u201cgone Byzantine\u201d. Canary Network A network used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network . All users of the canary network are real users, but they are aware of the experimental nature of the platform. The name comes from the time when actual miners used actual canaries to detect the presence of poisonous gas in the mines. Flare's canary network is called Songbird . Consensus Algorithm that makes nodes on a blockchain\u2019s network agree on the validity of a given transaction, even if some of the nodes provide invalid transactions or try to disrupt the network ( Byzantine Fault Tolerance ). Coston The name given to both of Flare's public test networks (Coston and Coston2), in remembrance and celebration of a great inventor, Martha J. Coston (1826-1904). Cross-chain (or inter-ecosystem) interoperability Communication between two or more disparate blockchain ecosystems that are technologically incompatible due to the lack of shared systems, protocols or code (e.g. Ethereum and Solana). DAO A Decentralized Autonomous Organization is an entity with no central authority. Its governance is mandated by rules encoded on a blockchain so it is tamper-proof. dApp A Decentralized Application is a computer program that makes use of blockchain technology and therefore the information it uses or stores has the same benefits (trustlessness, censorship resistance, geographical redundancy, etc). The dapp itself may or may not be hosted on a blockchain. Data Provider Each of the multiple programs supplying external information to an FTSO running on the Flare network, and getting rewarded for it. Token holders can delegate their stake to a data provider and receive a share of the rewards. DeFi Decentralized Finance is a form of finance that does not rely on a central financial institution. DeFi is commonly based on blockchain technology. Delegate To assign a duty to someone else, so they do it for you. On the Flare network, an address can delegate any fraction of the votes associated with the tokens it holds to another address, for the purpose of FTSO weighting or governance participation. Note that no tokens are transferred. EVM The Ethereum Virtual Machine allows executing smart contracts on the Ethereum network, regardless of the kind of computer that executes it. Multiple blockchain networks, including Flare, support EVM contracts. Read more... Executor Users who do not want to claim rewards themselves can set an executor to claim rewards for them and send them directly to their users' accounts. Read more... Faucet A dapp that distributes test tokens to anyone that requests them. Used only on test networks , obviously. See the Network Configuration page to learn about Flare's faucets. FBA Federated Byzantine Agreement is a form of Byzantine fault tolerance where each node keeps its own list of trusted nodes. It does not require nodes to invest stake or computing power as Proof of Stake or Proof of Work protocols do. FCP The Flare Consensus Protocol is an asynchronous, ordered and leaderless version of Federated Byzantine Agreement ( FBA ) consensus. The whitepaper is already available and it is currently in the process of being implemented. Read more... Flare Token (FLR) The native currency of the Flare's main network . FTSO The Flare Time Series Oracles provide external information to the Flare network in a decentralized manner, by using multiple independent data providers that are rewarded for providing accurate information. Read more... Governance Mechanism to propose, vote and implement changes on a blockchain protocol. On Flare, anybody can propose updates and token holders vote to accept them. Know Your Customer The process an entity completes to verify the identities of its users to comply with global requirements. Ledger Historically, a book where financial transactions are recorded. In blockchain technology a ledger can contain any kind of information and it has multiple copies distributed among several computers, which are kept in sync by a consensus algorithm. Light Client Relay A simplified communication mechanism built for speed that only queries the header data of any transaction and therefore lacks the security that comes from querying a full node with full history (e.g. SPV ). Liquidity Pool A collection of funds locked in a smart contract for the purpose of facilitating trading, lending and other functionality in a decentralized manner. Main Network (MAINNET) The computer network that supports a blockchain in its production stage, i.e., the real thing (instead of a Canary or Test network). Metaverse An old concept, at times called Virtual Reality or Cyberspace, that translates human interaction to virtual (i.e. non-physical) worlds. Currently in vogue again because blockchain technology promises to link the physical and the virtual worlds and thus bring a degree of reality to the latter. Multi-chain (or intra-ecosystem) interoperability Communication between two or more technologically compatible blockchains that exist within the same ecosystem and share systems, protocols and code (e.g. Polkadot Parachains , Cosmos Tendermint chains or Ethereum layer 2 protocols). NFT Non-Fungible Tokens are digital representations of assets which are unique and therefore non-mergeable (non-fungible), made impossible to copy by blockchain technology. Common use cases are certificates of authenticity or ownership, or limited edition collectibles. Most NFT tokens are built on the Ethereum network using standards ERC-721 and ERC-1155 . Oracle A mechanism to provide external information to a blockchain, so that it can be used by smart contracts , for example. Flare oracles are called FTSO . Proof of Stake A kind of Sybil resistance based on staking assets to participate in consensus. The rationale is that a participant investing enough assets will not be interested in attacking the network that supports such assets. Moreover, if malicious behavior is detected part of the assets can be taken as punishment. Proof of Work A kind of Sybil resistance based on spending computer power to participate in consensus. The rationale is that attacking the network becomes prohibitively expensive in terms of computer power. Pruning A blockchain database reduction technique, which keeps the state of all addresses (like their balance) and the transactions that led to that state, but removes any old transaction that does not impact the current state anymore. Quantum Resistance The ability of a cryptographic algorithm (and therefore of a blockchain) to resist an attack from a theoretical quantum computer. Quorum Set of participants on a consensus algorithm that must agree on a result for the whole network to accept that result. On a blockchain, once consensus is reached about a block , it is added to the ledger and the next block is processed. Quorum Slice In FBA consensus each node has multiple lists of other nodes which it voluntarily decides to trust, forming its quorum slices. All nodes in a quorum slice agreeing on a result are enough to convince the node of that result. If the quorum slices are correctly built, global quorum emerges from these local quorum slices. RPC Remote Procedure Call is a protocol that allows a program executing on a computer to request a service from another program, typically running on a different computer. Smart Contract Computer program running on a blockchain, typically one based on the EVM . The blockchain\u2019s immutability ensures that the contract is not tampered with, and running it on several machines bound together by a consensus algorithm ensures faithful execution. Smart contracts are said to be self-enforcing. Songbird Flare's canary network , launched in September 2021. State Connector Piece of the Flare network that keeps track of the state of other networks, facilitating the implementation of advanced mechanisms like the FAssets. The State Connector uses several independent Attestation Providers that are rewarded for providing correct information. Read more... Sybil Resistance The ability of a distributed system to overcome a Sybil attack, in which a malicious actor creates multiple identities to gain voting or mining power. Resistance is typically gained by making voting or mining too costly for the attack to be worth it (as in Proof of Work or Proof of Stake ) or by requiring new entities to be approved by existing actors (as in FBA ). Test Network (TESTNET) The computer network that supports a blockchain in its development stage. It is intended for testing purposes and should not store valuable assets, as its contents might be deleted (purposely or by accident) at any time. Among other facilities, testnets typically provide faucets . Compare to a Canary or a Main network. Flare's testnets are Coston for Songbird and Coston2 for Flare. Transaction A request to add information to the blockchain, which is then analyzed by the network and accepted when consensus is reached about its validity. It can be a movement of funds between two accounts, or the execution of a contract, for example. Transaction Fee Amount of cryptocurrency that must be paid by anybody submitting a transaction for inclusion on a blockchain. These fees reward block producers for their work processing transactions, and typically vary depending on network congestion. Token A digital representation of an asset. Fungible tokens are indistinguishable from one another so they can be merged together (e.g. a cryptocurrency). Non-fungible tokens ( NFT ) are unique and therefore cannot be merged. Turing-completeness The ability of a machine to solve any computational problem, no matter how complex, given the necessary steps and enough time and memory. This is a mandatory feature of any general-purpose processor like a CPU or the EVM . Validator A validator node is a machine connected to a blockchain network that verifies transactions and emits a vote. When there is a quorum among all validators regarding a given block of transactions, they are accepted into the blockchain. Voting Power Weight proportional to the tokens held by an address plus the tokens delegated to it. This weight is used during FTSO operation and governance votes, for example. Wen flare The war cry of all the impatient that would like to see the Flare network launch before it is fully tested. Pay no heed to them. Zero address A special address represented as 0x0000000000000000000000000000 . Also known as the null address, it is typically used as a return value from functions to indicate an error condition. /*Glossary links from within the glossary page*/ a[href^=\"#\"] { text-decoration-style: dotted; text-decoration-thickness: 1px; } /*Separating line for the glossary nav link from within the glossary page*/ .md-nav__link.md-nav__link--active { border-top: solid 1px var(--md-default-fg-color--lightest); padding-top: 8px; }","title":"Glossary"},{"location":"tech/glossary/#glossary","text":"Attestation A data proof provided to the State Connector by a decentralized set of Attestation Providers that confirms the validity or otherwise of any request. Autoclaiming Automatic claiming enables users to appoint an executor to claim rewards on their behalf. Read more... Avalanche An open-source blockchain using the Snow family of consensus protocols and Proof of Stake for Sybil resistance . It is advertised as the fastest smart contract platform. Read more... Block For performance reasons, blockchains do not process transactions one by one. Instead, transactions are grouped together in blocks which are then validated by the consensus algorithm. Blockchain Digital ledger storing data and transactions on a distributed network of computers to make it more robust. Cryptography protects against information tampering, and a consensus algorithm ensures that the majority of the network agrees on the stored data even if some of its nodes act maliciously. Byzantine Fault Tolerance Property of a distributed system that is capable of continuous operation even when some of its participants are unreliable. Participants acting against the interest of the whole system, by accident or on purpose, are said to have \u201cgone Byzantine\u201d. Canary Network A network used for testing features under \u201creal fire\u201d conditions, before deploying them on the main network . All users of the canary network are real users, but they are aware of the experimental nature of the platform. The name comes from the time when actual miners used actual canaries to detect the presence of poisonous gas in the mines. Flare's canary network is called Songbird . Consensus Algorithm that makes nodes on a blockchain\u2019s network agree on the validity of a given transaction, even if some of the nodes provide invalid transactions or try to disrupt the network ( Byzantine Fault Tolerance ). Coston The name given to both of Flare's public test networks (Coston and Coston2), in remembrance and celebration of a great inventor, Martha J. Coston (1826-1904). Cross-chain (or inter-ecosystem) interoperability Communication between two or more disparate blockchain ecosystems that are technologically incompatible due to the lack of shared systems, protocols or code (e.g. Ethereum and Solana). DAO A Decentralized Autonomous Organization is an entity with no central authority. Its governance is mandated by rules encoded on a blockchain so it is tamper-proof. dApp A Decentralized Application is a computer program that makes use of blockchain technology and therefore the information it uses or stores has the same benefits (trustlessness, censorship resistance, geographical redundancy, etc). The dapp itself may or may not be hosted on a blockchain. Data Provider Each of the multiple programs supplying external information to an FTSO running on the Flare network, and getting rewarded for it. Token holders can delegate their stake to a data provider and receive a share of the rewards. DeFi Decentralized Finance is a form of finance that does not rely on a central financial institution. DeFi is commonly based on blockchain technology. Delegate To assign a duty to someone else, so they do it for you. On the Flare network, an address can delegate any fraction of the votes associated with the tokens it holds to another address, for the purpose of FTSO weighting or governance participation. Note that no tokens are transferred. EVM The Ethereum Virtual Machine allows executing smart contracts on the Ethereum network, regardless of the kind of computer that executes it. Multiple blockchain networks, including Flare, support EVM contracts. Read more... Executor Users who do not want to claim rewards themselves can set an executor to claim rewards for them and send them directly to their users' accounts. Read more... Faucet A dapp that distributes test tokens to anyone that requests them. Used only on test networks , obviously. See the Network Configuration page to learn about Flare's faucets. FBA Federated Byzantine Agreement is a form of Byzantine fault tolerance where each node keeps its own list of trusted nodes. It does not require nodes to invest stake or computing power as Proof of Stake or Proof of Work protocols do. FCP The Flare Consensus Protocol is an asynchronous, ordered and leaderless version of Federated Byzantine Agreement ( FBA ) consensus. The whitepaper is already available and it is currently in the process of being implemented. Read more... Flare Token (FLR) The native currency of the Flare's main network . FTSO The Flare Time Series Oracles provide external information to the Flare network in a decentralized manner, by using multiple independent data providers that are rewarded for providing accurate information. Read more... Governance Mechanism to propose, vote and implement changes on a blockchain protocol. On Flare, anybody can propose updates and token holders vote to accept them. Know Your Customer The process an entity completes to verify the identities of its users to comply with global requirements. Ledger Historically, a book where financial transactions are recorded. In blockchain technology a ledger can contain any kind of information and it has multiple copies distributed among several computers, which are kept in sync by a consensus algorithm. Light Client Relay A simplified communication mechanism built for speed that only queries the header data of any transaction and therefore lacks the security that comes from querying a full node with full history (e.g. SPV ). Liquidity Pool A collection of funds locked in a smart contract for the purpose of facilitating trading, lending and other functionality in a decentralized manner. Main Network (MAINNET) The computer network that supports a blockchain in its production stage, i.e., the real thing (instead of a Canary or Test network). Metaverse An old concept, at times called Virtual Reality or Cyberspace, that translates human interaction to virtual (i.e. non-physical) worlds. Currently in vogue again because blockchain technology promises to link the physical and the virtual worlds and thus bring a degree of reality to the latter. Multi-chain (or intra-ecosystem) interoperability Communication between two or more technologically compatible blockchains that exist within the same ecosystem and share systems, protocols and code (e.g. Polkadot Parachains , Cosmos Tendermint chains or Ethereum layer 2 protocols). NFT Non-Fungible Tokens are digital representations of assets which are unique and therefore non-mergeable (non-fungible), made impossible to copy by blockchain technology. Common use cases are certificates of authenticity or ownership, or limited edition collectibles. Most NFT tokens are built on the Ethereum network using standards ERC-721 and ERC-1155 . Oracle A mechanism to provide external information to a blockchain, so that it can be used by smart contracts , for example. Flare oracles are called FTSO . Proof of Stake A kind of Sybil resistance based on staking assets to participate in consensus. The rationale is that a participant investing enough assets will not be interested in attacking the network that supports such assets. Moreover, if malicious behavior is detected part of the assets can be taken as punishment. Proof of Work A kind of Sybil resistance based on spending computer power to participate in consensus. The rationale is that attacking the network becomes prohibitively expensive in terms of computer power. Pruning A blockchain database reduction technique, which keeps the state of all addresses (like their balance) and the transactions that led to that state, but removes any old transaction that does not impact the current state anymore. Quantum Resistance The ability of a cryptographic algorithm (and therefore of a blockchain) to resist an attack from a theoretical quantum computer. Quorum Set of participants on a consensus algorithm that must agree on a result for the whole network to accept that result. On a blockchain, once consensus is reached about a block , it is added to the ledger and the next block is processed. Quorum Slice In FBA consensus each node has multiple lists of other nodes which it voluntarily decides to trust, forming its quorum slices. All nodes in a quorum slice agreeing on a result are enough to convince the node of that result. If the quorum slices are correctly built, global quorum emerges from these local quorum slices. RPC Remote Procedure Call is a protocol that allows a program executing on a computer to request a service from another program, typically running on a different computer. Smart Contract Computer program running on a blockchain, typically one based on the EVM . The blockchain\u2019s immutability ensures that the contract is not tampered with, and running it on several machines bound together by a consensus algorithm ensures faithful execution. Smart contracts are said to be self-enforcing. Songbird Flare's canary network , launched in September 2021. State Connector Piece of the Flare network that keeps track of the state of other networks, facilitating the implementation of advanced mechanisms like the FAssets. The State Connector uses several independent Attestation Providers that are rewarded for providing correct information. Read more... Sybil Resistance The ability of a distributed system to overcome a Sybil attack, in which a malicious actor creates multiple identities to gain voting or mining power. Resistance is typically gained by making voting or mining too costly for the attack to be worth it (as in Proof of Work or Proof of Stake ) or by requiring new entities to be approved by existing actors (as in FBA ). Test Network (TESTNET) The computer network that supports a blockchain in its development stage. It is intended for testing purposes and should not store valuable assets, as its contents might be deleted (purposely or by accident) at any time. Among other facilities, testnets typically provide faucets . Compare to a Canary or a Main network. Flare's testnets are Coston for Songbird and Coston2 for Flare. Transaction A request to add information to the blockchain, which is then analyzed by the network and accepted when consensus is reached about its validity. It can be a movement of funds between two accounts, or the execution of a contract, for example. Transaction Fee Amount of cryptocurrency that must be paid by anybody submitting a transaction for inclusion on a blockchain. These fees reward block producers for their work processing transactions, and typically vary depending on network congestion. Token A digital representation of an asset. Fungible tokens are indistinguishable from one another so they can be merged together (e.g. a cryptocurrency). Non-fungible tokens ( NFT ) are unique and therefore cannot be merged. Turing-completeness The ability of a machine to solve any computational problem, no matter how complex, given the necessary steps and enough time and memory. This is a mandatory feature of any general-purpose processor like a CPU or the EVM . Validator A validator node is a machine connected to a blockchain network that verifies transactions and emits a vote. When there is a quorum among all validators regarding a given block of transactions, they are accepted into the blockchain. Voting Power Weight proportional to the tokens held by an address plus the tokens delegated to it. This weight is used during FTSO operation and governance votes, for example. Wen flare The war cry of all the impatient that would like to see the Flare network launch before it is fully tested. Pay no heed to them. Zero address A special address represented as 0x0000000000000000000000000000 . Also known as the null address, it is typically used as a return value from functions to indicate an error condition. /*Glossary links from within the glossary page*/ a[href^=\"#\"] { text-decoration-style: dotted; text-decoration-thickness: 1px; } /*Separating line for the glossary nav link from within the glossary page*/ .md-nav__link.md-nav__link--active { border-top: solid 1px var(--md-default-fg-color--lightest); padding-top: 8px; }","title":"Glossary"},{"location":"tech/governance/","text":"Governance # Introduction # Flare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the Flare and Songbird networks, making governance an important element of decentralization. This process enables the Flare Foundation and Flare and Songbird community members to: Propose policy changes. Vote on them. Execute them if accepted. The following sections detail the different kinds of proposals Flare allows and the process for each of them. If you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the Voting User Guide . Flare's Governance # Excluding the testnets Coston and Coston2, Flare currently has two networks: Flare and Songbird. Moreover, two kinds of proposals are planned, depending on who initiates them: those proposed by the community and those proposed by the Flare Foundation. This situation leads to four types of proposals, of which only two are currently supported and detailed next. Flare Improvement Proposals and Songbird Test Proposals # Flare Improvement Proposals (FIPs) and Songbird Test Proposals (STPs) are initiated by the Flare Foundation and are aimed at improving the Flare and Songbird networks. Community-initiated proposals will be supported later. To increase its stability, FIPs are rejected by default, meaning that they are accepted only if enough votes are cast in their favor. To increase the swiftness at which new proposals can be tested on Songbird, STPs are accepted by default, meaning that they are rejected only if enough votes are cast against them. See Voting Outcomes below for more details. Who Votes # To vote on a proposal on a network, you must have the valid wrapped token: Network Proposal Type Token Wrapped Token Flare FIP $FLR $WFLR Songbird STP $SGB $WSGB Important Available votes depend on the amount of valid wrapped tokens you have, not the native tokens. Therefore, remember to wrap your tokens . Don't wrap all your tokens. Keep some of them to pay for transaction fees . To vote with your tokens, they must be wrapped before the proposal is submitted. The Flare Foundation announces proposals in advance, so that users can read them and wrap their tokens if they have to. Vote Transfer Votes can be transferred to another account while the wrapped tokens remain in your possession. Being able to transfer votes is useful, for example, if you have wrapped tokens in multiple self-custody wallets, because voting can then be simplified by transferring all the votes to a single wallet and voting from there. Votes can only be transferred to one address, but it can receive votes from multiple addresses. Received votes cannot be transferred again to a third address. Once activated, vote transfers always send 100% of an account's votes to the selected address and remain active until they are canceled. As an example, if you have 100 $WSGB before a proposal and you activate the transfer, you will transfer 100 votes. If you later add 100 more $WSGB , for the next proposal you will automatically transfer 200 votes, since the transfer remains active until you cancel it. The following is a more complex example, showing the changes produced by vote transfers, and token wrapping and unwrapping on Songbird: Changes in the number of votes on Songbird. Note Transferring votes has no connection with FTSO delegation: Wrapped tokens can be delegated to an FTSO data provider and at the same time the votes they grant can be transferred to a different address. The Vote Count Block # Since the amount of wrapped tokens an account holds varies over time, a snapshot of all accounts is taken before each voting period starts. The amount of wrapped tokens held by an account at the snapshot then dictates the number of votes available later. The block at which the snapshot is taken is called the vote count block . To encourage users to use their tokens and keep them in the network, instead of just acquiring them for voting and then disposing of them, the vote count block is randomly selected. The next section details when this happens. Voting Process # The image in this section shows the voting process, which includes several conditions: Threshold condition : A minimum quorum must be reached, meaning that enough votes must be cast, or no minimum quorum is required. Majority condition : More than 50% of the votes cast, must be for or against the proposal. Voting process. Announcement : The Flare Foundation publishes the proposal online and announces it through social media channels (linked on the footer of this page) and the Flare website . Notice period : Once the proposal is published, the Flare Foundation allows a notice period before voting can start, typically lasting one week. During this time the proposal can be discussed, clarified, commented on, and even cancelled if serious issues are found with it. For security reasons only, the Foundation may reduce the timeframe of this period. Block selection period : The vote count block is selected at a random time during this period. The duration of this period is also random. Warning If you need to wrap tokens, do so before this period starts since tokens wrapped after the selected vote count block will not result in additional votes. Voting period : The proposal is submitted to the Flare Portal , and it is immediately available for voting. Voting concludes after a week, and final results are presented on the portal. Voting Outcomes # FIPs # Voting on FIPs is acceptance-based. For an FIP to be accepted, a simple majority of the votes cast must be in favor of it. No minimum quorum is required. Therefore, an FIP will be rejected only if less than half of the cast votes are for it. STPs # Voting on STPs is rejection-based. For an STP to be rejected, both of the following conditions must be true: Threshold condition : The minimum quorum is at least 75% of all $SGB tokens circulation (excluding the Flare Foundation's tokens) at the vote count block . Note that the quorum is specified as a fraction of the circulating native $SGB tokens instead of the wrapped tokens $WSGB used for voting. This measure tries, again, to encourage users to wrap their tokens and use them in the network. Majority condition : More than 50% of the votes cast, must be against the proposal. Therefore, an STP will be accepted if the quorum threshold is not reached or if less than half of the cast votes are against it. Execution # Once a proposal is accepted, Flare's governance contracts allow for its automatic execution via a contract call. However, some proposals might require changes that are not implementable through a smart contract and therefore automatic execution is disabled for them. Both FIPs and STPs are manually executed by the Flare Foundation. Related User Guides # Voting","title":"Governance"},{"location":"tech/governance/#governance","text":"","title":"Governance"},{"location":"tech/governance/#introduction","text":"Flare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the Flare and Songbird networks, making governance an important element of decentralization. This process enables the Flare Foundation and Flare and Songbird community members to: Propose policy changes. Vote on them. Execute them if accepted. The following sections detail the different kinds of proposals Flare allows and the process for each of them. If you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the Voting User Guide .","title":"Introduction"},{"location":"tech/governance/#flares-governance","text":"Excluding the testnets Coston and Coston2, Flare currently has two networks: Flare and Songbird. Moreover, two kinds of proposals are planned, depending on who initiates them: those proposed by the community and those proposed by the Flare Foundation. This situation leads to four types of proposals, of which only two are currently supported and detailed next.","title":"Flare's Governance"},{"location":"tech/governance/#flare-improvement-proposals-and-songbird-test-proposals","text":"Flare Improvement Proposals (FIPs) and Songbird Test Proposals (STPs) are initiated by the Flare Foundation and are aimed at improving the Flare and Songbird networks. Community-initiated proposals will be supported later. To increase its stability, FIPs are rejected by default, meaning that they are accepted only if enough votes are cast in their favor. To increase the swiftness at which new proposals can be tested on Songbird, STPs are accepted by default, meaning that they are rejected only if enough votes are cast against them. See Voting Outcomes below for more details.","title":"Flare Improvement Proposals and Songbird Test Proposals"},{"location":"tech/governance/#who-votes","text":"To vote on a proposal on a network, you must have the valid wrapped token: Network Proposal Type Token Wrapped Token Flare FIP $FLR $WFLR Songbird STP $SGB $WSGB Important Available votes depend on the amount of valid wrapped tokens you have, not the native tokens. Therefore, remember to wrap your tokens . Don't wrap all your tokens. Keep some of them to pay for transaction fees . To vote with your tokens, they must be wrapped before the proposal is submitted. The Flare Foundation announces proposals in advance, so that users can read them and wrap their tokens if they have to. Vote Transfer Votes can be transferred to another account while the wrapped tokens remain in your possession. Being able to transfer votes is useful, for example, if you have wrapped tokens in multiple self-custody wallets, because voting can then be simplified by transferring all the votes to a single wallet and voting from there. Votes can only be transferred to one address, but it can receive votes from multiple addresses. Received votes cannot be transferred again to a third address. Once activated, vote transfers always send 100% of an account's votes to the selected address and remain active until they are canceled. As an example, if you have 100 $WSGB before a proposal and you activate the transfer, you will transfer 100 votes. If you later add 100 more $WSGB , for the next proposal you will automatically transfer 200 votes, since the transfer remains active until you cancel it. The following is a more complex example, showing the changes produced by vote transfers, and token wrapping and unwrapping on Songbird: Changes in the number of votes on Songbird. Note Transferring votes has no connection with FTSO delegation: Wrapped tokens can be delegated to an FTSO data provider and at the same time the votes they grant can be transferred to a different address.","title":"Who Votes"},{"location":"tech/governance/#the-vote-count-block","text":"Since the amount of wrapped tokens an account holds varies over time, a snapshot of all accounts is taken before each voting period starts. The amount of wrapped tokens held by an account at the snapshot then dictates the number of votes available later. The block at which the snapshot is taken is called the vote count block . To encourage users to use their tokens and keep them in the network, instead of just acquiring them for voting and then disposing of them, the vote count block is randomly selected. The next section details when this happens.","title":"The Vote Count Block"},{"location":"tech/governance/#voting-process","text":"The image in this section shows the voting process, which includes several conditions: Threshold condition : A minimum quorum must be reached, meaning that enough votes must be cast, or no minimum quorum is required. Majority condition : More than 50% of the votes cast, must be for or against the proposal. Voting process. Announcement : The Flare Foundation publishes the proposal online and announces it through social media channels (linked on the footer of this page) and the Flare website . Notice period : Once the proposal is published, the Flare Foundation allows a notice period before voting can start, typically lasting one week. During this time the proposal can be discussed, clarified, commented on, and even cancelled if serious issues are found with it. For security reasons only, the Foundation may reduce the timeframe of this period. Block selection period : The vote count block is selected at a random time during this period. The duration of this period is also random. Warning If you need to wrap tokens, do so before this period starts since tokens wrapped after the selected vote count block will not result in additional votes. Voting period : The proposal is submitted to the Flare Portal , and it is immediately available for voting. Voting concludes after a week, and final results are presented on the portal.","title":"Voting Process"},{"location":"tech/governance/#voting-outcomes","text":"","title":"Voting Outcomes"},{"location":"tech/governance/#fips","text":"Voting on FIPs is acceptance-based. For an FIP to be accepted, a simple majority of the votes cast must be in favor of it. No minimum quorum is required. Therefore, an FIP will be rejected only if less than half of the cast votes are for it.","title":"FIPs"},{"location":"tech/governance/#stps","text":"Voting on STPs is rejection-based. For an STP to be rejected, both of the following conditions must be true: Threshold condition : The minimum quorum is at least 75% of all $SGB tokens circulation (excluding the Flare Foundation's tokens) at the vote count block . Note that the quorum is specified as a fraction of the circulating native $SGB tokens instead of the wrapped tokens $WSGB used for voting. This measure tries, again, to encourage users to wrap their tokens and use them in the network. Majority condition : More than 50% of the votes cast, must be against the proposal. Therefore, an STP will be accepted if the quorum threshold is not reached or if less than half of the cast votes are against it.","title":"STPs"},{"location":"tech/governance/#execution","text":"Once a proposal is accepted, Flare's governance contracts allow for its automatic execution via a contract call. However, some proposals might require changes that are not implementable through a smart contract and therefore automatic execution is disabled for them. Both FIPs and STPs are manually executed by the Flare Foundation.","title":"Execution"},{"location":"tech/governance/#related-user-guides","text":"Voting","title":"Related User Guides"},{"location":"tech/personal-delegation-account/","text":"Personal Delegation Accounts # Flare token holders are eligible to receive a number of rewards, for example through FTSO Delegation . The Flare network offers the option to set up Personal Delegation Accounts (PDAs) to temporarily receive and store rewards to track which funds are from rewards, for example, for personal or tax purposes. In certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate. Each Flare address can be associated with one PDA, which behaves like a regular account in many respects. For example, it can receive funds from any address. Like regular accounts, it is under control of the owner and can perform functions such as delegation and claiming. Here are some of the differences from a regular account: A PDA cannot have another PDA of its own. PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's). A PDA automatically converts any $FLR tokens transferred to it to wrapped Flare tokens ( $WFLR ), which are more useful for functions such as delegation. Only the owner of the main account can transfer funds from the PDA and only to the main account. When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA. Warning The Flare Foundation is not liable for any damages, especially pertaining to tax related issues when using this service. Check your local tax laws. Developing PDA functionality For information on how to develop a PDA, or how to write an application that supports a PDA, see Personal Delegation Accounts in the Developer section. Related User Guides # Managing your PDA Related Developer Docs # Managing PDAs in applications","title":"Personal Delegation Accounts"},{"location":"tech/personal-delegation-account/#personal-delegation-accounts","text":"Flare token holders are eligible to receive a number of rewards, for example through FTSO Delegation . The Flare network offers the option to set up Personal Delegation Accounts (PDAs) to temporarily receive and store rewards to track which funds are from rewards, for example, for personal or tax purposes. In certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate. Each Flare address can be associated with one PDA, which behaves like a regular account in many respects. For example, it can receive funds from any address. Like regular accounts, it is under control of the owner and can perform functions such as delegation and claiming. Here are some of the differences from a regular account: A PDA cannot have another PDA of its own. PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's). A PDA automatically converts any $FLR tokens transferred to it to wrapped Flare tokens ( $WFLR ), which are more useful for functions such as delegation. Only the owner of the main account can transfer funds from the PDA and only to the main account. When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA. Warning The Flare Foundation is not liable for any damages, especially pertaining to tax related issues when using this service. Check your local tax laws. Developing PDA functionality For information on how to develop a PDA, or how to write an application that supports a PDA, see Personal Delegation Accounts in the Developer section.","title":"Personal Delegation Accounts"},{"location":"tech/personal-delegation-account/#related-user-guides","text":"Managing your PDA","title":"Related User Guides"},{"location":"tech/personal-delegation-account/#related-developer-docs","text":"Managing PDAs in applications","title":"Related Developer Docs"},{"location":"tech/state-connector/","text":"State Connector # Introduction # The State Connector is a smart contract running on the Flare network that allows anyone to query non-changing, verifiable information (such as blockchain or geographic data) from outside the Flare network . Data that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the State Connector. The State Connector accesses data in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). This is accomplished by using a set of independent attestation providers which fetch the required information from the world and deliver it to the Flare network. The State Connector smart contract then checks if there is enough consensus among the received answers and publishes the results if so. As an added security measure, individual validators can also define local attestation providers which, when in disagreement with the rest, cause the validator to branch into an idle, safe state while the situation is resolved. The State Connector. The State Connector can, for instance, check whether a deposit has been made on another blockchain , opening the door to more advanced mechanisms like the FAsset or the Layer Cake bridges. This page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed. Procedure Overview # This is how user queries are processed. The following sections contain more details. State Connector procedure overview. 1. Request # Anybody, be it a smart contract running on Flare or an application, can request the attestation of a specific event from the State Connector. Requests are yes/no questions regarding things that happened outside the Flare network, for example, \"Has transaction 0xABC been confirmed on the Bitcoin network enough times?\". The answers, though, might contain any kind of additional data attached, like the content of transaction 0xABC, for example. Requests must adhere to one of the available request types , which have been designed to be strictly decidable , i.e., the answers are objective and cannot be argued. Otherwise, queries like \"What is the weather like in Paris?\" would have a hard time reaching consensus among the different attestation providers. Section Adding New Attestation Types below contains more details. Making a request (for App developers) Make your requests using the requestAttestations method (#2) of the StateConnector contract : function requestAttestations ( bytes calldata data ) external ; The requestAttestations method has a single parameter, data , which is a byte array with a content that depends on the desired request type . You can learn how to build this array in the state-connector-attestation-types repository . 2. Request forwarding # The State Connector simply forwards the request to all connected attestation providers through an EVM event. Therefore, the request is not stored on the blockchain and its gas cost is very low for the requester. 3. Data retrieval # Attestation providers fetch the requested data by means that depend on the type of attestation, for example, retrieving data from another blockchain or public API. Keep in mind that attestation providers are not controlled by Flare in any way. Anybody can listen to the request events and provide answers using any combination of hardware, software, and code they see fit. 4. Attestation # To prevent attestation providers from peeking at each other's answers, these are submitted in a \"Commit and Reveal\" fashion called the CCCR protocol and detailed below. Submitting an attestation (For attestation provider developers) Attestation providers use the submitAttestation method (#3) of the StateConnector contract : function submitAttestation ( uint256 _bufferNumber , bytes32 _commitHash , bytes32 _merkleRoot , bytes32 _randomNumber ) external returns ( bool _isInitialBufferSlot ); Keep reading to understand the meaning of the parameters. More information in the Attestation Client repository . 5. Consensus # If at least 50% of the attestation providers submitted the same answer, it is made public. Otherwise, no consensus is achieved : requests remain unanswered and must be issued again. The answers are stored in the State Connector smart contract for a week , where anybody can read them, including the original requester. Retrieving your request's answer (for App developers) To retrieve the stored answers just read the merkleRoots public array (#8) in the StateConnector contract . More information on how to retrieve a particular answer in the State Connector contract source code . As shown below, multiple answers are actually packed into a single Merkle root. The Attestation Packing section explains how to retrieve an individual answer. Attestation Protocols # For simplicity, the above description omitted two very important mechanisms , reviewed here. The main one is Attestation packing , which decouples the number of requests from the number of answers, effectively providing unbounded scalability. It requires requests to be first collected and then answered all at once , so a protocol called CCCR is used. Overlapped CCCR Protocol # Requests and answers are submitted sequentially in attestation rounds . Each attestation round has 4 consecutive phases, called Collect, Choose, Commit and Reveal. Phases happen in 90-second windows, and the Choose and Commit phases share the same window, so a whole attestation round takes 4.5 minutes. The Collect-Choose-Commit-Reveal (CCCR) protocol. Collect phase : Users send their requests to the State Connector contract which forwards them to every attestation provider. Choose phase : Attestation Providers vote on which requests they will be able to answer in the current round. Commit phase : Attestation providers send obfuscated answers to the State Connector, so they cannot cheat by peeking at each other's submissions. Reveal phase : Attestation providers send the deobfuscation key so their previous answers are revealed. When all data is available, answers are made public if there is enough consensus. The CCCR protocol is akin to making submissions in a closed envelope which is not opened until all submissions are received. Results are available at the end of the Reveal phase, so the answer to a particular request can take anywhere from 3 to 4.5 minutes , depending on the time in which the request was made inside the Collect phase. Furthermore, the phases of the CCCR protocol are actually overlapped , so while requests are being collected for round \\((n+2)\\) , answers are being simultaneously committed for the previous round \\((n+1)\\) , and revealed for the round prior to that \\((n)\\) . The CCCR protocol with overlapped phases. This means that new requests can be made without waiting for the previous ones to be completed. Attestation Packing # Each round, attestation providers build a Merkle tree with the hashes of all valid answers to the requests that were agreed upon during the \"Choose\" phase . The obtained Merkle root is then called the Attestation Proof , since it is proof of the presence of each individual answer. Finally, the attestation proof is submitted to the State Connector for consensus evaluation. Attestation Proof packing using a Merkle tree. This allows any number of requests to be answered with a single hash , greatly improving scalability . Furthermore, the gas cost for attestation providers is constant each round, no matter how many requests they are answering. A request is only valid (and therefore added to the proof) if it is well-formed and it matches reality . Different providers might have different views on what reality is, and this is why the State Connector runs a consensus algorithm on the received answers. Additionally, the allowed request types are carefully designed to minimize the probability of contention . For example, requiring some time for transactions to settle before inquiring about them, and forcing requests to include the hash of a later block that confirms the transaction. Attestation providers keep the actual retrieved data for a week, in case it contains additional information beyond the yes/no result. Users can request this data directly from the providers through the Proof API . Note Please note that this data is safe to use even though it is obtained directly from the provider, because its hash is consistent with the Attestation Proof agreed upon by the State Connector's consensus. See the \"Proof unpacking\" box below to learn how to verify the data. Additional points worth noting: If two attestation providers observe a different validity for any of the requests in the round, they will submit a completely different Attestation Proof. Attestation providers must answer all agreed-upon queries in the round or abstain from participating in the round , otherwise, their Merkle tree root will not match other providers and will probably be discarded by consensus. Hashes are sorted before being added to the tree, just to have a consistent ordering (albeit arbitrary). The exact way in which the root hash is calculated can be changed without impacting the State Connector contract, which will continue to vote only on the hash value. Proof Unpacking (for App developers) The procedure for apps to check whether the State Connector answered yes or no to their request is detailed in the Attestation Client repository . What follows is an illustrative summary. The basic idea is that you must retrieve all data (both requests and answers) for the round from an attestation provider. You then rebuild the Merkle tree with this data and check that it matches the Attestation Proof provided by the State Connector. Proof unpacking. In the attestation round after you made the request (3 attestation phases, so from 3 to 4.5 minutes) the Attestation Proof for the round should be available in the State Connector. Retrieve it using method getAttestation (#7) of the StateConnector contract . Select any attestation provider you want and use the Proof API path api/proof/votes-for-round/{roundId} to retrieve all data for the round . Rebuild the Merkle tree for the retrieved data. There are tools to help you, like the MerkleTree.ts library. Check that the tree's root matches the Attestation Proof from step 1. If it does not match, this provider did not submit the answer agreed by the majority. Choose another provider in step 2. Conversely, you can use the api/proof/get-specific-proof API in step 2 which does steps 2, 3 and 4 for you. This API returns the JSON response data, including the attestation proof, if the attestation request was successfully verified in the given round. Now that you know that the retrieved data has been agreed upon by the consensus, you can use it. Look for your request inside the returned data . If it is not present, your request was deemed invalid (for example, the queried transaction was not present). Otherwise, your request is valid and you can find any extra information about it in the data array. Branching Protocol # Besides the consensus algorithm that runs on all received attestations, the State Connector provides one further security mechanism : the ability of any individual validator node to fork and halt execution if attestation providers specially trusted by it disagree with the majority. Attestation Provider Sets # To achieve this, two sets of attestation providers are defined: Default attestation providers set Anybody can submit attestations to the State Connector, but the contract will only accept submissions from attestation providers in the default set . This list was managed by Flare at launch and later became completely decentralized (see the section Becoming an Attestation Provider for more information). Every validator node in the Flare network relies on this set. Local attestation providers set Additionally, each node operator can provide a list of local attestation providers to be accepted besides the ones from the default set. Local providers are the same kind of nodes as default providers, and they are treated exactly the same by the State Connector. Furthermore, providers can belong to both sets. Default and Local attestation providers. Then, for an attestation round to succeed these three conditions must be met: The default set must agree on a result (50% consensus inside the set). The local set must agree on a result too (50% consensus inside the set). Both results must match . Otherwise, the round is undecided and no answer is made public. This gives local attestation providers the capacity to stop results from being approved if they don't agree with their own observations. Ideally, local providers are managed by the same entity controlling the validator node using them, so they can be trusted implicitly . As a consequence of different validators using different attestation providers, sometimes State Connector queries can get different results on some validators, which naturally leads to chain forks . Typically, blockchains allow every branch in a fork to coexist and grow independently , until the discrepancy is detected and resolved. At that point, any branches deemed invalid are removed and all the validators that were following them experience a rollback : All transactions that happened after the fork are reverted and the state of those validators is synchronized with the rest of the network. When dealing with forks caused by the State Connector, the Flare network implements an extra security measure : Validators whose local attestation providers disagree with the default set halt execution after the fork , ensuring that they will not suffer any rollback once the fork is resolved. In other words, these validators remain in a safe state in which the disputed query is undecided and therefore no action is taken based on it. Example State Connector forks. In the example picture , all validator nodes use the attestation providers from the default set (not shown), but validators on the rightmost column, additionally, employ local providers . One of them returns a different answer for one of the queries, which leads to a fork of the chain since that validator's state does not match the rest of the network (the divergent ledger, depicted in red). The next section shows how forks are resolved and halted nodes restarted. Branch Resolution # The two states of the branching protocol. The picture above shows the state of the network after a fork. The default network state is the one followed by validators which only use the default set of attestation providers . The alternate network state is where validators go if they use local attestation providers , and they disagree with the default set. In the alternate state no queries are answered and no blocks are produced , so it is a safe state for validators to wait for forks to be resolved. This resolution must come from operators when they are alerted that a validator node has stopped. To understand how to do this, note that attestations are designed to be objectively decidable , meaning that in the event of a fork one branch matches reality and the other does not . There are therefore only two ways to resolve a fork: When local providers are wrong : The operator of the separated validator needs to find out why the local attestation providers failed and either fix them or remove them from the local set of the validator. Once this is fixed, the node simply rewinds its state to where it split and quickly fast-forward to rejoin the default state. Fork resolution when local providers are wrong. Note that no transactions need to be rolled back , on either branch. In the event of this kind of fork, dapps depending on information from a separated validator just have to wait longer to get their result. When the default set is wrong : First off, this is a very delicate situation and it should be rare . The default set uses consensus among attestation providers which have been chosen due to their merits as FTSO data providers. The fact that more than 50% of them are reporting data inconsistent with reality can be considered a 51% attack . The operator of the separated validator, upon convincing themselves that their branch is the correct one (it matches reality) they need to bring the fork to the attention of the misbehaving attestation providers' operators. All validators in the default state then need to roll back to the last correct state (reverting transactions) and continue from there on the forked branch, which becomes the new default state. Fork resolution when the default set is wrong. Note that stopped nodes can resume now, and they never had to roll back any transaction . In summary, validators using at least one reliable local attestation provider do not have to worry about rollbacks, even in the face of 51% attacks . Becoming an Attestation Provider # Anyone may operate an attestation provider without any capital requirement (see the attestation-client repository for deployment information), which can readily be used as a local provider on validators that trust it. To be included in the default set , though, the same operator must run one of the top-performing FTSO data providers to prove its commitment to the network's well-being. More details will be added soon. Adding New Attestation Types # New real-world event-type integrations are introduced to the State Connector via acceptance by the default attestation providers, without requiring any changes to the core voting or branching protocols described above. This enables rapid deployment of new use-cases without any validator-level code changes. See the state-connector-attestation-types repository for more information.","title":"State Connector"},{"location":"tech/state-connector/#state-connector","text":"","title":"State Connector"},{"location":"tech/state-connector/#introduction","text":"The State Connector is a smart contract running on the Flare network that allows anyone to query non-changing, verifiable information (such as blockchain or geographic data) from outside the Flare network . Data that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the State Connector. The State Connector accesses data in a decentralized manner (no single party is in control of the process) and securely (it takes a lot of effort to disrupt the process). This is accomplished by using a set of independent attestation providers which fetch the required information from the world and deliver it to the Flare network. The State Connector smart contract then checks if there is enough consensus among the received answers and publishes the results if so. As an added security measure, individual validators can also define local attestation providers which, when in disagreement with the rest, cause the validator to branch into an idle, safe state while the situation is resolved. The State Connector. The State Connector can, for instance, check whether a deposit has been made on another blockchain , opening the door to more advanced mechanisms like the FAsset or the Layer Cake bridges. This page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.","title":"Introduction"},{"location":"tech/state-connector/#procedure-overview","text":"This is how user queries are processed. The following sections contain more details. State Connector procedure overview.","title":"Procedure Overview"},{"location":"tech/state-connector/#1-request","text":"Anybody, be it a smart contract running on Flare or an application, can request the attestation of a specific event from the State Connector. Requests are yes/no questions regarding things that happened outside the Flare network, for example, \"Has transaction 0xABC been confirmed on the Bitcoin network enough times?\". The answers, though, might contain any kind of additional data attached, like the content of transaction 0xABC, for example. Requests must adhere to one of the available request types , which have been designed to be strictly decidable , i.e., the answers are objective and cannot be argued. Otherwise, queries like \"What is the weather like in Paris?\" would have a hard time reaching consensus among the different attestation providers. Section Adding New Attestation Types below contains more details. Making a request (for App developers) Make your requests using the requestAttestations method (#2) of the StateConnector contract : function requestAttestations ( bytes calldata data ) external ; The requestAttestations method has a single parameter, data , which is a byte array with a content that depends on the desired request type . You can learn how to build this array in the state-connector-attestation-types repository .","title":"1. Request"},{"location":"tech/state-connector/#2-request-forwarding","text":"The State Connector simply forwards the request to all connected attestation providers through an EVM event. Therefore, the request is not stored on the blockchain and its gas cost is very low for the requester.","title":"2. Request forwarding"},{"location":"tech/state-connector/#3-data-retrieval","text":"Attestation providers fetch the requested data by means that depend on the type of attestation, for example, retrieving data from another blockchain or public API. Keep in mind that attestation providers are not controlled by Flare in any way. Anybody can listen to the request events and provide answers using any combination of hardware, software, and code they see fit.","title":"3. Data retrieval"},{"location":"tech/state-connector/#4-attestation","text":"To prevent attestation providers from peeking at each other's answers, these are submitted in a \"Commit and Reveal\" fashion called the CCCR protocol and detailed below. Submitting an attestation (For attestation provider developers) Attestation providers use the submitAttestation method (#3) of the StateConnector contract : function submitAttestation ( uint256 _bufferNumber , bytes32 _commitHash , bytes32 _merkleRoot , bytes32 _randomNumber ) external returns ( bool _isInitialBufferSlot ); Keep reading to understand the meaning of the parameters. More information in the Attestation Client repository .","title":"4. Attestation"},{"location":"tech/state-connector/#5-consensus","text":"If at least 50% of the attestation providers submitted the same answer, it is made public. Otherwise, no consensus is achieved : requests remain unanswered and must be issued again. The answers are stored in the State Connector smart contract for a week , where anybody can read them, including the original requester. Retrieving your request's answer (for App developers) To retrieve the stored answers just read the merkleRoots public array (#8) in the StateConnector contract . More information on how to retrieve a particular answer in the State Connector contract source code . As shown below, multiple answers are actually packed into a single Merkle root. The Attestation Packing section explains how to retrieve an individual answer.","title":"5. Consensus"},{"location":"tech/state-connector/#attestation-protocols","text":"For simplicity, the above description omitted two very important mechanisms , reviewed here. The main one is Attestation packing , which decouples the number of requests from the number of answers, effectively providing unbounded scalability. It requires requests to be first collected and then answered all at once , so a protocol called CCCR is used.","title":"Attestation Protocols"},{"location":"tech/state-connector/#overlapped-cccr-protocol","text":"Requests and answers are submitted sequentially in attestation rounds . Each attestation round has 4 consecutive phases, called Collect, Choose, Commit and Reveal. Phases happen in 90-second windows, and the Choose and Commit phases share the same window, so a whole attestation round takes 4.5 minutes. The Collect-Choose-Commit-Reveal (CCCR) protocol. Collect phase : Users send their requests to the State Connector contract which forwards them to every attestation provider. Choose phase : Attestation Providers vote on which requests they will be able to answer in the current round. Commit phase : Attestation providers send obfuscated answers to the State Connector, so they cannot cheat by peeking at each other's submissions. Reveal phase : Attestation providers send the deobfuscation key so their previous answers are revealed. When all data is available, answers are made public if there is enough consensus. The CCCR protocol is akin to making submissions in a closed envelope which is not opened until all submissions are received. Results are available at the end of the Reveal phase, so the answer to a particular request can take anywhere from 3 to 4.5 minutes , depending on the time in which the request was made inside the Collect phase. Furthermore, the phases of the CCCR protocol are actually overlapped , so while requests are being collected for round \\((n+2)\\) , answers are being simultaneously committed for the previous round \\((n+1)\\) , and revealed for the round prior to that \\((n)\\) . The CCCR protocol with overlapped phases. This means that new requests can be made without waiting for the previous ones to be completed.","title":"Overlapped CCCR Protocol"},{"location":"tech/state-connector/#attestation-packing","text":"Each round, attestation providers build a Merkle tree with the hashes of all valid answers to the requests that were agreed upon during the \"Choose\" phase . The obtained Merkle root is then called the Attestation Proof , since it is proof of the presence of each individual answer. Finally, the attestation proof is submitted to the State Connector for consensus evaluation. Attestation Proof packing using a Merkle tree. This allows any number of requests to be answered with a single hash , greatly improving scalability . Furthermore, the gas cost for attestation providers is constant each round, no matter how many requests they are answering. A request is only valid (and therefore added to the proof) if it is well-formed and it matches reality . Different providers might have different views on what reality is, and this is why the State Connector runs a consensus algorithm on the received answers. Additionally, the allowed request types are carefully designed to minimize the probability of contention . For example, requiring some time for transactions to settle before inquiring about them, and forcing requests to include the hash of a later block that confirms the transaction. Attestation providers keep the actual retrieved data for a week, in case it contains additional information beyond the yes/no result. Users can request this data directly from the providers through the Proof API . Note Please note that this data is safe to use even though it is obtained directly from the provider, because its hash is consistent with the Attestation Proof agreed upon by the State Connector's consensus. See the \"Proof unpacking\" box below to learn how to verify the data. Additional points worth noting: If two attestation providers observe a different validity for any of the requests in the round, they will submit a completely different Attestation Proof. Attestation providers must answer all agreed-upon queries in the round or abstain from participating in the round , otherwise, their Merkle tree root will not match other providers and will probably be discarded by consensus. Hashes are sorted before being added to the tree, just to have a consistent ordering (albeit arbitrary). The exact way in which the root hash is calculated can be changed without impacting the State Connector contract, which will continue to vote only on the hash value. Proof Unpacking (for App developers) The procedure for apps to check whether the State Connector answered yes or no to their request is detailed in the Attestation Client repository . What follows is an illustrative summary. The basic idea is that you must retrieve all data (both requests and answers) for the round from an attestation provider. You then rebuild the Merkle tree with this data and check that it matches the Attestation Proof provided by the State Connector. Proof unpacking. In the attestation round after you made the request (3 attestation phases, so from 3 to 4.5 minutes) the Attestation Proof for the round should be available in the State Connector. Retrieve it using method getAttestation (#7) of the StateConnector contract . Select any attestation provider you want and use the Proof API path api/proof/votes-for-round/{roundId} to retrieve all data for the round . Rebuild the Merkle tree for the retrieved data. There are tools to help you, like the MerkleTree.ts library. Check that the tree's root matches the Attestation Proof from step 1. If it does not match, this provider did not submit the answer agreed by the majority. Choose another provider in step 2. Conversely, you can use the api/proof/get-specific-proof API in step 2 which does steps 2, 3 and 4 for you. This API returns the JSON response data, including the attestation proof, if the attestation request was successfully verified in the given round. Now that you know that the retrieved data has been agreed upon by the consensus, you can use it. Look for your request inside the returned data . If it is not present, your request was deemed invalid (for example, the queried transaction was not present). Otherwise, your request is valid and you can find any extra information about it in the data array.","title":"Attestation Packing"},{"location":"tech/state-connector/#branching-protocol","text":"Besides the consensus algorithm that runs on all received attestations, the State Connector provides one further security mechanism : the ability of any individual validator node to fork and halt execution if attestation providers specially trusted by it disagree with the majority.","title":"Branching Protocol"},{"location":"tech/state-connector/#attestation-provider-sets","text":"To achieve this, two sets of attestation providers are defined: Default attestation providers set Anybody can submit attestations to the State Connector, but the contract will only accept submissions from attestation providers in the default set . This list was managed by Flare at launch and later became completely decentralized (see the section Becoming an Attestation Provider for more information). Every validator node in the Flare network relies on this set. Local attestation providers set Additionally, each node operator can provide a list of local attestation providers to be accepted besides the ones from the default set. Local providers are the same kind of nodes as default providers, and they are treated exactly the same by the State Connector. Furthermore, providers can belong to both sets. Default and Local attestation providers. Then, for an attestation round to succeed these three conditions must be met: The default set must agree on a result (50% consensus inside the set). The local set must agree on a result too (50% consensus inside the set). Both results must match . Otherwise, the round is undecided and no answer is made public. This gives local attestation providers the capacity to stop results from being approved if they don't agree with their own observations. Ideally, local providers are managed by the same entity controlling the validator node using them, so they can be trusted implicitly . As a consequence of different validators using different attestation providers, sometimes State Connector queries can get different results on some validators, which naturally leads to chain forks . Typically, blockchains allow every branch in a fork to coexist and grow independently , until the discrepancy is detected and resolved. At that point, any branches deemed invalid are removed and all the validators that were following them experience a rollback : All transactions that happened after the fork are reverted and the state of those validators is synchronized with the rest of the network. When dealing with forks caused by the State Connector, the Flare network implements an extra security measure : Validators whose local attestation providers disagree with the default set halt execution after the fork , ensuring that they will not suffer any rollback once the fork is resolved. In other words, these validators remain in a safe state in which the disputed query is undecided and therefore no action is taken based on it. Example State Connector forks. In the example picture , all validator nodes use the attestation providers from the default set (not shown), but validators on the rightmost column, additionally, employ local providers . One of them returns a different answer for one of the queries, which leads to a fork of the chain since that validator's state does not match the rest of the network (the divergent ledger, depicted in red). The next section shows how forks are resolved and halted nodes restarted.","title":"Attestation Provider Sets"},{"location":"tech/state-connector/#branch-resolution","text":"The two states of the branching protocol. The picture above shows the state of the network after a fork. The default network state is the one followed by validators which only use the default set of attestation providers . The alternate network state is where validators go if they use local attestation providers , and they disagree with the default set. In the alternate state no queries are answered and no blocks are produced , so it is a safe state for validators to wait for forks to be resolved. This resolution must come from operators when they are alerted that a validator node has stopped. To understand how to do this, note that attestations are designed to be objectively decidable , meaning that in the event of a fork one branch matches reality and the other does not . There are therefore only two ways to resolve a fork: When local providers are wrong : The operator of the separated validator needs to find out why the local attestation providers failed and either fix them or remove them from the local set of the validator. Once this is fixed, the node simply rewinds its state to where it split and quickly fast-forward to rejoin the default state. Fork resolution when local providers are wrong. Note that no transactions need to be rolled back , on either branch. In the event of this kind of fork, dapps depending on information from a separated validator just have to wait longer to get their result. When the default set is wrong : First off, this is a very delicate situation and it should be rare . The default set uses consensus among attestation providers which have been chosen due to their merits as FTSO data providers. The fact that more than 50% of them are reporting data inconsistent with reality can be considered a 51% attack . The operator of the separated validator, upon convincing themselves that their branch is the correct one (it matches reality) they need to bring the fork to the attention of the misbehaving attestation providers' operators. All validators in the default state then need to roll back to the last correct state (reverting transactions) and continue from there on the forked branch, which becomes the new default state. Fork resolution when the default set is wrong. Note that stopped nodes can resume now, and they never had to roll back any transaction . In summary, validators using at least one reliable local attestation provider do not have to worry about rollbacks, even in the face of 51% attacks .","title":"Branch Resolution"},{"location":"tech/state-connector/#becoming-an-attestation-provider","text":"Anyone may operate an attestation provider without any capital requirement (see the attestation-client repository for deployment information), which can readily be used as a local provider on validators that trust it. To be included in the default set , though, the same operator must run one of the top-performing FTSO data providers to prove its commitment to the network's well-being. More details will be added soon.","title":"Becoming an Attestation Provider"},{"location":"tech/state-connector/#adding-new-attestation-types","text":"New real-world event-type integrations are introduced to the State Connector via acceptance by the default attestation providers, without requiring any changes to the core voting or branching protocols described above. This enables rapid deployment of new use-cases without any validator-level code changes. See the state-connector-attestation-types repository for more information.","title":"Adding New Attestation Types"},{"location":"tech/the-flaredrop/","text":"The FlareDrop # The FlareDrop, previously called the Delegation Incentive Pool in the FIP.01 , is a distribution method for the 24.25B remaining $FLR tokens after the original airdrop . It will last for 36 months and is destined for any holder of wrapped $FLR ( $WFLR ) that participates in the network as per the FIP.01. If you enabled your PDA and it contains $WFLR , it is also eligible to receive the FlareDrop distribution. Make sure to check both your Main Account and your Delegation Account for FlareDrop to claim. How Is the FlareDrop Distributed? # The FlareDrop is distributed monthly over 36 30-day bank months to those that wrap their $FLR tokens. Each of the first 35 monthly allocations constitute 2.37% of the total FlareDrop, and the last one 2.05%. The total amount of $WFLR is calculated each month, and the monthly allocation is distributed among all $WFLR holders proportionally to the sampled average of their $WFLR balance. Users then receive an amount equal to their month's sampled $WFLR holdings divided by the month's total $WFLR , multiplied by the monthly allocation. Calculating an address's sampled average balance As each bank month passes, the FlareDrop receives a trigger to choose 3 random blocks in the previous 23 days. The FlareDrop smart contract then finds the average of the total $WFLR reported in those blocks and determines each address's percentage of the FlareDrop. 3-week average of wrapped $FLR . Upon claiming, the entitlement is sent directly to the account you claimed from. It is sent as $FLR to your Main Account and as $WFLR to your Personal Delegation Account (PDA) . Each distribution expires two bank months and a week (67 days) after it becomes claimable and expired tokens are burned. To ensure having no effect on the amount of $FLR that each claiming address receives, Flare Foundation and team addresses opt out of the FlareDrop distribution. Two steps to ensure receiving all your $FLR ! You must: Wrap $FLR to receive it. Rewards are proportional to the $WFLR balance, not $FLR , so always wrap as much $FLR as you can! Wrapping has no downside: Wrapped tokens continue to be available for delegation and governance voting , for example, and they can be unwrapped at any time. Claim before the distribution expires. After the distribution becomes claimable, it expires in two bank months and a week (67 days). You can also enable automatic claiming to make sure you don't miss any FlareDrop! Autoclaiming will claim for both your main account and your PDA if you enabled it. Related User Guides # Claiming the FlareDrop Wrapping tokens Related Developer Docs # The FlareDrop","title":"The FlareDrop"},{"location":"tech/the-flaredrop/#the-flaredrop","text":"The FlareDrop, previously called the Delegation Incentive Pool in the FIP.01 , is a distribution method for the 24.25B remaining $FLR tokens after the original airdrop . It will last for 36 months and is destined for any holder of wrapped $FLR ( $WFLR ) that participates in the network as per the FIP.01. If you enabled your PDA and it contains $WFLR , it is also eligible to receive the FlareDrop distribution. Make sure to check both your Main Account and your Delegation Account for FlareDrop to claim.","title":"The FlareDrop"},{"location":"tech/the-flaredrop/#how-is-the-flaredrop-distributed","text":"The FlareDrop is distributed monthly over 36 30-day bank months to those that wrap their $FLR tokens. Each of the first 35 monthly allocations constitute 2.37% of the total FlareDrop, and the last one 2.05%. The total amount of $WFLR is calculated each month, and the monthly allocation is distributed among all $WFLR holders proportionally to the sampled average of their $WFLR balance. Users then receive an amount equal to their month's sampled $WFLR holdings divided by the month's total $WFLR , multiplied by the monthly allocation. Calculating an address's sampled average balance As each bank month passes, the FlareDrop receives a trigger to choose 3 random blocks in the previous 23 days. The FlareDrop smart contract then finds the average of the total $WFLR reported in those blocks and determines each address's percentage of the FlareDrop. 3-week average of wrapped $FLR . Upon claiming, the entitlement is sent directly to the account you claimed from. It is sent as $FLR to your Main Account and as $WFLR to your Personal Delegation Account (PDA) . Each distribution expires two bank months and a week (67 days) after it becomes claimable and expired tokens are burned. To ensure having no effect on the amount of $FLR that each claiming address receives, Flare Foundation and team addresses opt out of the FlareDrop distribution. Two steps to ensure receiving all your $FLR ! You must: Wrap $FLR to receive it. Rewards are proportional to the $WFLR balance, not $FLR , so always wrap as much $FLR as you can! Wrapping has no downside: Wrapped tokens continue to be available for delegation and governance voting , for example, and they can be unwrapped at any time. Claim before the distribution expires. After the distribution becomes claimable, it expires in two bank months and a week (67 days). You can also enable automatic claiming to make sure you don't miss any FlareDrop! Autoclaiming will claim for both your main account and your PDA if you enabled it.","title":"How Is the FlareDrop Distributed?"},{"location":"tech/the-flaredrop/#related-user-guides","text":"Claiming the FlareDrop Wrapping tokens","title":"Related User Guides"},{"location":"tech/the-flaredrop/#related-developer-docs","text":"The FlareDrop","title":"Related Developer Docs"},{"location":"tech/tokenomics/","text":"Tokenomics # Flare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3. These tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare. The adoption of FIP.01 on January 27, 2023 enabled this approach by changing the mechanism of the public token distribution. Token Allocation # At network genesis, 100 Billion $FLR tokens (100,000,000,000) were created. They have been allocated to the following groups. Note the delegation, claiming, and voting abilities of each, defined here: Can delegate : The entity can delegate tokens to the Flare Time Series Oracle to earn standard inflationary rewards. Can claim : The entity can wrap tokens to claim a portion of the FlareDrop . Can vote : The entity can use its tokens to participate in governance by voting on Flare Improvement Proposals. Flare Partners # Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Flare Networks Limited (FNL) FNL builds tools, applications, and solutions designed to unify the decentralized economy using Flare\u2019s native data infrastructure. They were the earliest Flare development partner and built the software that powers the Flare blockchain, which was subsequently handed off to the Flare Foundation to operate. 12,500,000,000 (12.5 billion) YES NO YES Flare VC Fund A proactive investment entity designed to catalyze ecosystem growth, diversity, and participation by providing funds to carefully selected projects and communities. Flare Foundation and Flare Networks Limited each provide 50% or 5.0B of these tokens. 10,000,000,000 (10 billion) With tokens from FNL only NO NO SUBTOTAL 22.5 Billion $FLR Flare Community # Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Flare Foundation (FF) The foundation is a non-profit responsible for operating the Flare network ecosystem. Tokens to be distributed to community projects via the Ecosystem Support Program. 9,787,578,628 (9.8 billion) NO NO NO Initial Token Distribution Airdrop of `$FLR` tokens to wallets that held `$XRP` tokens on December 12, 2020. 4,278,738,206 (4.3 billion) YES YES YES FlareDrop Public distribution allocated to incentivize network participation. Can be earned by `$FLR` holders who wrap their tokens over a 36-month distribution period. 24,246,183,166 (24.2 billion) YES YES YES Cross-chain Incentives Network participation incentive earned by users bringing cross-chain tokens to Flare. 20,000,000,000 (20 billion) YES YES YES SUBTOTAL 58.3 Billion $FLR Team, Advisors, and Backers # Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Founding Team The first team members who have been building Flare together since 2017. 7,000,000,000 (7 billion) YES NO YES Rest of Team Subsequent team members who have joined Flare in the intervening years. 1,500,000,000 (1.5 billion) YES NO YES Future Team Incentive pool for future recruits. 3,000,000,000 (3 billion) YES NO YES Advisors Reserved for strategic advisors. 2,000,000,000 (2 billion) YES YES YES Backers Contingent allocation for early backers of the project. 5,687,500,000 (5.7 billion) YES YES YES SUBTOTAL 19.2 Billion $FLR Inflation Amount # Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Inflation Monthly inflation amount that drives participation and supports decentralized third parties running core Flare infrastructure: Flare Time Series Oracle data providers (70%), network validators (20%), and State Connector attestation providers (10%). N/A YES YES YES High-Level View # The majority of tokens are destined for community ownership, whether by direct token distribution, network incentives, or through the Flare Foundation ecosystem programs. Initial token distribution: Macro view of total $FLR allocation. Token Description # $FLR is the transactional token for the Flare Network. Attribute Description Network Flare Token name Flare Ticker FLR Initial supply 100 Billion Decimals Up to 18 Genesis creation date July 14, 2022 Token Distribution Event (TDE) January 9, 2023 FIP.01 acceptance: January 27, 2023 Flare Token Utility # Flare is an EVM-based Layer 1 that gives developers decentralized access to data from other chains and the internet. This access enables new use cases and monetization models, while allowing apps to serve multiple chains through a single deployment. $FLR is the network token and provides support for each of these functions: Incentivized delegation to the Flare Time Series Oracle (FTSO) to support the provision of reliable decentralized data. Collateral within decentralized applications built on Flare blockchains (cross-chain or solely native). Participation within network governance . Transaction fees to prevent spam attacks. Public Distribution # Here are important highlights of the public token distribution, updated following approval of Flare Improvement Proposal 01 (FIP.01). The full details are available in the FIP.01 blog post . The 28,524,921,372 $FLR public distribution is split into two parts: The first 15%, the initial Airdrop, which equates to 4,278,738,206 $FLR , was distributed during the Token Distribution Event (TDE) on January 9, 2023 to wallets that held XRP on December 12, 2020. The remaining 85% or 24,246,183,166 $FLR , the FlareDrop , are being distributed over 36 monthly amounts directly to token holders who have wrapped their $FLR into $WFLR . There will be 35 monthly distributions of 2.37% of the total (676,040,637 $FLR ) and a final distribution of the remaining 2.05% of the total (584,760,871 $FLR ) in month 36. Inflation Calculation # Annual inflation is calculated based on circulating supply and changes as the first 3 years progress: 10% in year 1. 7% in year 2. 5% from year 3 onwards. Vesting Detail # Vesting occurs when the full rights to an asset are gradually acquired over a pre-determined schedule. One cannot exercise any of the rights to each portion of the asset until its agreed-upon vesting date, thus incentivizing participation and strengthening the community. Additionally, the future right to an asset cannot be taken away unless stipulated in the vesting agreement, such as the requirement for employee status on a vesting date. Flare tokens are subject to vesting schedules as follows. Entity $FLR Amount in Genesis Vesting Schedule Flare Networks Limited (FNL) 12.5 billion Subject to 36-month vesting schedule, with 15% on token distribution event (TDE) and the remainder vesting in 35 monthly amounts of 2.37% of the total and one final amount of 2.05% of the total in month 36. Flare VC Fund 10 billion Flare Foundation (FF) 9.8 billion Initial Token Distribution 4.3 billion The initial airdrop was completed during the token distribution event, January 9, 2023. FlareDrop 24.2 billion Subject to a 36-month vesting schedule, with the full amount vesting in 35 monthly amounts of 2.79% of the total and one final amount of 2.35% in month 36. Cross-chain Incentives 20 billion The lesser of 3% of circulating supply or 10% of the cross-chain incentive pool, calculated per annum and distributed pro rata per month. Founding Team 7 billion Subject to 36-month vesting schedule, with 15% on token distribution event (TDE) and the remainder vesting in 35 monthly amounts of 2.37% of the total, and one final amount of 2.05% of the total in month 36. No tokens permitted to be sold within the first 6 months. A maximum of 10% of vested tokens permitted to be sold within months 7-12. A maximum of 25% of total vested tokens (including any already sold) permitted to be sold within months 13-18. Rest of Team 1.5 billion Future Team 3 billion Advisors 2 billion Backers 5.7 billion Backers have different vesting schedules. Allocations are contingent upon certain conditions being met and are, therefore, not guaranteed. Inflation N/A Year 1: 10% of circulating supply calculated per annum and distributed pro rata per month. Year 2: 7% of circulating supply. Year 3+: 5% of circulating supply. Supply Metrics # The first three charts show month 0 $FLR data and the remaining charts show $FLR trends over 36 months and at 36 months. The charts visualize aspects of these metrics: Total Supply: Initial supply at genesis + inflation. Initial Supply: Unlocked distributed tokens + all locked tokens. 100B $FLR created at genesis. Circulating Supply: Unlocked distributed tokens. Tokens provided through the initial token distribution event, FTSO delegation rewards, and FlareDrops and vesting schedules. Liquid Supply: Sellable. Circulating Supply at liberty to be sold. $FLR token distribution. Example: The Flare team can't sell their tokens immediately, but they can use them to earn FTSO rewards. Their tokens are circulating, but not liquid. Month 0 $FLR # Circulating $FLR # The recipients of the initial token distribution (Airdrop) are the largest single group of token holders. These tokens are available for network participation. Please note that the Flare Foundation and Flare Networks Limited amounts also include the unlocked backers\u2019 tokens because this is before their distribution commences in month 6. Month 0: Circulating $FLR token distribution (12.0B $FLR ). Liquid $FLR # Although Flare team members can use their initial token distribution to participate fully in the network and support reliable FTSO data provision, they are restricted from selling any of the tokens they receive in the first 6 months, and no more than 25% within the first 18 months. As per the Circulating $FLR chart, the FF & FNL percentages include the unlocked but as yet undistributed backers\u2019 tokens. Month 0: Liquid $FLR token distribution (10.0B $FLR ). Total $FLR # 80.2% of the initial total distribution (100B at genesis) is permitted to vote in governance, leaving 19.8% that is not permitted to vote (Flare Foundation & Flare VC Fund). Month 0: Total $FLR token distribution (100B $FLR ). 36-Month $FLR # Circulating and Liquid $FLR # Once the 36-month token distribution is complete, there will be 93.9B $FLR liquid and circulating. Month 36: Circulating and liquid $FLR token distribution (93.9B $FLR ). Distribution Schedule # After the initial 15% distribution, the majority of entities receive the remainder of their allocation smoothly over 36 months. The tokens are available for network participation, including governance and delegation to FTSO, but they are not liquid. 36-month $FLR token distribution schedule. The slight bumps are due to the delayed distribution of backer tokens commencing in months 6 and 13. Liquid Supply # Due to the restrictions placed on team token sales described in the Liquid $FLR chart above, until month 19 there are fewer liquid tokens than there are tokens able to participate in governance and delegate to the FTSO. 36-month $FLR liquid token distribution schedule. Circulating Supply # After 36 months, 85% of $FLR will be circulating (93.9B of a total 110.1B $FLR ). $FLR token supply over 36 months. Vote Power # Vote Power is the weight applied to a community member's vote, proportional to the amount of wrapped Flare or Songbird tokens ( $WFLR or $WSGB ) it holds, plus any amount delegated to it. From day 1, the Token Distribution Event (TDE), Flare has had below 50% governance vote power, with this percentage decreasing further throughout the distribution period. Flare\u2019s vote power is calculated from the sum of unlocked tokens held by Flare Networks Limited (FNL) plus the team and advisors. 36 Month Trend: Vote power.","title":"Tokenomics"},{"location":"tech/tokenomics/#tokenomics","text":"Flare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3. These tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare. The adoption of FIP.01 on January 27, 2023 enabled this approach by changing the mechanism of the public token distribution.","title":"Tokenomics"},{"location":"tech/tokenomics/#token-allocation","text":"At network genesis, 100 Billion $FLR tokens (100,000,000,000) were created. They have been allocated to the following groups. Note the delegation, claiming, and voting abilities of each, defined here: Can delegate : The entity can delegate tokens to the Flare Time Series Oracle to earn standard inflationary rewards. Can claim : The entity can wrap tokens to claim a portion of the FlareDrop . Can vote : The entity can use its tokens to participate in governance by voting on Flare Improvement Proposals.","title":"Token Allocation"},{"location":"tech/tokenomics/#flare-partners","text":"Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Flare Networks Limited (FNL) FNL builds tools, applications, and solutions designed to unify the decentralized economy using Flare\u2019s native data infrastructure. They were the earliest Flare development partner and built the software that powers the Flare blockchain, which was subsequently handed off to the Flare Foundation to operate. 12,500,000,000 (12.5 billion) YES NO YES Flare VC Fund A proactive investment entity designed to catalyze ecosystem growth, diversity, and participation by providing funds to carefully selected projects and communities. Flare Foundation and Flare Networks Limited each provide 50% or 5.0B of these tokens. 10,000,000,000 (10 billion) With tokens from FNL only NO NO SUBTOTAL 22.5 Billion $FLR","title":"Flare Partners"},{"location":"tech/tokenomics/#flare-community","text":"Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Flare Foundation (FF) The foundation is a non-profit responsible for operating the Flare network ecosystem. Tokens to be distributed to community projects via the Ecosystem Support Program. 9,787,578,628 (9.8 billion) NO NO NO Initial Token Distribution Airdrop of `$FLR` tokens to wallets that held `$XRP` tokens on December 12, 2020. 4,278,738,206 (4.3 billion) YES YES YES FlareDrop Public distribution allocated to incentivize network participation. Can be earned by `$FLR` holders who wrap their tokens over a 36-month distribution period. 24,246,183,166 (24.2 billion) YES YES YES Cross-chain Incentives Network participation incentive earned by users bringing cross-chain tokens to Flare. 20,000,000,000 (20 billion) YES YES YES SUBTOTAL 58.3 Billion $FLR","title":"Flare Community"},{"location":"tech/tokenomics/#team-advisors-and-backers","text":"Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Founding Team The first team members who have been building Flare together since 2017. 7,000,000,000 (7 billion) YES NO YES Rest of Team Subsequent team members who have joined Flare in the intervening years. 1,500,000,000 (1.5 billion) YES NO YES Future Team Incentive pool for future recruits. 3,000,000,000 (3 billion) YES NO YES Advisors Reserved for strategic advisors. 2,000,000,000 (2 billion) YES YES YES Backers Contingent allocation for early backers of the project. 5,687,500,000 (5.7 billion) YES YES YES SUBTOTAL 19.2 Billion $FLR","title":"Team, Advisors, and Backers"},{"location":"tech/tokenomics/#inflation-amount","text":"Entity Total $FLR Allocation Can Delegate Can Claim the FlareDrop Can Vote Inflation Monthly inflation amount that drives participation and supports decentralized third parties running core Flare infrastructure: Flare Time Series Oracle data providers (70%), network validators (20%), and State Connector attestation providers (10%). N/A YES YES YES","title":"Inflation Amount"},{"location":"tech/tokenomics/#high-level-view","text":"The majority of tokens are destined for community ownership, whether by direct token distribution, network incentives, or through the Flare Foundation ecosystem programs. Initial token distribution: Macro view of total $FLR allocation.","title":"High-Level View"},{"location":"tech/tokenomics/#token-description","text":"$FLR is the transactional token for the Flare Network. Attribute Description Network Flare Token name Flare Ticker FLR Initial supply 100 Billion Decimals Up to 18 Genesis creation date July 14, 2022 Token Distribution Event (TDE) January 9, 2023 FIP.01 acceptance: January 27, 2023","title":"Token Description"},{"location":"tech/tokenomics/#flare-token-utility","text":"Flare is an EVM-based Layer 1 that gives developers decentralized access to data from other chains and the internet. This access enables new use cases and monetization models, while allowing apps to serve multiple chains through a single deployment. $FLR is the network token and provides support for each of these functions: Incentivized delegation to the Flare Time Series Oracle (FTSO) to support the provision of reliable decentralized data. Collateral within decentralized applications built on Flare blockchains (cross-chain or solely native). Participation within network governance . Transaction fees to prevent spam attacks.","title":"Flare Token Utility"},{"location":"tech/tokenomics/#public-distribution","text":"Here are important highlights of the public token distribution, updated following approval of Flare Improvement Proposal 01 (FIP.01). The full details are available in the FIP.01 blog post . The 28,524,921,372 $FLR public distribution is split into two parts: The first 15%, the initial Airdrop, which equates to 4,278,738,206 $FLR , was distributed during the Token Distribution Event (TDE) on January 9, 2023 to wallets that held XRP on December 12, 2020. The remaining 85% or 24,246,183,166 $FLR , the FlareDrop , are being distributed over 36 monthly amounts directly to token holders who have wrapped their $FLR into $WFLR . There will be 35 monthly distributions of 2.37% of the total (676,040,637 $FLR ) and a final distribution of the remaining 2.05% of the total (584,760,871 $FLR ) in month 36.","title":"Public Distribution"},{"location":"tech/tokenomics/#inflation-calculation","text":"Annual inflation is calculated based on circulating supply and changes as the first 3 years progress: 10% in year 1. 7% in year 2. 5% from year 3 onwards.","title":"Inflation Calculation"},{"location":"tech/tokenomics/#vesting-detail","text":"Vesting occurs when the full rights to an asset are gradually acquired over a pre-determined schedule. One cannot exercise any of the rights to each portion of the asset until its agreed-upon vesting date, thus incentivizing participation and strengthening the community. Additionally, the future right to an asset cannot be taken away unless stipulated in the vesting agreement, such as the requirement for employee status on a vesting date. Flare tokens are subject to vesting schedules as follows. Entity $FLR Amount in Genesis Vesting Schedule Flare Networks Limited (FNL) 12.5 billion Subject to 36-month vesting schedule, with 15% on token distribution event (TDE) and the remainder vesting in 35 monthly amounts of 2.37% of the total and one final amount of 2.05% of the total in month 36. Flare VC Fund 10 billion Flare Foundation (FF) 9.8 billion Initial Token Distribution 4.3 billion The initial airdrop was completed during the token distribution event, January 9, 2023. FlareDrop 24.2 billion Subject to a 36-month vesting schedule, with the full amount vesting in 35 monthly amounts of 2.79% of the total and one final amount of 2.35% in month 36. Cross-chain Incentives 20 billion The lesser of 3% of circulating supply or 10% of the cross-chain incentive pool, calculated per annum and distributed pro rata per month. Founding Team 7 billion Subject to 36-month vesting schedule, with 15% on token distribution event (TDE) and the remainder vesting in 35 monthly amounts of 2.37% of the total, and one final amount of 2.05% of the total in month 36. No tokens permitted to be sold within the first 6 months. A maximum of 10% of vested tokens permitted to be sold within months 7-12. A maximum of 25% of total vested tokens (including any already sold) permitted to be sold within months 13-18. Rest of Team 1.5 billion Future Team 3 billion Advisors 2 billion Backers 5.7 billion Backers have different vesting schedules. Allocations are contingent upon certain conditions being met and are, therefore, not guaranteed. Inflation N/A Year 1: 10% of circulating supply calculated per annum and distributed pro rata per month. Year 2: 7% of circulating supply. Year 3+: 5% of circulating supply.","title":"Vesting Detail"},{"location":"tech/tokenomics/#supply-metrics","text":"The first three charts show month 0 $FLR data and the remaining charts show $FLR trends over 36 months and at 36 months. The charts visualize aspects of these metrics: Total Supply: Initial supply at genesis + inflation. Initial Supply: Unlocked distributed tokens + all locked tokens. 100B $FLR created at genesis. Circulating Supply: Unlocked distributed tokens. Tokens provided through the initial token distribution event, FTSO delegation rewards, and FlareDrops and vesting schedules. Liquid Supply: Sellable. Circulating Supply at liberty to be sold. $FLR token distribution. Example: The Flare team can't sell their tokens immediately, but they can use them to earn FTSO rewards. Their tokens are circulating, but not liquid.","title":"Supply Metrics"},{"location":"tech/tokenomics/#month-0-flr","text":"","title":"Month 0 $FLR"},{"location":"tech/tokenomics/#circulating-flr","text":"The recipients of the initial token distribution (Airdrop) are the largest single group of token holders. These tokens are available for network participation. Please note that the Flare Foundation and Flare Networks Limited amounts also include the unlocked backers\u2019 tokens because this is before their distribution commences in month 6. Month 0: Circulating $FLR token distribution (12.0B $FLR ).","title":"Circulating $FLR"},{"location":"tech/tokenomics/#liquid-flr","text":"Although Flare team members can use their initial token distribution to participate fully in the network and support reliable FTSO data provision, they are restricted from selling any of the tokens they receive in the first 6 months, and no more than 25% within the first 18 months. As per the Circulating $FLR chart, the FF & FNL percentages include the unlocked but as yet undistributed backers\u2019 tokens. Month 0: Liquid $FLR token distribution (10.0B $FLR ).","title":"Liquid $FLR"},{"location":"tech/tokenomics/#total-flr","text":"80.2% of the initial total distribution (100B at genesis) is permitted to vote in governance, leaving 19.8% that is not permitted to vote (Flare Foundation & Flare VC Fund). Month 0: Total $FLR token distribution (100B $FLR ).","title":"Total $FLR"},{"location":"tech/tokenomics/#36-month-flr","text":"","title":"36-Month $FLR"},{"location":"tech/tokenomics/#circulating-and-liquid-flr","text":"Once the 36-month token distribution is complete, there will be 93.9B $FLR liquid and circulating. Month 36: Circulating and liquid $FLR token distribution (93.9B $FLR ).","title":"Circulating and Liquid $FLR"},{"location":"tech/tokenomics/#distribution-schedule","text":"After the initial 15% distribution, the majority of entities receive the remainder of their allocation smoothly over 36 months. The tokens are available for network participation, including governance and delegation to FTSO, but they are not liquid. 36-month $FLR token distribution schedule. The slight bumps are due to the delayed distribution of backer tokens commencing in months 6 and 13.","title":"Distribution Schedule"},{"location":"tech/tokenomics/#liquid-supply","text":"Due to the restrictions placed on team token sales described in the Liquid $FLR chart above, until month 19 there are fewer liquid tokens than there are tokens able to participate in governance and delegate to the FTSO. 36-month $FLR liquid token distribution schedule.","title":"Liquid Supply"},{"location":"tech/tokenomics/#circulating-supply","text":"After 36 months, 85% of $FLR will be circulating (93.9B of a total 110.1B $FLR ). $FLR token supply over 36 months.","title":"Circulating Supply"},{"location":"tech/tokenomics/#vote-power","text":"Vote Power is the weight applied to a community member's vote, proportional to the amount of wrapped Flare or Songbird tokens ( $WFLR or $WSGB ) it holds, plus any amount delegated to it. From day 1, the Token Distribution Event (TDE), Flare has had below 50% governance vote power, with this percentage decreasing further throughout the distribution period. Flare\u2019s vote power is calculated from the sum of unlocked tokens held by Flare Networks Limited (FNL) plus the team and advisors. 36 Month Trend: Vote power.","title":"Vote Power"},{"location":"tech/validators/","text":"Validator Nodes # Validator nodes are online servers running a blockchain's client software. They all keep a copy of the ledger and are constantly talking to each other to make sure the copies are consistent as new data is added. A network of validator nodes, each one with an identical copy of the ledger. The fact that the ledger is not under control of a single entity but distributed among a network of independent validators is what makes blockchains: Require less trust than traditional options. Censorship resistant. Byzantine fault tolerant . Validators agree on the state of the ledger using a consensus algorithm that varies for each blockchain. While the implementation of the groundbreaking FCP protocol is being completed, Flare is currently using a variant of Avalanche 's Snowman++ algorithm. In Avalanche's Snowman++, each round a validator is randomly selected to act as the leader and propose new blocks to be added to the ledger, which are then validated by the rest of nodes. To provide Sybil resistance , the probability of a node's being elected the leader is proportional to the node's stake , so this is effectively a Proof-of-Stake consensus. The shortcomings of Proof-of-stake are well known and include risk of centralization and the rich-get-richer effect , for example. To compensate for this, Flare's version of Snowman++ reduces the importance of a node's stake and introduces a meritocratic factor : All Flare validators are also FTSO Data Providers , so their performance in this role has an impact on their chance to become round leaders. More precisely, the probability \\(P\\) of being the leader depends both on a node's stake ( \\(VotePower\\) ) and on its performance as a Data Provider (evaluated through its \\(RewardRate\\) ) like this: \\[ P = \\log (VotePower) * RewardRate \\] And then normalized so the probabilities for all nodes add up to \\(1.0\\) . As it can be seen: The logarithm (which might be replaced by a square root or similar compressing function) reduces the importance of large stakes. Multiplying by the \\(RewardRate\\) benefits the nodes that consistently provide good FTSO data. Both the \\(VotePower\\) and the \\(RewardRate\\) are evaluated once a week based on the previous week's results. The plots below show the equalizing effect of this formula on actual data taken from flaremetrics.io in 2022 (some provider names might have changed): Left: Probabilities based solely on stake. Right: Probablities based on diminished stake and FTSO performance. As it is readily apparent, the distribution to the right is far more egalitarian, while still rewarding high stakes and FTSO performance.","title":"Validator Nodes"},{"location":"tech/validators/#validator-nodes","text":"Validator nodes are online servers running a blockchain's client software. They all keep a copy of the ledger and are constantly talking to each other to make sure the copies are consistent as new data is added. A network of validator nodes, each one with an identical copy of the ledger. The fact that the ledger is not under control of a single entity but distributed among a network of independent validators is what makes blockchains: Require less trust than traditional options. Censorship resistant. Byzantine fault tolerant . Validators agree on the state of the ledger using a consensus algorithm that varies for each blockchain. While the implementation of the groundbreaking FCP protocol is being completed, Flare is currently using a variant of Avalanche 's Snowman++ algorithm. In Avalanche's Snowman++, each round a validator is randomly selected to act as the leader and propose new blocks to be added to the ledger, which are then validated by the rest of nodes. To provide Sybil resistance , the probability of a node's being elected the leader is proportional to the node's stake , so this is effectively a Proof-of-Stake consensus. The shortcomings of Proof-of-stake are well known and include risk of centralization and the rich-get-richer effect , for example. To compensate for this, Flare's version of Snowman++ reduces the importance of a node's stake and introduces a meritocratic factor : All Flare validators are also FTSO Data Providers , so their performance in this role has an impact on their chance to become round leaders. More precisely, the probability \\(P\\) of being the leader depends both on a node's stake ( \\(VotePower\\) ) and on its performance as a Data Provider (evaluated through its \\(RewardRate\\) ) like this: \\[ P = \\log (VotePower) * RewardRate \\] And then normalized so the probabilities for all nodes add up to \\(1.0\\) . As it can be seen: The logarithm (which might be replaced by a square root or similar compressing function) reduces the importance of large stakes. Multiplying by the \\(RewardRate\\) benefits the nodes that consistently provide good FTSO data. Both the \\(VotePower\\) and the \\(RewardRate\\) are evaluated once a week based on the previous week's results. The plots below show the equalizing effect of this formula on actual data taken from flaremetrics.io in 2022 (some provider names might have changed): Left: Probabilities based solely on stake. Right: Probablities based on diminished stake and FTSO performance. As it is readily apparent, the distribution to the right is far more egalitarian, while still rewarding high stakes and FTSO performance.","title":"Validator Nodes"},{"location":"user/","text":"User Guides # This section contains step-by-step guides on how to use tools like the Block Explorer or the different wallets. Select one of the topics below: Automatic Claiming Block Explorers Claiming the FlareDrop FTSO Delegation Governance Personal Delegation Accounts Wallets Wrapping Tokens","title":"User Guides"},{"location":"user/#user-guides","text":"This section contains step-by-step guides on how to use tools like the Block Explorer or the different wallets. Select one of the topics below: Automatic Claiming Block Explorers Claiming the FlareDrop FTSO Delegation Governance Personal Delegation Accounts Wallets Wrapping Tokens","title":"User Guides"},{"location":"user/automatic-claiming/","text":"Automatic Claiming # To save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an executor to claim rewards for you. Executors then use automatic claiming to send rewards directly to your account. Introduction # To set an executor you only need to enter its address in the Flare Portal . However, the Flare Portal does not help you find executor addresses, so you must find them in different ways, depending on whether they are manual or registered: Manual executors are ones that you locate yourself. Whether they charge a fee or not and how you pay it is between you and the executor. Registered executors are listed in a smart contract and can be retrieved, for instance, using the block explorer or third-party applications. These executors charge a fee when you set them up and every time they claim for you. Overview of autoclaiming functionality For an overview of what is available for the entire autoclaiming feature, see Automatic Claiming in the Flare Fundamentals section. Prerequisite # To enable an executor, obtain its address off-chain or, for registered executors, on-chain. The list of registered executors has not been added yet to the Flare Portal, but a manual method is given below using the block explorer (recommended for advanced users). Find a registered executor (using the Block Explorer) To find an executor you will need to use the ClaimSetupManager contract. See the Contract Addresses page to learn how to find the address of this contract. In the Block Explorer , paste the address of the ClaimSetupManager contract and scroll down to select the Read Contract tab. To get the available executors' addresses, scroll down to getRegisteredExecutors and enter a range of how many addresses to check, for example, 0 in the _start field and 10 in the _end field. Click Query . The Block Explorer returns the addresses and the total number available, so you can know if you've gotten them all. To get the executor's fee, copy one address at a time and enter it in the executor field for getExecutorCurrentFeeValue . Click Query . In the future, there will be more criteria to help with making this decision. Choose an executor and copy its address. Enabling Automatic Claiming # Now that you have your desired executor's address, you can set it as the executor for your account. Open the Flare Portal . Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Flare Portal Main Account interface. In the Executor section, click Add or Change . Paste the executor's address. A message confirms the executor's fee, whether it is a registered executor, and whether rewards go to your Main Account or your Personal Delegation Account (PDA) . Set an executor. To set this executor, click Confirm . Your wallet opens with the details of the transaction. Review the transaction and confirm it. If you confirm the executor, the Flare Portal displays the executor address you have selected, whether it is registered, and its fee. Note also that the Add button now reads Change , enabling you to remove or change the executor any time you choose. The executor is confirmed. Reward must be high enough to pay the executor's fee If the reward amount is too low to accommodate the fee, automatic claims won't occur, so you may see small amounts of unclaimed rewards even if you have autoclaiming set up. Disabling Automatic Claiming # To disable automatic claiming and stop paying the executor fees, go through the above process again and clear the Executor address field in Step 4. This is, confirm an empty address. Once you confirm the transaction in your wallet, automatic claiming will be disabled. Checking for Accrued Rewards # To check if you have accrued rewards, go to the Flare Portal : Click Connect to Wallet and log into your wallet. Select your Main Account or Delegation Account , if you have enabled a PDA. At the bottom of the screen, see the Claim x FLR button, where x is the number of $FLR rewards you can claim. Note If the configured executor is doing its job correctly, you should never see any pending rewards.","title":"Automatic Claiming"},{"location":"user/automatic-claiming/#automatic-claiming","text":"To save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an executor to claim rewards for you. Executors then use automatic claiming to send rewards directly to your account.","title":"Automatic Claiming"},{"location":"user/automatic-claiming/#introduction","text":"To set an executor you only need to enter its address in the Flare Portal . However, the Flare Portal does not help you find executor addresses, so you must find them in different ways, depending on whether they are manual or registered: Manual executors are ones that you locate yourself. Whether they charge a fee or not and how you pay it is between you and the executor. Registered executors are listed in a smart contract and can be retrieved, for instance, using the block explorer or third-party applications. These executors charge a fee when you set them up and every time they claim for you. Overview of autoclaiming functionality For an overview of what is available for the entire autoclaiming feature, see Automatic Claiming in the Flare Fundamentals section.","title":"Introduction"},{"location":"user/automatic-claiming/#prerequisite","text":"To enable an executor, obtain its address off-chain or, for registered executors, on-chain. The list of registered executors has not been added yet to the Flare Portal, but a manual method is given below using the block explorer (recommended for advanced users). Find a registered executor (using the Block Explorer) To find an executor you will need to use the ClaimSetupManager contract. See the Contract Addresses page to learn how to find the address of this contract. In the Block Explorer , paste the address of the ClaimSetupManager contract and scroll down to select the Read Contract tab. To get the available executors' addresses, scroll down to getRegisteredExecutors and enter a range of how many addresses to check, for example, 0 in the _start field and 10 in the _end field. Click Query . The Block Explorer returns the addresses and the total number available, so you can know if you've gotten them all. To get the executor's fee, copy one address at a time and enter it in the executor field for getExecutorCurrentFeeValue . Click Query . In the future, there will be more criteria to help with making this decision. Choose an executor and copy its address.","title":"Prerequisite"},{"location":"user/automatic-claiming/#enabling-automatic-claiming","text":"Now that you have your desired executor's address, you can set it as the executor for your account. Open the Flare Portal . Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Flare Portal Main Account interface. In the Executor section, click Add or Change . Paste the executor's address. A message confirms the executor's fee, whether it is a registered executor, and whether rewards go to your Main Account or your Personal Delegation Account (PDA) . Set an executor. To set this executor, click Confirm . Your wallet opens with the details of the transaction. Review the transaction and confirm it. If you confirm the executor, the Flare Portal displays the executor address you have selected, whether it is registered, and its fee. Note also that the Add button now reads Change , enabling you to remove or change the executor any time you choose. The executor is confirmed. Reward must be high enough to pay the executor's fee If the reward amount is too low to accommodate the fee, automatic claims won't occur, so you may see small amounts of unclaimed rewards even if you have autoclaiming set up.","title":"Enabling Automatic Claiming"},{"location":"user/automatic-claiming/#disabling-automatic-claiming","text":"To disable automatic claiming and stop paying the executor fees, go through the above process again and clear the Executor address field in Step 4. This is, confirm an empty address. Once you confirm the transaction in your wallet, automatic claiming will be disabled.","title":"Disabling Automatic Claiming"},{"location":"user/automatic-claiming/#checking-for-accrued-rewards","text":"To check if you have accrued rewards, go to the Flare Portal : Click Connect to Wallet and log into your wallet. Select your Main Account or Delegation Account , if you have enabled a PDA. At the bottom of the screen, see the Claim x FLR button, where x is the number of $FLR rewards you can claim. Note If the configured executor is doing its job correctly, you should never see any pending rewards.","title":"Checking for Accrued Rewards"},{"location":"user/claiming-the-flaredrop/","text":"Claiming the FlareDrop # Claiming the FlareDrop is available every 30 days and is based on the average balance from the last 23 days of each 30-day month. Therefore, it is advised that each address claim its funds during the first 7 days of each 30-day round. See The FlareDrop concept page for further explanation. FlareDrop distribution dates. There are several ways to claim. You can claim: Using the Flare Portal . Through an executor , which you can configure using the Portal, or Directly against a smart contract (for advanced users). Two steps to ensure receiving all your $FLR ! You must: Wrap $FLR to receive it. Rewards are proportional to the $WFLR balance, not $FLR , so always wrap as much $FLR as you can! Wrapping has no downside: Wrapped tokens continue to be available for delegation and governance voting , for example, and they can be unwrapped at any time. See Wrapping Flare Tokens . Claim before the distribution expires. After the distribution becomes claimable, it expires in two bank months and a week (67 days). Claiming from the Flare Portal # Claim manually from the Flare Portal. From there, you can see how many $FLR tokens you have to claim and you can claim them. Go to the Flare Portal . Click Connect to Wallet and log into your wallet. Your Main Account is open by default. If you enabled a PDA and want to claim for it instead, click Delegation Account . Under Claim your FlareDrop distribution , any $FLR you have to claim displays on the button. Claim Your FlareDrop Distribution. Click the Claim button to claim your $FLR . A confirmation dialog opens. FlareDrop claiming confirmation. As a convenience, you have the choice to wrap your tokens after claiming them. In this way they are ready for the next FlareDrop or to be delegated to the FTSO system , for example. Click on the Claim All Distribution button and confirm the transaction on your wallet. Nominating Executors # Alternatively, you can assign an executor to claim the FlareDrop for you. This is useful for cold wallets but also for any users wishing to reduce their operational burden. See Automatic Claiming to learn how.","title":"Claiming the FlareDrop"},{"location":"user/claiming-the-flaredrop/#claiming-the-flaredrop","text":"Claiming the FlareDrop is available every 30 days and is based on the average balance from the last 23 days of each 30-day month. Therefore, it is advised that each address claim its funds during the first 7 days of each 30-day round. See The FlareDrop concept page for further explanation. FlareDrop distribution dates. There are several ways to claim. You can claim: Using the Flare Portal . Through an executor , which you can configure using the Portal, or Directly against a smart contract (for advanced users). Two steps to ensure receiving all your $FLR ! You must: Wrap $FLR to receive it. Rewards are proportional to the $WFLR balance, not $FLR , so always wrap as much $FLR as you can! Wrapping has no downside: Wrapped tokens continue to be available for delegation and governance voting , for example, and they can be unwrapped at any time. See Wrapping Flare Tokens . Claim before the distribution expires. After the distribution becomes claimable, it expires in two bank months and a week (67 days).","title":"Claiming the FlareDrop"},{"location":"user/claiming-the-flaredrop/#claiming-from-the-flare-portal","text":"Claim manually from the Flare Portal. From there, you can see how many $FLR tokens you have to claim and you can claim them. Go to the Flare Portal . Click Connect to Wallet and log into your wallet. Your Main Account is open by default. If you enabled a PDA and want to claim for it instead, click Delegation Account . Under Claim your FlareDrop distribution , any $FLR you have to claim displays on the button. Claim Your FlareDrop Distribution. Click the Claim button to claim your $FLR . A confirmation dialog opens. FlareDrop claiming confirmation. As a convenience, you have the choice to wrap your tokens after claiming them. In this way they are ready for the next FlareDrop or to be delegated to the FTSO system , for example. Click on the Claim All Distribution button and confirm the transaction on your wallet.","title":"Claiming from the Flare Portal"},{"location":"user/claiming-the-flaredrop/#nominating-executors","text":"Alternatively, you can assign an executor to claim the FlareDrop for you. This is useful for cold wallets but also for any users wishing to reduce their operational burden. See Automatic Claiming to learn how.","title":"Nominating Executors"},{"location":"user/personal-delegation-account/","text":"Personal Delegation Accounts # You can receive $WFLR rewards for making contributions to the Flare community, for example, by delegating your tokens to FTSO data providers. A Personal Delegation Account (PDA) allows you to keep these rewards temporarily separate from your main account, so that you can track them, for example, as a personal record or for tax purposes. In certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate. See the Concept page for more detail. Particularly, the balance of a PDA can still be redelegated to earn compounded interest and the governance votes it grants can be transferred to another address. If a PDA is enabled and you configured an executor , it automatically claims rewards for the main account and the PDA, and sends them to the PDA. Enabling a PDA # You can enable and disable your PDA at any time in the Flare Portal without any ill-effect, except the cost of the transaction fee. Open the Flare Portal . Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Main Account opens. To switch from the Main Account to your PDA, click Delegation Account . Click Enable . Enable a PDA. A popup appears with a short description of what a PDA is. Confirm enabling the PDA. Click Enable . Your wallet shows the details of the transaction. Review the transaction and confirm it. Once the PDA is enabled, the Flare Portal displays the PDA address and the initial 0.0 $WFLR balance. Your PDA is now ready to receive rewards! The PDA address is enabled. If a PDA is enabled and you configured an executor , it automatically claims rewards for the main account and the PDA, and sends them to the PDA. Operations available in a PDA # Other operations available are: Operation Description Disable You can Disable the PDA at any time. Disabling sends all $WFLR back to the main account to your $WFLR balance. Automatic claims from executors will go to the main account as well. Withdraw You can withdraw from your PDA at any time. Click Withdraw , enter the amount of $WFLR to withdraw, and click Withdraw again. The amount is sent to your main account to your $WFLR balance. Delegate You can delegate your rewards to FTSO data providers for compounded rewards. Transfer votes A PDA cannot vote on governance proposals directly, but it can transfer its votes to another address, including its main account. Click Transfer votes , click main account or enter an address to transfer to, and click Confirm . Claim FLR The Claim FLR button shows how many rewards you have to claim. Use this button to claim rewards yourself, or configure an executor from the main account tab to do that for you.","title":"Personal Delegation Accounts"},{"location":"user/personal-delegation-account/#personal-delegation-accounts","text":"You can receive $WFLR rewards for making contributions to the Flare community, for example, by delegating your tokens to FTSO data providers. A Personal Delegation Account (PDA) allows you to keep these rewards temporarily separate from your main account, so that you can track them, for example, as a personal record or for tax purposes. In certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate. See the Concept page for more detail. Particularly, the balance of a PDA can still be redelegated to earn compounded interest and the governance votes it grants can be transferred to another address. If a PDA is enabled and you configured an executor , it automatically claims rewards for the main account and the PDA, and sends them to the PDA.","title":"Personal Delegation Accounts"},{"location":"user/personal-delegation-account/#enabling-a-pda","text":"You can enable and disable your PDA at any time in the Flare Portal without any ill-effect, except the cost of the transaction fee. Open the Flare Portal . Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Main Account opens. To switch from the Main Account to your PDA, click Delegation Account . Click Enable . Enable a PDA. A popup appears with a short description of what a PDA is. Confirm enabling the PDA. Click Enable . Your wallet shows the details of the transaction. Review the transaction and confirm it. Once the PDA is enabled, the Flare Portal displays the PDA address and the initial 0.0 $WFLR balance. Your PDA is now ready to receive rewards! The PDA address is enabled. If a PDA is enabled and you configured an executor , it automatically claims rewards for the main account and the PDA, and sends them to the PDA.","title":"Enabling a PDA"},{"location":"user/personal-delegation-account/#operations-available-in-a-pda","text":"Other operations available are: Operation Description Disable You can Disable the PDA at any time. Disabling sends all $WFLR back to the main account to your $WFLR balance. Automatic claims from executors will go to the main account as well. Withdraw You can withdraw from your PDA at any time. Click Withdraw , enter the amount of $WFLR to withdraw, and click Withdraw again. The amount is sent to your main account to your $WFLR balance. Delegate You can delegate your rewards to FTSO data providers for compounded rewards. Transfer votes A PDA cannot vote on governance proposals directly, but it can transfer its votes to another address, including its main account. Click Transfer votes , click main account or enter an address to transfer to, and click Confirm . Claim FLR The Claim FLR button shows how many rewards you have to claim. Use this button to claim rewards yourself, or configure an executor from the main account tab to do that for you.","title":"Operations available in a PDA"},{"location":"user/wrapping-tokens/","text":"Wrapping Flare Tokens # This information explains how to wrap and unwrap native tokens on various Flare networks using the Flare Portal or the block explorer. Wrapped tokens are required to delegate your vote power to FTSO data providers and to vote on decisions that affect how Flare networks operate. When you complete the following steps for wrapping, your native tokens, such as $FLR and $SGB , are wrapped into $WFLR and $WSGB , respectively, so that you can participate in FTSO delegation and governance. When you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below. Using the Flare Portal # Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. Choose one of the following options: Wrap : Locate your balance of native tokens, and click Wrap . Never wrap all your tokens Wrapping and unwrapping tokens are transactions with fees to be paid in native tokens. Always leave some unwrapped tokens to pay for transaction fees. Specify the amount to wrap, and click Wrap again. Unwrap : Locate your balance of wrapped tokens, and click Unwrap . Specify the amount to unwrap, and click Unwrap again. Follow the steps to complete the transaction in your wallet. Your wrapped token balance is updated and displayed in the Flare Portal and your wallet. If your wrapped token balance is not displayed in your wallet, you must manually add the wrapped token so that your wallet recognizes it. Using the Block Explorer # This section is for advanced users. Open a block explorer . From the block explorer, follow the Retrieval from Blockchain procedure to find and open the WNat contract. Click Connect Wallet , and complete the steps to connect your wallet, ensuring you are on the network on which you will wrap tokens. Click the Write Contract tab, and use the following methods to wrap and unwrap tokens: deposit : Wraps the amount of native tokens you specify in the field. withdraw : Unwraps the amount of native tokens you specify in the field. Your token balance is updated and displayed in your wallet. If your wrapped token balance is not displayed in your wallet, you must manually add the wrapped token so that your wallet recognizes it. Adding Wrapped Tokens to Wallets # Your wrapped tokens are stored on the blockchain in a special ERC-20 smart contract called WNat , for Wrapped Native tokens. Some wallets, like the Bifrost Wallet , are aware of this contract and are therefore preconfigured to display $WFLR and $WSGB balances. Some other wallets, though, require you to configure them so that they can display wrapped-token balances. If your wallet doesn't display your wrapped-token balance, you need to configure it, either automatically or manually as described in the following procedures. Automatically # This is typically the fastest procedure, but might not work with all wallets. Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. On the Main Account tab, locate the Account heading and the Help icon, identified by a question mark. Flare Portal Account Help. Click the Help icon and click How do I add Wrapped Flare token to my wallet? . A Click here link for adding $WFLR to your wallet is displayed. Flare Portal Wrapping Help. Click Click here . Your wallet opens. Wallets typically ask you to accept the token. The exact instructions depend on your wallet. Follow the prompts in your wallet to add the wrapped token. Your wrapped token balance is displayed in your wallet. Manually # This section is for advanced users. If the automatic method did not work for you, most wallets can still be configured to recognize ERC-20 tokens through an Import tokens or Add custom asset menu, for example. The exact instructions depend on your wallet, but they generally just require you to locate the aforementioned menu and provide the address of the WNat contract. The wallet can usually then retrieve the token name, symbol, and number of decimals directly from the contract. See the Contract Addresses page to find the address of the WNat contract.","title":"Wrapping Flare Tokens"},{"location":"user/wrapping-tokens/#wrapping-flare-tokens","text":"This information explains how to wrap and unwrap native tokens on various Flare networks using the Flare Portal or the block explorer. Wrapped tokens are required to delegate your vote power to FTSO data providers and to vote on decisions that affect how Flare networks operate. When you complete the following steps for wrapping, your native tokens, such as $FLR and $SGB , are wrapped into $WFLR and $WSGB , respectively, so that you can participate in FTSO delegation and governance. When you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below.","title":"Wrapping Flare Tokens"},{"location":"user/wrapping-tokens/#using-the-flare-portal","text":"Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. Choose one of the following options: Wrap : Locate your balance of native tokens, and click Wrap . Never wrap all your tokens Wrapping and unwrapping tokens are transactions with fees to be paid in native tokens. Always leave some unwrapped tokens to pay for transaction fees. Specify the amount to wrap, and click Wrap again. Unwrap : Locate your balance of wrapped tokens, and click Unwrap . Specify the amount to unwrap, and click Unwrap again. Follow the steps to complete the transaction in your wallet. Your wrapped token balance is updated and displayed in the Flare Portal and your wallet. If your wrapped token balance is not displayed in your wallet, you must manually add the wrapped token so that your wallet recognizes it.","title":"Using the Flare Portal"},{"location":"user/wrapping-tokens/#using-the-block-explorer","text":"This section is for advanced users. Open a block explorer . From the block explorer, follow the Retrieval from Blockchain procedure to find and open the WNat contract. Click Connect Wallet , and complete the steps to connect your wallet, ensuring you are on the network on which you will wrap tokens. Click the Write Contract tab, and use the following methods to wrap and unwrap tokens: deposit : Wraps the amount of native tokens you specify in the field. withdraw : Unwraps the amount of native tokens you specify in the field. Your token balance is updated and displayed in your wallet. If your wrapped token balance is not displayed in your wallet, you must manually add the wrapped token so that your wallet recognizes it.","title":"Using the Block Explorer"},{"location":"user/wrapping-tokens/#adding-wrapped-tokens-to-wallets","text":"Your wrapped tokens are stored on the blockchain in a special ERC-20 smart contract called WNat , for Wrapped Native tokens. Some wallets, like the Bifrost Wallet , are aware of this contract and are therefore preconfigured to display $WFLR and $WSGB balances. Some other wallets, though, require you to configure them so that they can display wrapped-token balances. If your wallet doesn't display your wrapped-token balance, you need to configure it, either automatically or manually as described in the following procedures.","title":"Adding Wrapped Tokens to Wallets"},{"location":"user/wrapping-tokens/#automatically","text":"This is typically the fastest procedure, but might not work with all wallets. Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. On the Main Account tab, locate the Account heading and the Help icon, identified by a question mark. Flare Portal Account Help. Click the Help icon and click How do I add Wrapped Flare token to my wallet? . A Click here link for adding $WFLR to your wallet is displayed. Flare Portal Wrapping Help. Click Click here . Your wallet opens. Wallets typically ask you to accept the token. The exact instructions depend on your wallet. Follow the prompts in your wallet to add the wrapped token. Your wrapped token balance is displayed in your wallet.","title":"Automatically"},{"location":"user/wrapping-tokens/#manually","text":"This section is for advanced users. If the automatic method did not work for you, most wallets can still be configured to recognize ERC-20 tokens through an Import tokens or Add custom asset menu, for example. The exact instructions depend on your wallet, but they generally just require you to locate the aforementioned menu and provide the address of the WNat contract. The wallet can usually then retrieve the token name, symbol, and number of decimals directly from the contract. See the Contract Addresses page to find the address of the WNat contract.","title":"Manually"},{"location":"user/block-explorers/","text":"Block Explorers # Block explorers enable you to analyze transactions and interact with addresses on blockchains. Flare provides a block explorer for each of the networks in its ecosystem: Flare Explorer Songbird Explorer Coston Explorer Coston2 Explorer Topics # Finding the Reward Epoch Managing Delegations Managing Rewards Verifying the Vote-Power Block Viewing NFTs Viewing Token Balances Viewing Token Transfers Viewing Transactions Block Explorer Dashboard","title":"Block Explorers"},{"location":"user/block-explorers/#block-explorers","text":"Block explorers enable you to analyze transactions and interact with addresses on blockchains. Flare provides a block explorer for each of the networks in its ecosystem: Flare Explorer Songbird Explorer Coston Explorer Coston2 Explorer","title":"Block Explorers"},{"location":"user/block-explorers/#topics","text":"Finding the Reward Epoch Managing Delegations Managing Rewards Verifying the Vote-Power Block Viewing NFTs Viewing Token Balances Viewing Token Transfers Viewing Transactions Block Explorer Dashboard","title":"Topics"},{"location":"user/block-explorers/finding-reward-epoch/","text":"Finding the Reward Epoch # This page is for advanced users. Reward epochs are periods during which delegations rewards are accrued. Use the block explorer to find the current reward epoch, which you can use to find the epoch for which you can claim rewards and to determine the vote-power block for the next epoch. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. From the block explorer, follow the Retrieval from Blockchain procedure to find and open the FtsoManager contract. The Contract Address Details page is displayed. Click the Read Contract tab, and locate the getCurrentRewardEpoch method. The current reward epoch number is already displayed beside the function, as shown in the following example: Current Reward Epoch. In this example, the FTSO reward epoch is 80.","title":"Finding the Reward Epoch"},{"location":"user/block-explorers/finding-reward-epoch/#finding-the-reward-epoch","text":"This page is for advanced users. Reward epochs are periods during which delegations rewards are accrued. Use the block explorer to find the current reward epoch, which you can use to find the epoch for which you can claim rewards and to determine the vote-power block for the next epoch. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. From the block explorer, follow the Retrieval from Blockchain procedure to find and open the FtsoManager contract. The Contract Address Details page is displayed. Click the Read Contract tab, and locate the getCurrentRewardEpoch method. The current reward epoch number is already displayed beside the function, as shown in the following example: Current Reward Epoch. In this example, the FTSO reward epoch is 80.","title":"Finding the Reward Epoch"},{"location":"user/block-explorers/managing-delegations/","text":"Managing Delegations Using the Block Explorer # This page is for advanced users. When you make delegations to FTSO data providers , you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards. Use the following information to manage your vote-power delegations with the the block explorer, which provides many options but is more complex. Alternatively, if you prefer a simpler interface, use the Flare Portal . Prerequisites # Before you delegate your vote power, you must: Wrap your native tokens . Wrapped tokens are required to delegate your vote power to data providers. Choose 1 or 2 data providers. Multiple lists of data providers are available online, such as FlareMetrics . As you browse the lists, consider the factors that affect the potential for rewards . Understand how the timing of delegations affects rewards , and consider the implications about the vote-power snapshot that will affect your rewards. Delegating Your Vote Power # After you choose your data provider from the list of data providers , locate its address beneath its name, and copy it. To verify the address of the data provider, open a block explorer , paste the address in the search field, and click the same address displayed as the result. On the Transactions tab, a list of recently submitted SubmitHash and RevealPrices transactions are displayed to confirm that the data provider is operating. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the delegate method, and specify values for these parameters: _to(address) : The address for the data provider you copied in Step 1. _bips(uin256) : The percentage in basis points. For example, 10000 bips = 100%, and 5000 bips = 50%. Click Write to run the delegate method. Follow the steps to complete the transaction in your wallet. Delegation is complete. In the next reward epoch, your newly delegated tokens will be included in the calculation of your selected data provider's weight. If the data provider submits useful data and garners any rewards, you will be able to claim your share of the rewards when the reward epoch is over. Removing Delegations # Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the delegate method, change the value of _bips(uin256) for the data provider's address to 0, and click Write to run the method. Follow the steps to complete the transaction in your wallet. Redelegating Vote Power # Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the undelegateAll method, and click Write to run the method. Follow the steps to complete the transaction in your wallet. All your delegations are removed. Delegate to the data providers you've chosen by following the previous set of steps to delegate . Revoking Vote Power # You can immediately revoke your vote power from a malicious data provider. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the revokeDelegationAt method, and specify values for the following parameters: _who(address) : The address of the data provider from whom you will revoke your delegation. _blockNumber(uint256) : The block number at which your delegation will be revoked. Click Write to run the method. Follow the steps to complete the transaction in your wallet. Your delegation is immediately revoked.","title":"Managing Delegations"},{"location":"user/block-explorers/managing-delegations/#managing-delegations-using-the-block-explorer","text":"This page is for advanced users. When you make delegations to FTSO data providers , you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards. Use the following information to manage your vote-power delegations with the the block explorer, which provides many options but is more complex. Alternatively, if you prefer a simpler interface, use the Flare Portal .","title":"Managing Delegations Using the Block Explorer"},{"location":"user/block-explorers/managing-delegations/#prerequisites","text":"Before you delegate your vote power, you must: Wrap your native tokens . Wrapped tokens are required to delegate your vote power to data providers. Choose 1 or 2 data providers. Multiple lists of data providers are available online, such as FlareMetrics . As you browse the lists, consider the factors that affect the potential for rewards . Understand how the timing of delegations affects rewards , and consider the implications about the vote-power snapshot that will affect your rewards.","title":"Prerequisites"},{"location":"user/block-explorers/managing-delegations/#delegating-your-vote-power","text":"After you choose your data provider from the list of data providers , locate its address beneath its name, and copy it. To verify the address of the data provider, open a block explorer , paste the address in the search field, and click the same address displayed as the result. On the Transactions tab, a list of recently submitted SubmitHash and RevealPrices transactions are displayed to confirm that the data provider is operating. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the delegate method, and specify values for these parameters: _to(address) : The address for the data provider you copied in Step 1. _bips(uin256) : The percentage in basis points. For example, 10000 bips = 100%, and 5000 bips = 50%. Click Write to run the delegate method. Follow the steps to complete the transaction in your wallet. Delegation is complete. In the next reward epoch, your newly delegated tokens will be included in the calculation of your selected data provider's weight. If the data provider submits useful data and garners any rewards, you will be able to claim your share of the rewards when the reward epoch is over.","title":"Delegating Your Vote Power"},{"location":"user/block-explorers/managing-delegations/#removing-delegations","text":"Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the delegate method, change the value of _bips(uin256) for the data provider's address to 0, and click Write to run the method. Follow the steps to complete the transaction in your wallet.","title":"Removing Delegations"},{"location":"user/block-explorers/managing-delegations/#redelegating-vote-power","text":"Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the undelegateAll method, and click Write to run the method. Follow the steps to complete the transaction in your wallet. All your delegations are removed. Delegate to the data providers you've chosen by following the previous set of steps to delegate .","title":"Redelegating Vote Power"},{"location":"user/block-explorers/managing-delegations/#revoking-vote-power","text":"You can immediately revoke your vote power from a malicious data provider. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the WNat contract. The Contract Address Details page is displayed. Click the Write Contract tab, and then click Connect Wallet , as shown in the following image: Write Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the revokeDelegationAt method, and specify values for the following parameters: _who(address) : The address of the data provider from whom you will revoke your delegation. _blockNumber(uint256) : The block number at which your delegation will be revoked. Click Write to run the method. Follow the steps to complete the transaction in your wallet. Your delegation is immediately revoked.","title":"Revoking Vote Power"},{"location":"user/block-explorers/managing-rewards/","text":"Managing Rewards Using the Block Explorer # This page is for advanced users. Rewards are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch. Use the following information to check your reward balance and claim your rewards with the block explorer, which provides many options but is more complex. Alternatively, if you prefer a simple interface, use the Flare Portal . Checking Your Reward Balance # Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the FtsoRewardManager contract. The Contract Address Details page is displayed. Click the Read Contract tab, and then click Connect Wallet , as shown in the following image: Read Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the getStateOfRewards method, and specify values for the following parameters: _beneficiary(address) : The address to check for rewards. _rewardEpoch(uint256) : The epoch in which you want to check the address for rewards. To check rewards for the epoch currently in progress, get the current reward epoch . Click Query to run the getStateOfRewards method. The following information is returned: _dataProviders : List of providers to which the address delegated vote power during this epoch. _rewardAmounts : List of reward amounts from each delegation. _claimed : List of boolean values indicating whether each of the amounts has already been claimed. _claimable : Boolean value indicating whether rewards for the address are claimable. Rewards are claimable if they are not expired and the epoch has ended. The value of _claimable is independent of the value of _claimed. Claiming Your Rewards # Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the FtsoRewardManager contract. The Contract Address Details page is displayed. Click the Read Contract tab, and then click Connect Wallet , as shown in the following image: Read Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. In the next steps, you will check this wallet for accrued rewards. You can disconnect this wallet and connect a different wallet as frequently as necessary. Run the getEpochsWithUnclaimedRewards(beneficiary_address) method by clicking Query . A list of previous epochs with pending rewards to be claimed is returned. On the Write Contract tab, locate the claimReward method, and specify values for the following parameters: _recipient(address) : The address to which you want claimed rewards to be sent. It can be the address you used to connect your wallet to the block explorer or a different address. _rewardEpochs(uint256[]) : One or more epoch numbers retrieved in Step 5. Specify multiple epoch numbers in a comma-separated list enclosed by square brackets, such as [59,60] . Click Write to run the claimReward method. One of the following results occurs: The claimReward method prompts you to confirm the transaction. Go to Step 8. The claimReward method fails. For security reasons, the FtsoRewardManager contract contains a limited amount of tokens and is replenished periodically. Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the contract becomes empty. If you are unable to claim your rewards because the contract is empty, try again the next day . Follow the steps to confirm the transaction in your wallet. Your rewards are claimed, and your updated balance of native tokens is displayed.","title":"Managing Rewards"},{"location":"user/block-explorers/managing-rewards/#managing-rewards-using-the-block-explorer","text":"This page is for advanced users. Rewards are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch. Use the following information to check your reward balance and claim your rewards with the block explorer, which provides many options but is more complex. Alternatively, if you prefer a simple interface, use the Flare Portal .","title":"Managing Rewards Using the Block Explorer"},{"location":"user/block-explorers/managing-rewards/#checking-your-reward-balance","text":"Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the FtsoRewardManager contract. The Contract Address Details page is displayed. Click the Read Contract tab, and then click Connect Wallet , as shown in the following image: Read Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. Locate the getStateOfRewards method, and specify values for the following parameters: _beneficiary(address) : The address to check for rewards. _rewardEpoch(uint256) : The epoch in which you want to check the address for rewards. To check rewards for the epoch currently in progress, get the current reward epoch . Click Query to run the getStateOfRewards method. The following information is returned: _dataProviders : List of providers to which the address delegated vote power during this epoch. _rewardAmounts : List of reward amounts from each delegation. _claimed : List of boolean values indicating whether each of the amounts has already been claimed. _claimable : Boolean value indicating whether rewards for the address are claimable. Rewards are claimable if they are not expired and the epoch has ended. The value of _claimable is independent of the value of _claimed.","title":"Checking Your Reward Balance"},{"location":"user/block-explorers/managing-rewards/#claiming-your-rewards","text":"Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Follow the Retrieval from Blockchain procedure to find and open the FtsoRewardManager contract. The Contract Address Details page is displayed. Click the Read Contract tab, and then click Connect Wallet , as shown in the following image: Read Contract Tab and Connect Your Wallet. Complete the steps to connect your wallet. In the next steps, you will check this wallet for accrued rewards. You can disconnect this wallet and connect a different wallet as frequently as necessary. Run the getEpochsWithUnclaimedRewards(beneficiary_address) method by clicking Query . A list of previous epochs with pending rewards to be claimed is returned. On the Write Contract tab, locate the claimReward method, and specify values for the following parameters: _recipient(address) : The address to which you want claimed rewards to be sent. It can be the address you used to connect your wallet to the block explorer or a different address. _rewardEpochs(uint256[]) : One or more epoch numbers retrieved in Step 5. Specify multiple epoch numbers in a comma-separated list enclosed by square brackets, such as [59,60] . Click Write to run the claimReward method. One of the following results occurs: The claimReward method prompts you to confirm the transaction. Go to Step 8. The claimReward method fails. For security reasons, the FtsoRewardManager contract contains a limited amount of tokens and is replenished periodically. Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the contract becomes empty. If you are unable to claim your rewards because the contract is empty, try again the next day . Follow the steps to confirm the transaction in your wallet. Your rewards are claimed, and your updated balance of native tokens is displayed.","title":"Claiming Your Rewards"},{"location":"user/block-explorers/user-interface/","text":"Block Explorer Dashboard # Each block explorer provides a dashboard that includes the following elements: Block Explorer Dashboard. Navigation Bar Metrics Blocks Transactions Navigation Bar # Use the options in the navigation bar to explore the blockchain and toggle light and dark modes. Blocks : View recently created blocks and their constituent transactions. Transactions : View validated or pending transactions. Tokens : View a list of all the tokens on the blockchain or the addresses of wallets that hold a specific token. APIs : For web3 developers to retrieve blockchain data. Network : View the explorers for other networks in the Flare ecosystem. Display theme : Toggle between light and dark mode. Search : Search the blockchain by address, token symbol, token name, transaction hash, or block number. Metrics # The metrics section displays the following information: Gas tracker : The average amount of gas required to process a transaction on a Flare network. Gas is denominated in units of gwei, where 1,000,000,000 gwei equals one token on a Flare network. Average block time : The average time required to confirm a block. Total transactions : The total amount of verified transactions. Total blocks : The total amount of confirmed blocks. Wallet addresses : The total amount of wallets created on the network. Blocks # A block is a group of transactions submitted, validated, and recorded on the blockchain. Each block has a sequential ID and a number of transactions aggregated in the block. To view details about a block and the transactions it contains, click the block ID. Alternatively, view a continuous list of confirmed blocks as they occur by clicking View All Blocks . Blocks. Transactions # Transactions are the various actions you can take on a blockchain. They are categorized by the following types: Standard : Transfers of tokens between two wallets. Contract : Interactions between two smart contracts or a wallet and a smart contract. Contract transactions include delegating tokens, transferring tokens, wrapping and unwrapping tokens, and so on. Interactions between two smart contracts are internal transactions . Transaction Types.","title":"Block Explorer Dashboard"},{"location":"user/block-explorers/user-interface/#block-explorer-dashboard","text":"Each block explorer provides a dashboard that includes the following elements: Block Explorer Dashboard. Navigation Bar Metrics Blocks Transactions","title":"Block Explorer Dashboard"},{"location":"user/block-explorers/user-interface/#navigation-bar","text":"Use the options in the navigation bar to explore the blockchain and toggle light and dark modes. Blocks : View recently created blocks and their constituent transactions. Transactions : View validated or pending transactions. Tokens : View a list of all the tokens on the blockchain or the addresses of wallets that hold a specific token. APIs : For web3 developers to retrieve blockchain data. Network : View the explorers for other networks in the Flare ecosystem. Display theme : Toggle between light and dark mode. Search : Search the blockchain by address, token symbol, token name, transaction hash, or block number.","title":"Navigation Bar"},{"location":"user/block-explorers/user-interface/#metrics","text":"The metrics section displays the following information: Gas tracker : The average amount of gas required to process a transaction on a Flare network. Gas is denominated in units of gwei, where 1,000,000,000 gwei equals one token on a Flare network. Average block time : The average time required to confirm a block. Total transactions : The total amount of verified transactions. Total blocks : The total amount of confirmed blocks. Wallet addresses : The total amount of wallets created on the network.","title":"Metrics"},{"location":"user/block-explorers/user-interface/#blocks","text":"A block is a group of transactions submitted, validated, and recorded on the blockchain. Each block has a sequential ID and a number of transactions aggregated in the block. To view details about a block and the transactions it contains, click the block ID. Alternatively, view a continuous list of confirmed blocks as they occur by clicking View All Blocks . Blocks.","title":"Blocks"},{"location":"user/block-explorers/user-interface/#transactions","text":"Transactions are the various actions you can take on a blockchain. They are categorized by the following types: Standard : Transfers of tokens between two wallets. Contract : Interactions between two smart contracts or a wallet and a smart contract. Contract transactions include delegating tokens, transferring tokens, wrapping and unwrapping tokens, and so on. Interactions between two smart contracts are internal transactions . Transaction Types.","title":"Transactions"},{"location":"user/block-explorers/verifying-vote-power-block/","text":"Verifying the Vote-Power Block # This page is for advanced users. Use the block explorer to verify the vote-power block snapshot for a specific epoch. The snapshot indicates when your delegations are enacted. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. From the block explorer, follow the Retrieval from Blockchain procedure to find and open the FtsoManager contract. The Contract Address Details page is displayed. Click the Read Contract tab. On the Read Contract tab, locate the getRewardEpochVotePowerBlock method, and specify the epoch number. Click Query to run the getRewardEpochVotePowerBlock method. The block number that was used to determine the vote power for the next epoch is returned. Copy this block number, paste it into the Search field, and press Enter. The Block Details page is displayed. The timestamp is displayed, as shown in the following image: Vote-Power Block Snapshot. The displayed timestamp is the exact date and UTC time when vote power was locked during the epoch you specified.","title":"Verifying the Vote-Power Block"},{"location":"user/block-explorers/verifying-vote-power-block/#verifying-the-vote-power-block","text":"This page is for advanced users. Use the block explorer to verify the vote-power block snapshot for a specific epoch. The snapshot indicates when your delegations are enacted. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. From the block explorer, follow the Retrieval from Blockchain procedure to find and open the FtsoManager contract. The Contract Address Details page is displayed. Click the Read Contract tab. On the Read Contract tab, locate the getRewardEpochVotePowerBlock method, and specify the epoch number. Click Query to run the getRewardEpochVotePowerBlock method. The block number that was used to determine the vote power for the next epoch is returned. Copy this block number, paste it into the Search field, and press Enter. The Block Details page is displayed. The timestamp is displayed, as shown in the following image: Vote-Power Block Snapshot. The displayed timestamp is the exact date and UTC time when vote power was locked during the epoch you specified.","title":"Verifying the Vote-Power Block"},{"location":"user/block-explorers/viewing-nfts/","text":"Viewing NFTs # This page is for advanced users. Use the block explorer to view NFTs. Before you begin, ensure the status of the transaction to mint the NFT is Confirmed . Retrieve the transaction hash for the NFT. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Specify the NFT transaction hash from Step 1 in the Search field, and click the result. The Transaction Details page is displayed. Locate the Tokens Minted section. The value of the For parameter is the numerical ID for the NFT. Click the ID. The NFT collection page is displayed. In most cases, your NFT is displayed in the upper-right hand side of the page. However, if the NFT creator used public IPFS gateways or did not create the NFT according to the ERC-721 or ERC-1155 standards, the NFT might not display.","title":"Viewing NFTs"},{"location":"user/block-explorers/viewing-nfts/#viewing-nfts","text":"This page is for advanced users. Use the block explorer to view NFTs. Before you begin, ensure the status of the transaction to mint the NFT is Confirmed . Retrieve the transaction hash for the NFT. Open a block explorer for the appropriate network. The block explorer dashboard is displayed. Specify the NFT transaction hash from Step 1 in the Search field, and click the result. The Transaction Details page is displayed. Locate the Tokens Minted section. The value of the For parameter is the numerical ID for the NFT. Click the ID. The NFT collection page is displayed. In most cases, your NFT is displayed in the upper-right hand side of the page. However, if the NFT creator used public IPFS gateways or did not create the NFT according to the ERC-721 or ERC-1155 standards, the NFT might not display.","title":"Viewing NFTs"},{"location":"user/block-explorers/viewing-token-balances/","text":"Viewing Token Balances # This page is for advanced users. Use the block explorer to view the list of token balances at an address. Retrieve the address whose tokens you want to view. Open the block explorer for the appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed. Click the Tokens tab, as shown in the following image: Tokens. The address's $FLR balance and a list of the non-native tokens it contains are displayed. The list can include ERC-20, ERC-721, and ERC-1155 tokens. Balance History # Use the block explorer to view a historical chart of the native-token balance at the address. Retrieve the address whose tokens you want to view. Open the block explorer for the network appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed. Click the Coin Balance History tab, as shown in the following image: Coin Balance History. A chart that shows the history of the native token at the address and a list of associated blocks is displayed, as shown in the following image: Coin Balance Chart.","title":"Viewing Token Balances"},{"location":"user/block-explorers/viewing-token-balances/#viewing-token-balances","text":"This page is for advanced users. Use the block explorer to view the list of token balances at an address. Retrieve the address whose tokens you want to view. Open the block explorer for the appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed. Click the Tokens tab, as shown in the following image: Tokens. The address's $FLR balance and a list of the non-native tokens it contains are displayed. The list can include ERC-20, ERC-721, and ERC-1155 tokens.","title":"Viewing Token Balances"},{"location":"user/block-explorers/viewing-token-balances/#balance-history","text":"Use the block explorer to view a historical chart of the native-token balance at the address. Retrieve the address whose tokens you want to view. Open the block explorer for the network appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed. Click the Coin Balance History tab, as shown in the following image: Coin Balance History. A chart that shows the history of the native token at the address and a list of associated blocks is displayed, as shown in the following image: Coin Balance Chart.","title":"Balance History"},{"location":"user/block-explorers/viewing-token-transfers/","text":"Viewing Token Transfers # This page is for advanced users. Use the block explorer to view token transfers to and from an address. Retrieve the address whose token transfers you want to view. Open the block explorer for the appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed. Click the Token Transfers tab, as shown in the following image: Token Transfers. The Token Transfers list is displayed. Click the transaction hash for the token transfer you want to view. The following details about the transfer are displayed: Transaction Hash : A unique identifier that proves a transaction is verified and added to the blockchain. Result : The state of the transaction. The state is either Success , Pending , or Failed . Status : The status of the transaction. The status is either Confirmed or Unconfirmed . Block : The number of the block that contains the transaction. Timestamp : The date and time when the transaction was added to the blockchain and the amount of time required to confirm it. From : The address of the transaction sender. Interacted With (To) : The address of the contract that handles the transaction. Tokens Transferred From : The address that initiated the transaction with the contract. To : The address of the recipient of the token in the transaction. For : The symbol of the token and its quantity in the transaction. Value : The quantity of tokens sent. Transaction Fee : The total cost of the transaction. Gas Price : The price per unit of gas specified by the sender. Units are measured in gwei. Transaction Type : Gas Limit : The maximum amount of gas approved for the transaction. Max Fee Per Gas : The maximum total amount per unit of gas the sender would pay, including the base fee and priority fee. Max Priority Fee per Gas : The maximum fee per unit of gas specified by the sender to pay a validator to prioritize the transaction. This fee is also called a tip. Priority Fee/Tip : The priority fee specified by the sender to pay a validator to prioritize the transaction. Transaction Burnt Fee : The amount of $FLR burned for the transaction. Gas Used by Transaction : The actual amount of gas used by the transaction. Nonce Position : The transaction number from the sender's address. Each transaction made by an address increases the nonce by one. Raw Input : The hashed input of a transaction. This input accompanies the transaction to process it. Input : The relevant functions that were called and parameters used in the transaction.","title":"Viewing Token Transfers"},{"location":"user/block-explorers/viewing-token-transfers/#viewing-token-transfers","text":"This page is for advanced users. Use the block explorer to view token transfers to and from an address. Retrieve the address whose token transfers you want to view. Open the block explorer for the appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed. Click the Token Transfers tab, as shown in the following image: Token Transfers. The Token Transfers list is displayed. Click the transaction hash for the token transfer you want to view. The following details about the transfer are displayed: Transaction Hash : A unique identifier that proves a transaction is verified and added to the blockchain. Result : The state of the transaction. The state is either Success , Pending , or Failed . Status : The status of the transaction. The status is either Confirmed or Unconfirmed . Block : The number of the block that contains the transaction. Timestamp : The date and time when the transaction was added to the blockchain and the amount of time required to confirm it. From : The address of the transaction sender. Interacted With (To) : The address of the contract that handles the transaction. Tokens Transferred From : The address that initiated the transaction with the contract. To : The address of the recipient of the token in the transaction. For : The symbol of the token and its quantity in the transaction. Value : The quantity of tokens sent. Transaction Fee : The total cost of the transaction. Gas Price : The price per unit of gas specified by the sender. Units are measured in gwei. Transaction Type : Gas Limit : The maximum amount of gas approved for the transaction. Max Fee Per Gas : The maximum total amount per unit of gas the sender would pay, including the base fee and priority fee. Max Priority Fee per Gas : The maximum fee per unit of gas specified by the sender to pay a validator to prioritize the transaction. This fee is also called a tip. Priority Fee/Tip : The priority fee specified by the sender to pay a validator to prioritize the transaction. Transaction Burnt Fee : The amount of $FLR burned for the transaction. Gas Used by Transaction : The actual amount of gas used by the transaction. Nonce Position : The transaction number from the sender's address. Each transaction made by an address increases the nonce by one. Raw Input : The hashed input of a transaction. This input accompanies the transaction to process it. Input : The relevant functions that were called and parameters used in the transaction.","title":"Viewing Token Transfers"},{"location":"user/block-explorers/viewing-transactions/","text":"Viewing Transactions # This page is for advanced users. Use the block explorer to view transaction details that explain where the transactions exist on the blockchain, when they were processed, how much gas they consumed, and more. Retrieve the address whose transactions you want to view. Open the block explorer for the appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed, as shown in the following image. The preselected Transactions tab lists the transactions associated with the address. Transactions. Click the transaction hash, as shown in the following image, which highlights in sequence a standard transaction and a contract transaction . The listed transactions were made by the address you specified. Details about a transaction are displayed when you click a transaction hash. Transaction Hash. The Transaction Details page is displayed, as shown in the following image: Transaction Details. Transaction Details # The following transaction information is provided: Transaction Hash : A unique identifier that proves a transaction is verified and added to the blockchain. Result : The state of the transaction. The state is either Success , Pending , or Failed . Status : The status of the transaction. The status is either Confirmed or Unconfirmed . Block : The number of the block that contains the transaction. Timestamp : The date and time when the transaction was added to the blockchain and the amount of time required to confirm it. From : The address of the transaction sender. To : The address of the transaction recipient. Value : The quantity of tokens sent. Transaction Fee : The total cost of the transaction. Gas Price : The price per unit of gas specified by the sender. Units are measured in gwei. Transaction Type : Gas Limit : The maximum amount of gas approved for the transaction. Max Fee Per Gas : The maximum total amount per unit of gas the sender would pay, including the base fee and priority fee. Max Priority Fee per Gas : The maximum fee per unit of gas specified by the sender to pay a validator to prioritize the transaction. This fee is also called a tip. Priority Fee/Tip : The priority fee specified by the sender to pay a validator to prioritize the transaction. Transaction Burnt Fee : The amount of $FLR burned for the transaction. Gas Used by Transaction : The actual amount of gas used by the transaction. Nonce Position : The transaction number from the sender's address. Each transaction made by an address increases the nonce by one. The following elements are specific to contract transactions: Interacted With (To) : The address of the contract that handles the transaction. Tokens Minted From : The address that initiated the transaction with the contract. To : The address of the recipient of the token in the transaction. For : The symbol of the token and its quantity in the transaction. Raw Input : The hashed input of a transaction. This input accompanies the transaction to process it. Input # The Input section shows the methods that were called and the parameters used in the transaction. Internal Transactions # Internal transactions occur between multiple smart contracts. In some cases, tokens are transferred to a smart contract during an internal transaction. Locate the Internal Transactions tab, as shown in the following image: Internal Transactions. Click the transaction hash, as shown in the following image: Transaction Hash. The transaction details are displayed. Logs # Transaction logs show events that were trigged by smart contracts during a transaction and information related to those events. Click the Logs tab, as shown in the following image: Logs. The logs are displayed. Raw Trace # The raw trace shows all parameters and data related to a transaction. If errors occurred during the transaction, this information can be used to debug them. Click the Raw Trace tab, as shown in the following image: Raw Trace. The raw trace is displayed in JSON format.","title":"Viewing Transactions"},{"location":"user/block-explorers/viewing-transactions/#viewing-transactions","text":"This page is for advanced users. Use the block explorer to view transaction details that explain where the transactions exist on the blockchain, when they were processed, how much gas they consumed, and more. Retrieve the address whose transactions you want to view. Open the block explorer for the appropriate network. The block explorer dashboard is displayed. Insert the address from Step 1 into the Search field. If the address exists, it is highlighted in the results list. Click the highlighted address. The Address Details page is displayed, as shown in the following image. The preselected Transactions tab lists the transactions associated with the address. Transactions. Click the transaction hash, as shown in the following image, which highlights in sequence a standard transaction and a contract transaction . The listed transactions were made by the address you specified. Details about a transaction are displayed when you click a transaction hash. Transaction Hash. The Transaction Details page is displayed, as shown in the following image: Transaction Details.","title":"Viewing Transactions"},{"location":"user/block-explorers/viewing-transactions/#transaction-details","text":"The following transaction information is provided: Transaction Hash : A unique identifier that proves a transaction is verified and added to the blockchain. Result : The state of the transaction. The state is either Success , Pending , or Failed . Status : The status of the transaction. The status is either Confirmed or Unconfirmed . Block : The number of the block that contains the transaction. Timestamp : The date and time when the transaction was added to the blockchain and the amount of time required to confirm it. From : The address of the transaction sender. To : The address of the transaction recipient. Value : The quantity of tokens sent. Transaction Fee : The total cost of the transaction. Gas Price : The price per unit of gas specified by the sender. Units are measured in gwei. Transaction Type : Gas Limit : The maximum amount of gas approved for the transaction. Max Fee Per Gas : The maximum total amount per unit of gas the sender would pay, including the base fee and priority fee. Max Priority Fee per Gas : The maximum fee per unit of gas specified by the sender to pay a validator to prioritize the transaction. This fee is also called a tip. Priority Fee/Tip : The priority fee specified by the sender to pay a validator to prioritize the transaction. Transaction Burnt Fee : The amount of $FLR burned for the transaction. Gas Used by Transaction : The actual amount of gas used by the transaction. Nonce Position : The transaction number from the sender's address. Each transaction made by an address increases the nonce by one. The following elements are specific to contract transactions: Interacted With (To) : The address of the contract that handles the transaction. Tokens Minted From : The address that initiated the transaction with the contract. To : The address of the recipient of the token in the transaction. For : The symbol of the token and its quantity in the transaction. Raw Input : The hashed input of a transaction. This input accompanies the transaction to process it.","title":"Transaction Details"},{"location":"user/block-explorers/viewing-transactions/#input","text":"The Input section shows the methods that were called and the parameters used in the transaction.","title":"Input"},{"location":"user/block-explorers/viewing-transactions/#internal-transactions","text":"Internal transactions occur between multiple smart contracts. In some cases, tokens are transferred to a smart contract during an internal transaction. Locate the Internal Transactions tab, as shown in the following image: Internal Transactions. Click the transaction hash, as shown in the following image: Transaction Hash. The transaction details are displayed.","title":"Internal Transactions"},{"location":"user/block-explorers/viewing-transactions/#logs","text":"Transaction logs show events that were trigged by smart contracts during a transaction and information related to those events. Click the Logs tab, as shown in the following image: Logs. The logs are displayed.","title":"Logs"},{"location":"user/block-explorers/viewing-transactions/#raw-trace","text":"The raw trace shows all parameters and data related to a transaction. If errors occurred during the transaction, this information can be used to debug them. Click the Raw Trace tab, as shown in the following image: Raw Trace. The raw trace is displayed in JSON format.","title":"Raw Trace"},{"location":"user/delegation/","text":"FTSO Delegation # Select one of the topics below: Managing Delegations Managing Rewards","title":"FTSO Delegation"},{"location":"user/delegation/#ftso-delegation","text":"Select one of the topics below: Managing Delegations Managing Rewards","title":"FTSO Delegation"},{"location":"user/delegation/managing-delegations/","text":"Managing Delegations Using the Flare Portal # When you make delegations to data providers, you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards. This information explains how to manage your delegations using the Flare Portal . Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer , which provides more options but can be more complex. Using it is intended for advanced users. Prerequisites # Before you delegate your vote power, you must: Wrap your native tokens . Wrapped tokens are required to delegate your vote power to data providers. Choose 1 or 2 data providers. Multiple lists of data providers are available online, such as FlareMetrics . As you browse the lists, consider the factors that affect the potential for rewards . Understand how the timing of delegations affects rewards , and consider the following implications about the vote-power snapshot that will affect your rewards. Delegating Your Vote Power # Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. On the Main Account tab, locate the FTSO provider delegations field, and click Delegate . The Delegate FTSO providers window is displayed. Click the Main provider dropdown menu, click the data provider you want, and drag the slider to select the percentage of your vote power you want to delegate to the data provider. Delegate FTSO providers window. Optional : If you want to delegate to a second data provider, locate the Second (optional) provider field, and repeat step 3. Click Submit . Follow the steps to confirm the transaction in your wallet. Removing Delegations # Open the Flare Portal , connect your wallet, and ensure you are connected to the network you want. On the Main Account tab, locate the FTSO provider delegations field, and click Delegate . The Delegate FTSO providers window is displayed. Drag the slider to 0% for one or both of the data providers, and click Submit . Follow the steps to confirm the transaction in your wallet.","title":"Managing Delegations"},{"location":"user/delegation/managing-delegations/#managing-delegations-using-the-flare-portal","text":"When you make delegations to data providers, you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards. This information explains how to manage your delegations using the Flare Portal . Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer , which provides more options but can be more complex. Using it is intended for advanced users.","title":"Managing Delegations Using the Flare Portal"},{"location":"user/delegation/managing-delegations/#prerequisites","text":"Before you delegate your vote power, you must: Wrap your native tokens . Wrapped tokens are required to delegate your vote power to data providers. Choose 1 or 2 data providers. Multiple lists of data providers are available online, such as FlareMetrics . As you browse the lists, consider the factors that affect the potential for rewards . Understand how the timing of delegations affects rewards , and consider the following implications about the vote-power snapshot that will affect your rewards.","title":"Prerequisites"},{"location":"user/delegation/managing-delegations/#delegating-your-vote-power","text":"Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. On the Main Account tab, locate the FTSO provider delegations field, and click Delegate . The Delegate FTSO providers window is displayed. Click the Main provider dropdown menu, click the data provider you want, and drag the slider to select the percentage of your vote power you want to delegate to the data provider. Delegate FTSO providers window. Optional : If you want to delegate to a second data provider, locate the Second (optional) provider field, and repeat step 3. Click Submit . Follow the steps to confirm the transaction in your wallet.","title":"Delegating Your Vote Power"},{"location":"user/delegation/managing-delegations/#removing-delegations","text":"Open the Flare Portal , connect your wallet, and ensure you are connected to the network you want. On the Main Account tab, locate the FTSO provider delegations field, and click Delegate . The Delegate FTSO providers window is displayed. Drag the slider to 0% for one or both of the data providers, and click Submit . Follow the steps to confirm the transaction in your wallet.","title":"Removing Delegations"},{"location":"user/delegation/managing-rewards/","text":"Managing Rewards Using the Flare Portal # Rewards are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch. Use this information to claim FTSO delegation rewards by using the Flare Portal. Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer , which provides more options but can be more complex. Using it is intended for advanced users. Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. On the Main Account tab, locate the Claim your delegation rewards section to determine whether you have claimable rewards and whether those rewards can currently be claimed: If you have rewards to claim and the reward manager contains enough tokens, the Claim button is enabled and shows the amount of rewards you can claim. Go to Step 5. If you have rewards to claim, but the reward manager currently does not contain enough tokens, the Claim button shows the amount of rewards you can claim but is disabled. For security reasons, a limited amount of tokens is stored at a given time in the reward manager contract. Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the token storage is depleted. The storage is replenished periodically. If you are currently unable to claim your rewards because the storage is empty, try again the next day . If you don't have claimable rewards, the Claim button shows 0 and is disabled. The following image shows an account with claimable rewards: An account with claimable rewards. Click the Claim button. The Claim your delegation rewards window is displayed. Claim your delegation rewards. Optional : If you have enabled your personal delegation account , the option to send your rewards to the PDA is preselected by default. To send your rewards to the address that you connected to the Portal instead, deselect the option. Click Claim All Rewards to claim all available rewards for the listed epochs. Follow the steps to confirm the transaction in your wallet. Your rewards are claimed, and your updated balance of native tokens is displayed.","title":"Managing Rewards"},{"location":"user/delegation/managing-rewards/#managing-rewards-using-the-flare-portal","text":"Rewards are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch. Use this information to claim FTSO delegation rewards by using the Flare Portal. Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer , which provides more options but can be more complex. Using it is intended for advanced users. Open the Flare Portal . The home page is displayed. Flare Portal home. Click Connect to Wallet and log into your wallet. The interface to your Main Account opens. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network. Main Account on the Flare network. On the Main Account tab, locate the Claim your delegation rewards section to determine whether you have claimable rewards and whether those rewards can currently be claimed: If you have rewards to claim and the reward manager contains enough tokens, the Claim button is enabled and shows the amount of rewards you can claim. Go to Step 5. If you have rewards to claim, but the reward manager currently does not contain enough tokens, the Claim button shows the amount of rewards you can claim but is disabled. For security reasons, a limited amount of tokens is stored at a given time in the reward manager contract. Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the token storage is depleted. The storage is replenished periodically. If you are currently unable to claim your rewards because the storage is empty, try again the next day . If you don't have claimable rewards, the Claim button shows 0 and is disabled. The following image shows an account with claimable rewards: An account with claimable rewards. Click the Claim button. The Claim your delegation rewards window is displayed. Claim your delegation rewards. Optional : If you have enabled your personal delegation account , the option to send your rewards to the PDA is preselected by default. To send your rewards to the address that you connected to the Portal instead, deselect the option. Click Claim All Rewards to claim all available rewards for the listed epochs. Follow the steps to confirm the transaction in your wallet. Your rewards are claimed, and your updated balance of native tokens is displayed.","title":"Managing Rewards Using the Flare Portal"},{"location":"user/governance/","text":"Governance # This section contains information about participating in governance on the Flare and Songbird networks. Voting","title":"Governance"},{"location":"user/governance/#governance","text":"This section contains information about participating in governance on the Flare and Songbird networks. Voting","title":"Governance"},{"location":"user/governance/voting/","text":"Voting # An integral part of the governance process , voting is the way you influence decisions about how Flare and Songbird operate. This process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the Flare Portal to enable you to conveniently cast your vote. The following information is about voting on the Flare and Songbird networks. Ensure you have selected one of these networks in your wallet. Governance Process Summary # This section summarizes the voting process, which is explained in more detail in the Governance page . All changes to the Flare and Songbird networks are determined by the outcomes of votes on Flare Improvement Proposals and Songbird Testing Proposals . For now, all proposals are published by the Flare Foundation. On each network, each account can cast a number of votes equal to the amount of wrapped tokens it holds. Since this amount varies over time, a snapshot of all accounts is taken at a block randomly chosen before voting starts. This block is called the vote count block . Before snapshots are taken, a notice period occurs. If you need to wrap tokens before a voting, wrap them during this notice period so that they are always included in the snapshot . Tip It is worth noting that you can use the same wrapped tokens to simultaneously vote on proposals and delegate to FTSO data providers . Requirements # To vote on any proposal, you need an account that contains wrapped tokens. You can wrap your tokens by using the Flare Portal , as shown in the Getting Wrapped Tokens section below. Warning Only wrapped tokens held at the vote count block are considered towards your vote count. Tokens wrapped or received afterwards will not result in additional votes. If you need to wrap tokens, always do so during the notice period . Guide # 1. Connecting to the Portal # Copy the Flare Portal URL, since you will need it later: https://portal.flare.network The first step to use the portal is to connect your wallet to it, and the procedure is different for each wallet: Bifrost Wallet # Open Bifrost Wallet, log in, and click the web browser tab indicated by the four gray squares at the bottom of the screen. Paste the Flare Portal URL in the search field at the top of the window, and click Search . Click Connect to Wallet . Select Bifrost Wallet . Ensure either the Flare or Songbird network is selected in the pop-up window, and click Connect . Your wallet is now connected to the portal. MetaMask Mobile # Open MetaMask, and log in. Click the three-lines menu , and click Browser . Paste the Flare Portal URL in the search field at the top of the window, and click Go . Click Connect to Wallet , and click MetaMask . Your wallet is now connected to the portal. Ledger Nano S/X and Chrome # Connect to your Ledger device, and unlock it. Log into the MetaMask Chrome extension, and sync your Ledger device. Paste the Flare Portal URL in the search field at the top of the Chrome window, and click Enter . Click Connect to Wallet . Click MetaMask . Your wallet is now connected to the portal. MetaMask or Brave Wallet # Copy and paste the Flare Portal URL in the search bar at the top of your browser and press Enter . Click Connect to Wallet . Select MetaMask . Ensure the correct account address is selected and press Confirm . Your wallet is now connected to the portal. 2. Getting Wrapped Tokens # Wrapped tokens are required to vote. To wrap your tokens: On the Account tab in the Flare Portal, ensure you are connected to the network on which the proposal will be voted. Locate your token balance, and click Wrap . Specify the amount you want to wrap, and click Wrap . Never wrap all your tokens Always leave some unwrapped tokens to pay for transaction fees. Confirm the transaction in your wallet. Remember to wrap your tokens before voting starts, as explained in the Governance Process Summary section above. 3. Casting Your Vote # Important Wrapped tokens are required to vote. Depending on the network, ensure you have either $FLR or $SGB in the wallet you will use to vote. For more information, see Getting Wrapped Tokens . In the Flare Portal, select the Voting tab. The Governance Proposals page is displayed. Locate your current number of votes in the black box. If you have fewer votes than you expected, consider the warning in the Requirements section above. In the List of proposals , locate the proposal you want to vote on, and click on it . The selected proposal is displayed. Review the information in the Proposal info and Voting details sections. Cast your vote. All your available votes will be assigned to the option you specify: To vote in favor of the proposal, click Vote For . To vote for the proposal to be rejected, click Vote Against . After you sign the transaction, your vote is final and cannot be changed. To sign the transaction and lock your vote, click Confirm . Your contribution to this proposal is now complete. Transferring Votes # Votes can be transferred to another account while the wrapped tokens remain in your possession. This is useful, for example, if you have wrapped tokens in multiple self-custody wallets, since you can simplify your voting process by transferring all the votes to a single wallet. You can read all the details about transferring votes in the Governance page . By completing the following process, you are crediting another account with votes only; the tokens themselves stay in the original wallet. Copy the Flare or Songbird address you want to transfer votes to. On the Voting tab in the Flare Portal, locate your amount of current votes in the black box, and click Transfer votes . The Information about transferred votes window is displayed. Read the disclaimer, and click Transfer votes . The Transfer votes window is displayed. In the Transfer all my votes to field, paste the address from Step 1, and click Confirm . Click Confirm on your wallet to sign the transaction. Your votes are credited to the address you specified. The tokens themselves stay in the original address. Canceling vote transfers You can stop transferring your votes to another address, if you do so before the snapshot is taken. You can do so from the Transfer votes window using the Remove delegation button. This button is only available when you have previously transferred votes.","title":"Voting"},{"location":"user/governance/voting/#voting","text":"An integral part of the governance process , voting is the way you influence decisions about how Flare and Songbird operate. This process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the Flare Portal to enable you to conveniently cast your vote. The following information is about voting on the Flare and Songbird networks. Ensure you have selected one of these networks in your wallet.","title":"Voting"},{"location":"user/governance/voting/#governance-process-summary","text":"This section summarizes the voting process, which is explained in more detail in the Governance page . All changes to the Flare and Songbird networks are determined by the outcomes of votes on Flare Improvement Proposals and Songbird Testing Proposals . For now, all proposals are published by the Flare Foundation. On each network, each account can cast a number of votes equal to the amount of wrapped tokens it holds. Since this amount varies over time, a snapshot of all accounts is taken at a block randomly chosen before voting starts. This block is called the vote count block . Before snapshots are taken, a notice period occurs. If you need to wrap tokens before a voting, wrap them during this notice period so that they are always included in the snapshot . Tip It is worth noting that you can use the same wrapped tokens to simultaneously vote on proposals and delegate to FTSO data providers .","title":"Governance Process Summary"},{"location":"user/governance/voting/#requirements","text":"To vote on any proposal, you need an account that contains wrapped tokens. You can wrap your tokens by using the Flare Portal , as shown in the Getting Wrapped Tokens section below. Warning Only wrapped tokens held at the vote count block are considered towards your vote count. Tokens wrapped or received afterwards will not result in additional votes. If you need to wrap tokens, always do so during the notice period .","title":"Requirements"},{"location":"user/governance/voting/#guide","text":"","title":"Guide"},{"location":"user/governance/voting/#1-connecting-to-the-portal","text":"Copy the Flare Portal URL, since you will need it later: https://portal.flare.network The first step to use the portal is to connect your wallet to it, and the procedure is different for each wallet:","title":"1. Connecting to the Portal"},{"location":"user/governance/voting/#bifrost-wallet","text":"Open Bifrost Wallet, log in, and click the web browser tab indicated by the four gray squares at the bottom of the screen. Paste the Flare Portal URL in the search field at the top of the window, and click Search . Click Connect to Wallet . Select Bifrost Wallet . Ensure either the Flare or Songbird network is selected in the pop-up window, and click Connect . Your wallet is now connected to the portal.","title":"Bifrost Wallet"},{"location":"user/governance/voting/#metamask-mobile","text":"Open MetaMask, and log in. Click the three-lines menu , and click Browser . Paste the Flare Portal URL in the search field at the top of the window, and click Go . Click Connect to Wallet , and click MetaMask . Your wallet is now connected to the portal.","title":"MetaMask Mobile"},{"location":"user/governance/voting/#ledger-nano-sx-and-chrome","text":"Connect to your Ledger device, and unlock it. Log into the MetaMask Chrome extension, and sync your Ledger device. Paste the Flare Portal URL in the search field at the top of the Chrome window, and click Enter . Click Connect to Wallet . Click MetaMask . Your wallet is now connected to the portal.","title":"Ledger Nano S/X and Chrome"},{"location":"user/governance/voting/#metamask-or-brave-wallet","text":"Copy and paste the Flare Portal URL in the search bar at the top of your browser and press Enter . Click Connect to Wallet . Select MetaMask . Ensure the correct account address is selected and press Confirm . Your wallet is now connected to the portal.","title":"MetaMask or Brave Wallet"},{"location":"user/governance/voting/#2-getting-wrapped-tokens","text":"Wrapped tokens are required to vote. To wrap your tokens: On the Account tab in the Flare Portal, ensure you are connected to the network on which the proposal will be voted. Locate your token balance, and click Wrap . Specify the amount you want to wrap, and click Wrap . Never wrap all your tokens Always leave some unwrapped tokens to pay for transaction fees. Confirm the transaction in your wallet. Remember to wrap your tokens before voting starts, as explained in the Governance Process Summary section above.","title":"2. Getting Wrapped Tokens"},{"location":"user/governance/voting/#3-casting-your-vote","text":"Important Wrapped tokens are required to vote. Depending on the network, ensure you have either $FLR or $SGB in the wallet you will use to vote. For more information, see Getting Wrapped Tokens . In the Flare Portal, select the Voting tab. The Governance Proposals page is displayed. Locate your current number of votes in the black box. If you have fewer votes than you expected, consider the warning in the Requirements section above. In the List of proposals , locate the proposal you want to vote on, and click on it . The selected proposal is displayed. Review the information in the Proposal info and Voting details sections. Cast your vote. All your available votes will be assigned to the option you specify: To vote in favor of the proposal, click Vote For . To vote for the proposal to be rejected, click Vote Against . After you sign the transaction, your vote is final and cannot be changed. To sign the transaction and lock your vote, click Confirm . Your contribution to this proposal is now complete.","title":"3. Casting Your Vote"},{"location":"user/governance/voting/#transferring-votes","text":"Votes can be transferred to another account while the wrapped tokens remain in your possession. This is useful, for example, if you have wrapped tokens in multiple self-custody wallets, since you can simplify your voting process by transferring all the votes to a single wallet. You can read all the details about transferring votes in the Governance page . By completing the following process, you are crediting another account with votes only; the tokens themselves stay in the original wallet. Copy the Flare or Songbird address you want to transfer votes to. On the Voting tab in the Flare Portal, locate your amount of current votes in the black box, and click Transfer votes . The Information about transferred votes window is displayed. Read the disclaimer, and click Transfer votes . The Transfer votes window is displayed. In the Transfer all my votes to field, paste the address from Step 1, and click Confirm . Click Confirm on your wallet to sign the transaction. Your votes are credited to the address you specified. The tokens themselves stay in the original address. Canceling vote transfers You can stop transferring your votes to another address, if you do so before the snapshot is taken. You can do so from the Transfer votes window using the Remove delegation button. This button is only available when you have previously transferred votes.","title":"Transferring Votes"},{"location":"user/wallets/","text":"Wallets # Choose your wallet: Bifrost Wallet Brave Wallet D'CENT Wallet Enkrypt Wallet Ledger Nano X and Nano S MetaMask SafePal S1 Wallet Trezor T","title":"Wallets"},{"location":"user/wallets/#wallets","text":"Choose your wallet: Bifrost Wallet Brave Wallet D'CENT Wallet Enkrypt Wallet Ledger Nano X and Nano S MetaMask SafePal S1 Wallet Trezor T","title":"Wallets"},{"location":"user/wallets/bifrost-wallet/","text":"Bifrost Wallet # Bifrost Wallet is a noncustodial mobile wallet available for both Android and iOS. You can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare ( $FLR ) and Songbird ( $SGB ). Getting Started # Start by downloading Bifrost Wallet from the Apple App Store or Google Play Store and either create a new wallet or import an existing one from a recovery phrase. The official guides in the Bifrost Wallet help center may be of assistance. Please make sure you have installed at least version 0.4.5 XRP Airdrop Note that, once $FLR distribution begins , users who imported their Ethereum-style claim address into Bifrost to access the XRP airdrop will automatically see their tokens in the Flare asset row in the COINS section. Adding Flare Tokens # When your balance of any native or wrapped token on the Flare network or Songbird network is more than 0, Bifrost Wallet automatically displays the balance. No additional action is required. Wrap and Delegate # When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. To wrap and delegate your $FLR or $SGB tokens using Bifrost Wallet, see Bifrost's guide for wrapping and delegating $FLR and guide for wrapping and delegating $SGB . Alternatively, wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Bifrost Wallet"},{"location":"user/wallets/bifrost-wallet/#bifrost-wallet","text":"Bifrost Wallet is a noncustodial mobile wallet available for both Android and iOS. You can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare ( $FLR ) and Songbird ( $SGB ).","title":"Bifrost Wallet"},{"location":"user/wallets/bifrost-wallet/#getting-started","text":"Start by downloading Bifrost Wallet from the Apple App Store or Google Play Store and either create a new wallet or import an existing one from a recovery phrase. The official guides in the Bifrost Wallet help center may be of assistance. Please make sure you have installed at least version 0.4.5 XRP Airdrop Note that, once $FLR distribution begins , users who imported their Ethereum-style claim address into Bifrost to access the XRP airdrop will automatically see their tokens in the Flare asset row in the COINS section.","title":"Getting Started"},{"location":"user/wallets/bifrost-wallet/#adding-flare-tokens","text":"When your balance of any native or wrapped token on the Flare network or Songbird network is more than 0, Bifrost Wallet automatically displays the balance. No additional action is required.","title":"Adding Flare Tokens"},{"location":"user/wallets/bifrost-wallet/#wrap-and-delegate","text":"When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. To wrap and delegate your $FLR or $SGB tokens using Bifrost Wallet, see Bifrost's guide for wrapping and delegating $FLR and guide for wrapping and delegating $SGB . Alternatively, wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Wrap and Delegate"},{"location":"user/wallets/brave-wallet/","text":"Brave Wallet # Brave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird. Getting Started # To use Brave Wallet with Flare or Songbird, ensure you have: Downloaded Brave Browser to your computer, version 1.42.88 or later. Initialized a Brave wallet or restored an existing one. Protected your Brave wallet with a password. Backed up your crypto wallet with a 12-word recovery phrase. Adding Flare Tokens # After your wallet is set up, you need to connect to Flare's networks, which will add each network's native token to your listed assets. Open Brave browser on your computer. Navigate to Settings , and select Web3 from the list of options. In the box on the right, click Wallet Networks , and then click Add . Complete the following steps to set up the Flare network and Songbird network: Flare Songbird In the Search network field , select 0xe(14) Flare Mainnet , and verify that the displayed values match the values in this table: Network Setting Value The id of chain 0xe The name of chain Flare Mainnet Chain's currency name Flare Chain's currency symbol FLR Chain's currency decimals 18 RPC URLs https://flare-api.flare.network/ext/C/rpc Icon URLs (leave blank) Block explorer URLs https://flare-explorer.flare.network Click Submit . In the Search network field , select 0x13(19) Songbird Canary-Network , and verify that the displayed values match the values in the following table. Important Make sure the RPC node URL is https://songbird-api.flare.network/ext/C/rpc . Network Setting Value The id of chain 0x13 The name of chain Songbird Canary-Network Chain's currency name Songbird Chain's currency symbol SGB Chain's currency decimals 18 RPC URLs https://songbird-api.flare.network/ext/C/rpc Icon URLs (leave blank) Block explorer URLs https://songbird-explorer.flare.network Click Submit . Click Wallet . Specify your password, and click Unlock . On the left side of the screen beside Balance , click the drop-down menu and select Flare or Songbird . Connection to the network is complete, and your balance of native tokens on the selected network is displayed. With the previous steps completed, you now have access to the Flare network and Songbird Network and each network's native token, but you must complete an extra step for the wallet to recognize wrapped tokens, which are needed in a lot of operations. Wrap and Delegate # When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. Wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Brave Wallet"},{"location":"user/wallets/brave-wallet/#brave-wallet","text":"Brave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird.","title":"Brave Wallet"},{"location":"user/wallets/brave-wallet/#getting-started","text":"To use Brave Wallet with Flare or Songbird, ensure you have: Downloaded Brave Browser to your computer, version 1.42.88 or later. Initialized a Brave wallet or restored an existing one. Protected your Brave wallet with a password. Backed up your crypto wallet with a 12-word recovery phrase.","title":"Getting Started"},{"location":"user/wallets/brave-wallet/#adding-flare-tokens","text":"After your wallet is set up, you need to connect to Flare's networks, which will add each network's native token to your listed assets. Open Brave browser on your computer. Navigate to Settings , and select Web3 from the list of options. In the box on the right, click Wallet Networks , and then click Add . Complete the following steps to set up the Flare network and Songbird network: Flare Songbird In the Search network field , select 0xe(14) Flare Mainnet , and verify that the displayed values match the values in this table: Network Setting Value The id of chain 0xe The name of chain Flare Mainnet Chain's currency name Flare Chain's currency symbol FLR Chain's currency decimals 18 RPC URLs https://flare-api.flare.network/ext/C/rpc Icon URLs (leave blank) Block explorer URLs https://flare-explorer.flare.network Click Submit . In the Search network field , select 0x13(19) Songbird Canary-Network , and verify that the displayed values match the values in the following table. Important Make sure the RPC node URL is https://songbird-api.flare.network/ext/C/rpc . Network Setting Value The id of chain 0x13 The name of chain Songbird Canary-Network Chain's currency name Songbird Chain's currency symbol SGB Chain's currency decimals 18 RPC URLs https://songbird-api.flare.network/ext/C/rpc Icon URLs (leave blank) Block explorer URLs https://songbird-explorer.flare.network Click Submit . Click Wallet . Specify your password, and click Unlock . On the left side of the screen beside Balance , click the drop-down menu and select Flare or Songbird . Connection to the network is complete, and your balance of native tokens on the selected network is displayed. With the previous steps completed, you now have access to the Flare network and Songbird Network and each network's native token, but you must complete an extra step for the wallet to recognize wrapped tokens, which are needed in a lot of operations.","title":"Adding Flare Tokens"},{"location":"user/wallets/brave-wallet/#wrap-and-delegate","text":"When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. Wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Wrap and Delegate"},{"location":"user/wallets/dcent-wallet/","text":"D'CENT Wallet # D'CENT Biometric Wallet is a noncustodial hardware wallet and is considered one of the most secure ways to manage your crypto assets. Getting Started # Purchase a D'CENT Biometric hardware wallet from the official D'CENT shop or download their software wallet/mobile app from the Apple App Store or Google Play Store . Then either initialize a new wallet or import an existing one from a recovery phrase. The official D'CENT device setup help guides can be found here: https://userguide.dcentwallet.com/biometric-wallet/setting-up . Adding Flare Tokens # After your device is set up and synced with the mobile app, complete the following procedure to add native tokens $FLR and $SGB to your listed assets. Although this procedure also explains how to add the wrapped tokens $WFLR and $WSGB to your listed assets, you can automatically add $WFLR and $WSGB using the Flare Portal . Ensure the D'CENT biometric wallet is updated with the latest firmware, v2.24.0 or later. Login to your D'CENT mobile app and have your device turned on, unlocked, and paired via Bluetooth. Click the + sign on the bottom right of the Account tab. In the Search box, search for one of the following tokens to add, and select the result: Token Result Flare Flare (FLR) Songbird Songbird Token (SGB) Wrapped Flare Wrapped Flare (WFLR) Wrapped Songbird Wrapped Songbird (WSGB) Name your new account, and click Create . Repeat steps 4 and 5 for each token you want to add to the list of assets in your wallet. Wrap and Delegate # When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. You can wrap and delegate your $SGB using D'CENT's native FTSO Portal: Delegation instructions for the Flare network are awaiting confirmation. Click the Discovery tab at the bottom middle of the screen. Select the FTSO Portal from the menu then click Go . Choose the Songbird account you wish to use and click Connect . You will need to wrap your $SGB by clicking SGB \u2194\ufe0f WSGB marked in green near the top middle of the screen. Input the $SGB amount you want to wrap and click the green SGB \u2194\ufe0f WSGB box. Click Confirm and follow the prompts to sign the transaction with your hardware device. You can now delegate your $WSGB by clicking Add delegation . Select a provider and input the percentage of your $WSGB holdings you want to delegate to their service and press Delegate . Note Providers listed as a Partner have additional security features integrated with D'cent. Click Confirm and follow the prompts to sign the transaction with your hardware device. To add a second provider (up to two), repeat steps 7 through 9. Alternatively, wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"D'CENT Wallet"},{"location":"user/wallets/dcent-wallet/#dcent-wallet","text":"D'CENT Biometric Wallet is a noncustodial hardware wallet and is considered one of the most secure ways to manage your crypto assets.","title":"D'CENT Wallet"},{"location":"user/wallets/dcent-wallet/#getting-started","text":"Purchase a D'CENT Biometric hardware wallet from the official D'CENT shop or download their software wallet/mobile app from the Apple App Store or Google Play Store . Then either initialize a new wallet or import an existing one from a recovery phrase. The official D'CENT device setup help guides can be found here: https://userguide.dcentwallet.com/biometric-wallet/setting-up .","title":"Getting Started"},{"location":"user/wallets/dcent-wallet/#adding-flare-tokens","text":"After your device is set up and synced with the mobile app, complete the following procedure to add native tokens $FLR and $SGB to your listed assets. Although this procedure also explains how to add the wrapped tokens $WFLR and $WSGB to your listed assets, you can automatically add $WFLR and $WSGB using the Flare Portal . Ensure the D'CENT biometric wallet is updated with the latest firmware, v2.24.0 or later. Login to your D'CENT mobile app and have your device turned on, unlocked, and paired via Bluetooth. Click the + sign on the bottom right of the Account tab. In the Search box, search for one of the following tokens to add, and select the result: Token Result Flare Flare (FLR) Songbird Songbird Token (SGB) Wrapped Flare Wrapped Flare (WFLR) Wrapped Songbird Wrapped Songbird (WSGB) Name your new account, and click Create . Repeat steps 4 and 5 for each token you want to add to the list of assets in your wallet.","title":"Adding Flare Tokens"},{"location":"user/wallets/dcent-wallet/#wrap-and-delegate","text":"When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. You can wrap and delegate your $SGB using D'CENT's native FTSO Portal: Delegation instructions for the Flare network are awaiting confirmation. Click the Discovery tab at the bottom middle of the screen. Select the FTSO Portal from the menu then click Go . Choose the Songbird account you wish to use and click Connect . You will need to wrap your $SGB by clicking SGB \u2194\ufe0f WSGB marked in green near the top middle of the screen. Input the $SGB amount you want to wrap and click the green SGB \u2194\ufe0f WSGB box. Click Confirm and follow the prompts to sign the transaction with your hardware device. You can now delegate your $WSGB by clicking Add delegation . Select a provider and input the percentage of your $WSGB holdings you want to delegate to their service and press Delegate . Note Providers listed as a Partner have additional security features integrated with D'cent. Click Confirm and follow the prompts to sign the transaction with your hardware device. To add a second provider (up to two), repeat steps 7 through 9. Alternatively, wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Wrap and Delegate"},{"location":"user/wallets/enkrypt-wallet/","text":"Enkrypt Wallet # Enkrypt is a multichain , open-source and noncustodial wallet that tracks no data. It interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser. Getting Started # Install Enkrypt . Create a new wallet or import an existing wallet to Enkrypt. Securely back up your recovery phrase offline. Protect your Enkrypt wallet with a password. Adding Flare Tokens # After you set up your wallet, connect to Flare's networks, which will add each network's native token and wrapped token to your listed assets: Add Flare or Songbird as a custom network using these parameters: Flare Songbird From the main menu, click Manage networks . The Manage networks window is displayed. Click the sliders icon beside the Search networks field. Click Custom network . The Custom network window is displayed. Specify the following values: Network Setting Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Click Add network . Locate Flare Mainnet at the bottom of the list, and toggle the switch to enable your wallet to display your balance of $FLR . Follow these instructions for manually adding tokens to retrieve the WNat contract address, and copy it. Important The WNat contract address is different on each network. Ensure you copy the WNat contract address on the Flare network. With Flare Mainnet selected on the main menu in your Enkrypt wallet, click Add custom token . The Add a token window is displayed. In the Contract address field, paste the WNat contract address that you copied in step 6. Click Add token . The wrapped token $WFLR is added to your list of Flare assets. From the main menu, click Manage networks . The Manage networks window is displayed. Click the sliders icon beside the Search networks field. Click Custom network . The Custom network window is displayed. Specify the following values: Network Setting Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Click Add network . Locate Songbird Canary-Network at the bottom of the list, and toggle the switch to enable your wallet to display your balance of $SGB . Follow these instructions for manually adding tokens to retrieve the WNat contract address, and copy it. Important The WNat contract address is different on each network. Ensure you copy the WNat contract address on the Songbird network. With Songbird Canary-Network selected on the main menu in your Enkrypt wallet, click Add custom token . The Add a token window is displayed. In the Contract address field, paste the WNat contract address that you copied in step 6. Click Add token . The wrapped token $WSGB is added to your list of Songbird assets. Wrap and Delegate # When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. Wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Enkrypt Wallet"},{"location":"user/wallets/enkrypt-wallet/#enkrypt-wallet","text":"Enkrypt is a multichain , open-source and noncustodial wallet that tracks no data. It interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser.","title":"Enkrypt Wallet"},{"location":"user/wallets/enkrypt-wallet/#getting-started","text":"Install Enkrypt . Create a new wallet or import an existing wallet to Enkrypt. Securely back up your recovery phrase offline. Protect your Enkrypt wallet with a password.","title":"Getting Started"},{"location":"user/wallets/enkrypt-wallet/#adding-flare-tokens","text":"After you set up your wallet, connect to Flare's networks, which will add each network's native token and wrapped token to your listed assets: Add Flare or Songbird as a custom network using these parameters: Flare Songbird From the main menu, click Manage networks . The Manage networks window is displayed. Click the sliders icon beside the Search networks field. Click Custom network . The Custom network window is displayed. Specify the following values: Network Setting Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Click Add network . Locate Flare Mainnet at the bottom of the list, and toggle the switch to enable your wallet to display your balance of $FLR . Follow these instructions for manually adding tokens to retrieve the WNat contract address, and copy it. Important The WNat contract address is different on each network. Ensure you copy the WNat contract address on the Flare network. With Flare Mainnet selected on the main menu in your Enkrypt wallet, click Add custom token . The Add a token window is displayed. In the Contract address field, paste the WNat contract address that you copied in step 6. Click Add token . The wrapped token $WFLR is added to your list of Flare assets. From the main menu, click Manage networks . The Manage networks window is displayed. Click the sliders icon beside the Search networks field. Click Custom network . The Custom network window is displayed. Specify the following values: Network Setting Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Click Add network . Locate Songbird Canary-Network at the bottom of the list, and toggle the switch to enable your wallet to display your balance of $SGB . Follow these instructions for manually adding tokens to retrieve the WNat contract address, and copy it. Important The WNat contract address is different on each network. Ensure you copy the WNat contract address on the Songbird network. With Songbird Canary-Network selected on the main menu in your Enkrypt wallet, click Add custom token . The Add a token window is displayed. In the Contract address field, paste the WNat contract address that you copied in step 6. Click Add token . The wrapped token $WSGB is added to your list of Songbird assets.","title":"Adding Flare Tokens"},{"location":"user/wallets/enkrypt-wallet/#wrap-and-delegate","text":"When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. Wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Wrap and Delegate"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/","text":"Ledger Nano X and Nano S # Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions. This guide explains how to configure your Ledger device to use it through the MetaMask wallet. One-Time Setup # You only need to perform the steps in this section once. Installing MetaMask # Follow the MetaMask guide to install and configure the MetaMask wallet. Make sure MetaMask can show $FLR and $SGB tokens, and their wrapped $WFLR and $WSGB versions. Installing Ledger # Follow the Ledger instructions to: Install Ledger Live and open it. Initialize your Ledger device with a recovery phrase. Protect your Ledger device with a PIN code. Install the latest Ledger device firmware. Installing the Ethereum App # Flare is EVM -compatible, so it uses the Ethereum app on Ledger. After meeting the requirements above, install the Ethereum app on the device with the following steps: Open the Manager in Ledger Live. Connect and unlock your Ledger device. Enable the manager on your Ledger device by pressing both buttons. Find Ethereum (ETH) in the app catalog. Click the Install button of the app. Your Ledger device displays Processing\u2026 . The app installation is complete. Creating Accounts # After enabling access to Songbird and Flare in MetaMask, create one or more accounts. In MetaMask: Select Flare or Songbird in the network dropdown. Connect your Ledger device using USB. Open the Ethereum app on your Ledger device. If Ledger Live is still running on your computer, you must quit the app. Locate MetaMask's Settings and then Advanced settings. Ensure that the Preferred Ledger Connection Type is set to WebHID in the drop-down menu (it should be the case by default). Click your account image and Connect Hardware Wallet . A pop up box opens listing paired Human Interface Devices (HID). Highlight your Ledger S or Ledger X and click Connect . A random set of addresses opens that are available for your use. To create one or more accounts (for example, for different tokens or different purposes), select any account number or multiple account numbers and click Unlock . You have created one or more Ledger accounts to which you can send $FLR or $SGB tokens. Your $FLR and $SGB balance will be displayed on the MetaMask overview. Once the accounts contain $WFLR or $WSGB their balances will be shown too if you followed the Wrapping Flare Tokens guide. Note The Ledger Live desktop application, as of version 2.55, can show your $FLR and $SGB balances but NOT the wrapped $WFLR and $WSGB versions. The tokens are still in the account, but Ledger Live does not show them. Using Ledger with MetaMask # Now that you have the one-time setup complete, here are a few things you can do to get started using your new accounts. Receive tokens . To receive tokens, copy your account address and share it with the sender. Send tokens . To send tokens, click Send and enter the recipient address. Then enter the desired amount and click Next . MetaMask will ask you to confirm the transaction from the Ledger device. Confirm transactions . To confirm or reject a transaction, follow the on-screen instructions on your Ledger device. Warning Always review all transaction details on your Ledger device before confirming any transaction! To learn how to use Ledger, including signing transactions, go to Ledger.com .","title":"Ledger Nano X and Nano S"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#ledger-nano-x-and-nano-s","text":"Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions. This guide explains how to configure your Ledger device to use it through the MetaMask wallet.","title":"Ledger Nano X and Nano S"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#one-time-setup","text":"You only need to perform the steps in this section once.","title":"One-Time Setup"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#installing-metamask","text":"Follow the MetaMask guide to install and configure the MetaMask wallet. Make sure MetaMask can show $FLR and $SGB tokens, and their wrapped $WFLR and $WSGB versions.","title":"Installing MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#installing-ledger","text":"Follow the Ledger instructions to: Install Ledger Live and open it. Initialize your Ledger device with a recovery phrase. Protect your Ledger device with a PIN code. Install the latest Ledger device firmware.","title":"Installing Ledger"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#installing-the-ethereum-app","text":"Flare is EVM -compatible, so it uses the Ethereum app on Ledger. After meeting the requirements above, install the Ethereum app on the device with the following steps: Open the Manager in Ledger Live. Connect and unlock your Ledger device. Enable the manager on your Ledger device by pressing both buttons. Find Ethereum (ETH) in the app catalog. Click the Install button of the app. Your Ledger device displays Processing\u2026 . The app installation is complete.","title":"Installing the Ethereum App"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#creating-accounts","text":"After enabling access to Songbird and Flare in MetaMask, create one or more accounts. In MetaMask: Select Flare or Songbird in the network dropdown. Connect your Ledger device using USB. Open the Ethereum app on your Ledger device. If Ledger Live is still running on your computer, you must quit the app. Locate MetaMask's Settings and then Advanced settings. Ensure that the Preferred Ledger Connection Type is set to WebHID in the drop-down menu (it should be the case by default). Click your account image and Connect Hardware Wallet . A pop up box opens listing paired Human Interface Devices (HID). Highlight your Ledger S or Ledger X and click Connect . A random set of addresses opens that are available for your use. To create one or more accounts (for example, for different tokens or different purposes), select any account number or multiple account numbers and click Unlock . You have created one or more Ledger accounts to which you can send $FLR or $SGB tokens. Your $FLR and $SGB balance will be displayed on the MetaMask overview. Once the accounts contain $WFLR or $WSGB their balances will be shown too if you followed the Wrapping Flare Tokens guide. Note The Ledger Live desktop application, as of version 2.55, can show your $FLR and $SGB balances but NOT the wrapped $WFLR and $WSGB versions. The tokens are still in the account, but Ledger Live does not show them.","title":"Creating Accounts"},{"location":"user/wallets/how-to-access-flare-network-with-a-ledger-device/#using-ledger-with-metamask","text":"Now that you have the one-time setup complete, here are a few things you can do to get started using your new accounts. Receive tokens . To receive tokens, copy your account address and share it with the sender. Send tokens . To send tokens, click Send and enter the recipient address. Then enter the desired amount and click Next . MetaMask will ask you to confirm the transaction from the Ledger device. Confirm transactions . To confirm or reject a transaction, follow the on-screen instructions on your Ledger device. Warning Always review all transaction details on your Ledger device before confirming any transaction! To learn how to use Ledger, including signing transactions, go to Ledger.com .","title":"Using Ledger with MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/","text":"Trezor T # Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions. Getting Started # To use your Trezor device with Flare ( $FLR ) or Songbird ( $SGB ), first make sure that you have: Initialized your Trezor device with a recovery phrase. Protected your Trezor device with a PIN code. Trezor Suite is installed, open and ready to use. Enabled Ethereum under the Crypto tab in Trezor Suite. Installed the latest Trezor device firmware. Installed the latest version of Google Chrome . Installed the MetaMask browser extension . Use Trezor T Device with MetaMask # You can access Flare and Songbird by using your Trezor T with the MetaMask browser extension. Open the MetaMask browser extension in your browser. Click Custom RPC in the network dropdown. Songbird Flare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Click Save . Select Flare or Songbird in the network dropdown. Connect and unlock your Trezor device. Click your account image and Connect Hardware Wallet . Select Trezor and click Continue . Follow the on screen instructions to export your public key. Select your Account and click Unlock . Info Please note that the provided Flare RPC node is only for individuals and not for commercial use . Companies and developers may contact Flare Networks to arrange dedicated access. You will see your $FLR or $SGB balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next . Follow the on screen instructions to confirm or reject the transaction on your Trezor device. Warning Always review all transaction details on your Trezor device before confirming any transaction! Wrap and Delegate # Once connected to a Flare network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers. Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io .","title":"Trezor T"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#trezor-t","text":"Hardware wallets are considered among the more secure options to manage crypto assets and store private keys. Your crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.","title":"Trezor T"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#getting-started","text":"To use your Trezor device with Flare ( $FLR ) or Songbird ( $SGB ), first make sure that you have: Initialized your Trezor device with a recovery phrase. Protected your Trezor device with a PIN code. Trezor Suite is installed, open and ready to use. Enabled Ethereum under the Crypto tab in Trezor Suite. Installed the latest Trezor device firmware. Installed the latest version of Google Chrome . Installed the MetaMask browser extension .","title":"Getting Started"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#use-trezor-t-device-with-metamask","text":"You can access Flare and Songbird by using your Trezor T with the MetaMask browser extension. Open the MetaMask browser extension in your browser. Click Custom RPC in the network dropdown. Songbird Flare Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Click Save . Select Flare or Songbird in the network dropdown. Connect and unlock your Trezor device. Click your account image and Connect Hardware Wallet . Select Trezor and click Continue . Follow the on screen instructions to export your public key. Select your Account and click Unlock . Info Please note that the provided Flare RPC node is only for individuals and not for commercial use . Companies and developers may contact Flare Networks to arrange dedicated access. You will see your $FLR or $SGB balance on the overview. To receive tokens, copy your account address and share it with the sender. To send tokens, click Send and enter the recipient address, enter the desired amount and click Next . Follow the on screen instructions to confirm or reject the transaction on your Trezor device. Warning Always review all transaction details on your Trezor device before confirming any transaction!","title":"Use Trezor T Device with MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-a-trezor-device/#wrap-and-delegate","text":"Once connected to a Flare network, enter the address of the website or dapp you wish to use to wrap and delegate in the MetaMask browser. A few FTSO data providers have developed dApps integrated with their websites that allow users to wrap, delegate and claim SGB and Flare rewards. Delegating using this method is not exclusive to one specific provider, as these dapps allow you to choose from a number of different providers. Other providers have their own websites and are developing similar dapps. See the full list of active data providers on flaremetrics.io .","title":"Wrap and Delegate"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/","text":"MetaMask # The MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare. To do so, you need to first add a custom network to MetaMask, as explained in this guide. Make sure that you have securely backed up your recovery phrase before proceeding. Getting Started # To use MetaMask with Songbird or Flare, ensure you have: Installed the latest version of Google Chrome . Installed the MetaMask browser extension . Created a new wallet or imported an existing wallet to MetaMask. Securely backed up your recovery phrase offline. Protected your MetaMask with a password. Adding Flare Tokens # After you set up your wallet, add the native tokens $FLR and $SGB and the wrapped tokens $WFLR and $WSGB to your listed assets: Open the MetaMask browser extension. Unlock your MetaMask wallet with your password. Click the networks drop-down menu, and click Add network . In a browser tab, the Settings menu opens to the Networks section. Scroll to the bottom of the page, and click Add a network manually . Complete the following steps to set up the Flare network and Songbird network: Flare Songbird Specify the values from the following table to set up the Flare network, which will add the native $FLR token to your list of assets. Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Click Save . Follow these instructions to automatically add $WFLR to your listed assets. Specify the values from the following table to set up the Songbird network, which will add the native $SGB token to your list of assets. Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Click Save . Follow these instructions to automatically add $WSGB to your listed assets. Warning Always review all transaction details in MetaMask before confirming any transaction! Wrap and Delegate # When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. Wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#metamask","text":"The MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare. To do so, you need to first add a custom network to MetaMask, as explained in this guide. Make sure that you have securely backed up your recovery phrase before proceeding.","title":"MetaMask"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#getting-started","text":"To use MetaMask with Songbird or Flare, ensure you have: Installed the latest version of Google Chrome . Installed the MetaMask browser extension . Created a new wallet or imported an existing wallet to MetaMask. Securely backed up your recovery phrase offline. Protected your MetaMask with a password.","title":"Getting Started"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#adding-flare-tokens","text":"After you set up your wallet, add the native tokens $FLR and $SGB and the wrapped tokens $WFLR and $WSGB to your listed assets: Open the MetaMask browser extension. Unlock your MetaMask wallet with your password. Click the networks drop-down menu, and click Add network . In a browser tab, the Settings menu opens to the Networks section. Scroll to the bottom of the page, and click Add a network manually . Complete the following steps to set up the Flare network and Songbird network: Flare Songbird Specify the values from the following table to set up the Flare network, which will add the native $FLR token to your list of assets. Field Value Network Name Flare New RPC URL https://flare-api.flare.network/ext/C/rpc Chain ID 14 Currency Symbol FLR Block Explorer URL https://flare-explorer.flare.network Click Save . Follow these instructions to automatically add $WFLR to your listed assets. Specify the values from the following table to set up the Songbird network, which will add the native $SGB token to your list of assets. Field Value Network Name Songbird New RPC URL https://songbird-api.flare.network/ext/C/rpc Chain ID 19 Currency Symbol SGB Block Explorer URL https://songbird-explorer.flare.network Click Save . Follow these instructions to automatically add $WSGB to your listed assets. Warning Always review all transaction details in MetaMask before confirming any transaction!","title":"Adding Flare Tokens"},{"location":"user/wallets/how-to-access-flare-network-with-metamask/#wrap-and-delegate","text":"When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. Wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Wrap and Delegate"},{"location":"user/wallets/safepal-s1-wallet/","text":"SafePal S1 Wallet # SafePal S1 is a noncustodial hardware wallet that is considered one of the most secure ways to manage your crypto assets. Getting Started # Use of a SafePal S1 hardware wallet requires syncing the device with the mobile app. A step by step unboxing guide to initialize a new device/wallet, or import an existing one from a recovery phrase, can be found here: https://safepalsupport.zendesk.com/hc/en-us/articles/360046051752-How-to-Set-Up-a-S1-Hardware-Wallet . Adding Flare Tokens # After you set up your wallet, add the native tokens $FLR and $SGB and the wrapped token $WFLR to your listed assets. Important SafePal currently does not support the addition of wrapped Songbird ( $WSGB ) to wallets. Ensure the SafePal S1 is updated with the latest firmware, version V1.0.32 or later. Login to your SafePal mobile app and have your S1 device turned on and unlocked. Scroll to the bottom of your listed assets in the mobile app, and click Manage Coins . Click the Enter token or token contract address field. The Search window is displayed. Complete the following steps to add Flare and Songbird tokens to your wallet: Flare Songbird Scroll through the list of networks, and select Flare . In the Enter token or token contract address field, search for Flare . Click the plus sign (+) displayed beside FLR (Flare) . FLR (Flare) added to your list of assets, and the homepage is displayed. Scroll to the bottom of your listed assets in the mobile app, and click Manage Coins . Select Flare from the list of networks again, and search for Wrapped Flare . Click the plus sign (+) displayed beside WFLR (Flare) . WFLR (Flare) is added to your list of assets on the homepage. In the Enter token or token contract address field, search for Songbird . A list of Songbird tokens on various blockchains is displayed. Important Ignore all Songbird tokens categorized as BEP-20 and ERC-20. Click the plus sign (+) for this SGB (Songbird) token with the logo: SGB (Songbird) is added to your list of assets on the homepage. Wrap and Delegate # When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. You can use the SafePal mobile app to wrap and delegate your tokens: Open the SafePal mobile app and navigate to the built-in web browser by clicking the four squares at the bottom middle of the screen. Enter the address of the website or dapp you wish to use to wrap and delegate in the search bar at the top of the screen. Info These dapps are usually created by FTSO data providers , but some of them allow you to choose a different data provider to delegate to. Take a look at flaremetrics.io and pick the one you prefer. After copying and pasting the address, click the drop-down menu to the right of the search tab. Scroll down, select the Flare or Songbird networks, and click Go . A pop-up will appear notifying that you are being redirected to a third-party dapp. Press Confirm . Other data providers host similar websites or dapps for wrapping and delegation. See the full list of signal providers on Songbird at https://flaremetrics.io/ . Alternatively, wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"SafePal S1 Wallet"},{"location":"user/wallets/safepal-s1-wallet/#safepal-s1-wallet","text":"SafePal S1 is a noncustodial hardware wallet that is considered one of the most secure ways to manage your crypto assets.","title":"SafePal S1 Wallet"},{"location":"user/wallets/safepal-s1-wallet/#getting-started","text":"Use of a SafePal S1 hardware wallet requires syncing the device with the mobile app. A step by step unboxing guide to initialize a new device/wallet, or import an existing one from a recovery phrase, can be found here: https://safepalsupport.zendesk.com/hc/en-us/articles/360046051752-How-to-Set-Up-a-S1-Hardware-Wallet .","title":"Getting Started"},{"location":"user/wallets/safepal-s1-wallet/#adding-flare-tokens","text":"After you set up your wallet, add the native tokens $FLR and $SGB and the wrapped token $WFLR to your listed assets. Important SafePal currently does not support the addition of wrapped Songbird ( $WSGB ) to wallets. Ensure the SafePal S1 is updated with the latest firmware, version V1.0.32 or later. Login to your SafePal mobile app and have your S1 device turned on and unlocked. Scroll to the bottom of your listed assets in the mobile app, and click Manage Coins . Click the Enter token or token contract address field. The Search window is displayed. Complete the following steps to add Flare and Songbird tokens to your wallet: Flare Songbird Scroll through the list of networks, and select Flare . In the Enter token or token contract address field, search for Flare . Click the plus sign (+) displayed beside FLR (Flare) . FLR (Flare) added to your list of assets, and the homepage is displayed. Scroll to the bottom of your listed assets in the mobile app, and click Manage Coins . Select Flare from the list of networks again, and search for Wrapped Flare . Click the plus sign (+) displayed beside WFLR (Flare) . WFLR (Flare) is added to your list of assets on the homepage. In the Enter token or token contract address field, search for Songbird . A list of Songbird tokens on various blockchains is displayed. Important Ignore all Songbird tokens categorized as BEP-20 and ERC-20. Click the plus sign (+) for this SGB (Songbird) token with the logo: SGB (Songbird) is added to your list of assets on the homepage.","title":"Adding Flare Tokens"},{"location":"user/wallets/safepal-s1-wallet/#wrap-and-delegate","text":"When you delegate your vote power to FTSO data providers, you not only support the Flare ecosystem but also earn monetary rewards. You can use the SafePal mobile app to wrap and delegate your tokens: Open the SafePal mobile app and navigate to the built-in web browser by clicking the four squares at the bottom middle of the screen. Enter the address of the website or dapp you wish to use to wrap and delegate in the search bar at the top of the screen. Info These dapps are usually created by FTSO data providers , but some of them allow you to choose a different data provider to delegate to. Take a look at flaremetrics.io and pick the one you prefer. After copying and pasting the address, click the drop-down menu to the right of the search tab. Scroll down, select the Flare or Songbird networks, and click Go . A pop-up will appear notifying that you are being redirected to a third-party dapp. Press Confirm . Other data providers host similar websites or dapps for wrapping and delegation. See the full list of signal providers on Songbird at https://flaremetrics.io/ . Alternatively, wrap and delegate your $FLR or $SGB tokens using the Flare Portal . First, wrap your tokens , and then delegate them .","title":"Wrap and Delegate"}]}